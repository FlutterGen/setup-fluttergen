import {createRequire} from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0;i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path, options);
  }
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
  }
  module.exports = isexe;
  isexe.sync = sync;
  var fs = __require("fs");
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  module.exports = isexe;
  isexe.sync = sync;
  var fs = __require("fs");
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  function isexe(path, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path, options) {
    try {
      return core.sync(path, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
  var fs = __require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path = __require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0;i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, { pathExt: pathExtExe });
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform2 = options.platform || process.platform;
    if (platform2 !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env[getPathKey({ env })],
        pathExt: withoutPathExt ? path.delimiter : undefined
      });
    } catch (e) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  var path = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports, module) => {
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    arg = arg.replace(/(\\*)$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs.openSync(command, "r");
      fs.readSync(fd, buffer, 0, size, 0);
      fs.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  var fs = __require("fs");
  var shebangCommand = require_shebang_command();
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path.normalize(parsed.command);
      parsed.command = escape3.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape3.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: undefined,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  var path = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape3 = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  module.exports = parse;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  var isWin = process.platform === "win32";
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  function spawn(command, args, options) {
    const parsed = parse(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  var cp = __require("child_process");
  var parse = require_parse();
  var enoent = require_enoent();
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse;
  module.exports._enoent = enoent;
});

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports) => {
  function toCommandValue(input) {
    if (input === null || input === undefined) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
      return {};
    }
    return {
      title: annotationProperties.title,
      file: annotationProperties.file,
      line: annotationProperties.startLine,
      endLine: annotationProperties.endLine,
      col: annotationProperties.startColumn,
      endColumn: annotationProperties.endColumn
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toCommandProperties = exports.toCommandValue = undefined;
  exports.toCommandValue = toCommandValue;
  exports.toCommandProperties = toCommandProperties;
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports) => {
  function issueCommand(command4, properties, message2) {
    const cmd = new Command(command4, properties, message2);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  function issue(name, message2 = "") {
    issueCommand(name, {}, message2);
  }
  function escapeData(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.issue = exports.issueCommand = undefined;
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  exports.issueCommand = issueCommand;
  exports.issue = issue;
  var CMD_STRING = "::";

  class Command {
    constructor(command4, properties, message2) {
      if (!command4) {
        command4 = "missing.command";
      }
      this.command = command4;
      this.properties = properties;
      this.message = message2;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val2 = this.properties[key];
            if (val2) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val2)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  }
});

// node_modules/@actions/core/node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/@actions/core/node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate2(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate2;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringify(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i2 = 0;i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).substr(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v1(options3, buf, offset) {
    let i2 = buf && offset || 0;
    const b = buf || new Array(16);
    options3 = options3 || {};
    let node3 = options3.node || _nodeId;
    let clockseq = options3.clockseq !== undefined ? options3.clockseq : _clockseq;
    if (node3 == null || clockseq == null) {
      const seedBytes = options3.random || (options3.rng || _rng.default)();
      if (node3 == null) {
        node3 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options3.msecs !== undefined ? options3.msecs : Date.now();
    let nsecs = options3.nsecs !== undefined ? options3.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options3.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options3.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i2++] = tl >>> 24 & 255;
    b[i2++] = tl >>> 16 & 255;
    b[i2++] = tl >>> 8 & 255;
    b[i2++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i2++] = tmh >>> 8 & 255;
    b[i2++] = tmh & 255;
    b[i2++] = tmh >>> 24 & 15 | 16;
    b[i2++] = tmh >>> 16 & 255;
    b[i2++] = clockseq >>> 8 | 128;
    b[i2++] = clockseq & 255;
    for (let n2 = 0;n2 < 6; ++n2) {
      b[i2 + n2] = node3[n2];
    }
    return buf || (0, _stringify.default)(b);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i2 = 0;i2 < str.length; ++i2) {
      bytes.push(str.charCodeAt(i2));
    }
    return bytes;
  }
  function _default(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i2 = 0;i2 < 16; ++i2) {
          buf[offset + i2] = bytes[i2];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  exports.URL = exports.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse2());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/@actions/core/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4(options3, buf, offset) {
    options3 = options3 || {};
    const rnds = options3.random || (options3.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0;i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _default = v4;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version;
  exports.default = _default;
});

// node_modules/@actions/core/node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse2());
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports) => {
  function issueFileCommand(command4, message2) {
    const filePath = process.env[`GITHUB_${command4}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command4}`);
    }
    if (!fs.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message2)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    if (key.includes(delimiter)) {
      throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
      throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareKeyValueMessage = exports.issueFileCommand = undefined;
  var fs = __importStar(__require("fs"));
  var os = __importStar(__require("os"));
  var uuid_1 = require_dist();
  var utils_1 = require_utils();
  exports.issueFileCommand = issueFileCommand;
  exports.prepareKeyValueMessage = prepareKeyValueMessage;
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS((exports) => {
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return;
    }
  }
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkBypass = exports.getProxyUrl = undefined;
  exports.getProxyUrl = getProxyUrl;
  exports.checkBypass = checkBypass;

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports) => {
  function httpOverHttp(options3) {
    var agent = new TunnelingAgent(options3);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options3) {
    var agent = new TunnelingAgent(options3);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options3) {
    var agent = new TunnelingAgent(options3);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options3) {
    var agent = new TunnelingAgent(options3);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options3) {
    var self2 = this;
    self2.options = options3 || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port, localAddress) {
      var options4 = toOptions(host, port, localAddress);
      for (var i2 = 0, len = self2.requests.length;i2 < len; ++i2) {
        var pending = self2.requests[i2];
        if (pending.host === options4.host && pending.port === options4.port) {
          self2.requests.splice(i2, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  function createSecureSocket(options3, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options3, function(socket) {
      var hostHeader = options3.request.getHeader("host");
      var tlsOptions = mergeOptions2({}, self2.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options3.host
      });
      var secureSocket = tls.connect(0, tlsOptions);
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string") {
      return {
        host,
        port,
        localAddress
      };
    }
    return host;
  }
  function mergeOptions2(target) {
    for (var i2 = 1, len = arguments.length;i2 < len; ++i2) {
      var overrides = arguments[i2];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var net = __require("net");
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var events = __require("events");
  var assert = __require("assert");
  var util = __require("util");
  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self2 = this;
    var options3 = mergeOptions2({ request: req }, self2.options, toOptions(host, port, localAddress));
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push(options3);
      return;
    }
    self2.createSocket(options3, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      req.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, options3);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options3, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions2({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options3.host + ":" + options3.port,
      agent: false,
      headers: {
        host: options3.host + ":" + options3.port
      }
    });
    if (options3.localAddress) {
      connectOptions.localAddress = options3.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode !== 200) {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        socket.destroy();
        var error2 = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
        error2.code = "ECONNRESET";
        options3.request.emit("error", error2);
        self2.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug("got illegal response body from proxy");
        socket.destroy();
        var error2 = new Error("got illegal response body from proxy");
        error2.code = "ECONNRESET";
        options3.request.emit("error", error2);
        self2.removeSocket(placeholder);
        return;
      }
      debug("tunneling connection has established");
      self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
      var error2 = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
      error2.code = "ECONNRESET";
      options3.request.emit("error", error2);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  };
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.debug = debug;
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, ConnectTimeoutError);
      this.name = "ConnectTimeoutError";
      this.message = message2 || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message2 || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, HeadersOverflowError);
      this.name = "HeadersOverflowError";
      this.message = message2 || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message2 || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message2, statusCode, headers, body) {
      super(message2);
      Error.captureStackTrace(this, ResponseStatusCodeError);
      this.name = "ResponseStatusCodeError";
      this.message = message2 || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message2 || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message2 || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class RequestAbortedError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "AbortError";
      this.message = message2 || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message2 || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, RequestContentLengthMismatchError);
      this.name = "RequestContentLengthMismatchError";
      this.message = message2 || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message2 || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message2 || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message2 || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message2, socket) {
      super(message2);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message2 || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message2 || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "MissingUpstreamError";
      this.message = message2 || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message2, code, data) {
      super(message2);
      Error.captureStackTrace(this, HTTPParserError);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message2 || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }

  class RequestRetryError extends UndiciError {
    constructor(message2, code, { headers, data }) {
      super(message2);
      Error.captureStackTrace(this, RequestRetryError);
      this.name = "RequestRetryError";
      this.message = message2 || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
  }
  module.exports = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError
  };
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS((exports, module) => {
  var headerNameLowerCasedRecord = {};
  var wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i2 = 0;i2 < wellknownHeaderNames.length; ++i2) {
    const key = wellknownHeaderNames[i2];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  function nop() {
  }
  function isStream2(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!/^https?:/.test(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
      let path5 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/")) {
        origin = origin.substring(0, origin.length - 1);
      }
      if (path5 && !path5.startsWith("/")) {
        path5 = `/${path5}`;
      }
      url = new URL(origin + path5);
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert.strictEqual(typeof host, "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body) {
    if (body == null) {
      return 0;
    } else if (isStream2(body)) {
      const state = body._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  }
  function isDestroyed(stream4) {
    return !stream4 || !!(stream4.destroyed || stream4[kDestroyed]);
  }
  function isReadableAborted(stream4) {
    const state = stream4 && stream4._readableState;
    return isDestroyed(stream4) && state && !state.endEmitted;
  }
  function destroy(stream4, err) {
    if (stream4 == null || !isStream2(stream4) || isDestroyed(stream4)) {
      return;
    }
    if (typeof stream4.destroy === "function") {
      if (Object.getPrototypeOf(stream4).constructor === IncomingMessage) {
        stream4.socket = null;
      }
      stream4.destroy(err);
    } else if (err) {
      process.nextTick((stream5, err2) => {
        stream5.emit("error", err2);
      }, stream4, err);
    }
    if (stream4.destroyed !== true) {
      stream4[kDestroyed] = true;
    }
  }
  function parseKeepAliveTimeout(val2) {
    const m = val2.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return headerNameLowerCasedRecord[value] || value.toLowerCase();
  }
  function parseHeaders(headers, obj = {}) {
    if (!Array.isArray(headers))
      return headers;
    for (let i2 = 0;i2 < headers.length; i2 += 2) {
      const key = headers[i2].toString().toLowerCase();
      let val2 = obj[key];
      if (!val2) {
        if (Array.isArray(headers[i2 + 1])) {
          obj[key] = headers[i2 + 1].map((x) => x.toString("utf8"));
        } else {
          obj[key] = headers[i2 + 1].toString("utf8");
        }
      } else {
        if (!Array.isArray(val2)) {
          val2 = [val2];
          obj[key] = val2;
        }
        val2.push(headers[i2 + 1].toString("utf8"));
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers) {
    const ret = [];
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    for (let n2 = 0;n2 < headers.length; n2 += 2) {
      const key = headers[n2 + 0].toString();
      const val2 = headers[n2 + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
        ret.push(key, val2);
        hasContentLength = true;
      } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = ret.push(key, val2) - 1;
      } else {
        ret.push(key, val2);
      }
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream3.isDisturbed ? stream3.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
  }
  function isErrored(body) {
    return !!(body && (stream3.isErrored ? stream3.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
  }
  function isReadable(body) {
    return !!(body && (stream3.isReadable ? stream3.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  async function* convertIterableToBuffer(iterable2) {
    for await (const chunk of iterable2) {
      yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    }
  }
  function ReadableStreamFrom(iterable2) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    if (ReadableStream2.from) {
      return ReadableStream2.from(convertIterableToBuffer(iterable2));
    }
    let iterator;
    return new ReadableStream2({
      async start() {
        iterator = iterable2[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            controller.close();
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      }
    }, 0);
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function throwIfAborted(signal5) {
    if (!signal5) {
      return;
    }
    if (typeof signal5.throwIfAborted === "function") {
      signal5.throwIfAborted();
    } else {
      if (signal5.aborted) {
        const err = new Error("The operation was aborted");
        err.name = "AbortError";
        throw err;
      }
    }
  }
  function addAbortListener3(signal5, listener) {
    if ("addEventListener" in signal5) {
      signal5.addEventListener("abort", listener, { once: true });
      return () => signal5.removeEventListener("abort", listener);
    }
    signal5.addListener("abort", listener);
    return () => signal5.removeListener("abort", listener);
  }
  function toUSVString(val2) {
    if (hasToWellFormed) {
      return `${val2}`.toWellFormed();
    } else if (nodeUtil.toUSVString) {
      return nodeUtil.toUSVString(val2);
    }
    return `${val2}`;
  }
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  var assert = __require("assert");
  var { kDestroyed, kBodyUsed } = require_symbols();
  var { IncomingMessage } = __require("http");
  var stream3 = __require("stream");
  var net = __require("net");
  var { InvalidArgumentError } = require_errors();
  var { Blob: Blob2 } = __require("buffer");
  var nodeUtil = __require("util");
  var { stringify } = __require("querystring");
  var { headerNameLowerCasedRecord } = require_constants();
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  var ReadableStream2;
  var hasToWellFormed = !!String.prototype.toWellFormed;
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream: isStream2,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    addAbortListener: addAbortListener3,
    parseRangeHeader,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
  };
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS((exports, module) => {
  function onTimeout() {
    fastNow = Date.now();
    let len = fastTimers.length;
    let idx = 0;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer.state === 0) {
        timer.state = fastNow + timer.delay;
      } else if (timer.state > 0 && fastNow >= timer.state) {
        timer.state = -1;
        timer.callback(timer.opaque);
      }
      if (timer.state === -1) {
        timer.state = -2;
        if (idx !== len - 1) {
          fastTimers[idx] = fastTimers.pop();
        } else {
          fastTimers.pop();
        }
        len -= 1;
      } else {
        idx += 1;
      }
    }
    if (fastTimers.length > 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout && fastNowTimeout.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTimeout, 1000);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  }
  var fastNow = Date.now();
  var fastNowTimeout;
  var fastTimers = [];

  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback;
      this.delay = delay;
      this.opaque = opaque;
      this.state = -2;
      this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        fastTimers.push(this);
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, opaque) {
      return delay < 1000 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout3) {
      if (timeout3 instanceof Timeout) {
        timeout3.clear();
      } else {
        clearTimeout(timeout3);
      }
    }
  };
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  function SBMH(needle) {
    if (typeof needle === "string") {
      needle = Buffer.from(needle);
    }
    if (!Buffer.isBuffer(needle)) {
      throw new TypeError("The needle has to be a String or a Buffer.");
    }
    const needleLength = needle.length;
    if (needleLength === 0) {
      throw new Error("The needle cannot be an empty String/Buffer.");
    }
    if (needleLength > 256) {
      throw new Error("The needle cannot have a length bigger than 256.");
    }
    this.maxMatches = Infinity;
    this.matches = 0;
    this._occ = new Array(256).fill(needleLength);
    this._lookbehind_size = 0;
    this._needle = needle;
    this._bufpos = 0;
    this._lookbehind = Buffer.alloc(needleLength);
    for (var i2 = 0;i2 < needleLength - 1; ++i2) {
      this._occ[needle[i2]] = needleLength - 1 - i2;
    }
  }
  var EventEmitter2 = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  inherits(SBMH, EventEmitter2);
  SBMH.prototype.reset = function() {
    this._lookbehind_size = 0;
    this.matches = 0;
    this._bufpos = 0;
  };
  SBMH.prototype.push = function(chunk, pos) {
    if (!Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, "binary");
    }
    const chlen = chunk.length;
    this._bufpos = pos || 0;
    let r;
    while (r !== chlen && this.matches < this.maxMatches) {
      r = this._sbmh_feed(chunk);
    }
    return r;
  };
  SBMH.prototype._sbmh_feed = function(data) {
    const len = data.length;
    const needle = this._needle;
    const needleLength = needle.length;
    const lastNeedleChar = needle[needleLength - 1];
    let pos = -this._lookbehind_size;
    let ch;
    if (pos < 0) {
      while (pos < 0 && pos <= len - needleLength) {
        ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
        if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
          this._lookbehind_size = 0;
          ++this.matches;
          this.emit("info", true);
          return this._bufpos = pos + needleLength;
        }
        pos += this._occ[ch];
      }
      if (pos < 0) {
        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
          ++pos;
        }
      }
      if (pos >= 0) {
        this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
        this._lookbehind_size = 0;
      } else {
        const bytesToCutOff = this._lookbehind_size + pos;
        if (bytesToCutOff > 0) {
          this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
        }
        this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
        this._lookbehind_size -= bytesToCutOff;
        data.copy(this._lookbehind, this._lookbehind_size);
        this._lookbehind_size += len;
        this._bufpos = len;
        return len;
      }
    }
    pos += (pos >= 0) * this._bufpos;
    if (data.indexOf(needle, pos) !== -1) {
      pos = data.indexOf(needle, pos);
      ++this.matches;
      if (pos > 0) {
        this.emit("info", true, data, this._bufpos, pos);
      } else {
        this.emit("info", true);
      }
      return this._bufpos = pos + needleLength;
    } else {
      pos = len - needleLength;
    }
    while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) {
      ++pos;
    }
    if (pos < len) {
      data.copy(this._lookbehind, 0, pos, pos + (len - pos));
      this._lookbehind_size = len - pos;
    }
    if (pos > 0) {
      this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
    }
    this._bufpos = len;
    return len;
  };
  SBMH.prototype._sbmh_lookup_char = function(data, pos) {
    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
  };
  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
    for (var i2 = 0;i2 < len; ++i2) {
      if (this._sbmh_lookup_char(data, pos + i2) !== this._needle[i2]) {
        return false;
      }
    }
    return true;
  };
  module.exports = SBMH;
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS((exports, module) => {
  function PartStream(opts) {
    ReadableStream2.call(this, opts);
  }
  var inherits = __require("node:util").inherits;
  var ReadableStream2 = __require("node:stream").Readable;
  inherits(PartStream, ReadableStream2);
  PartStream.prototype._read = function(n2) {
  };
  module.exports = PartStream;
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS((exports, module) => {
  module.exports = function getLimit(limits, name, defaultLimit) {
    if (!limits || limits[name] === undefined || limits[name] === null) {
      return defaultLimit;
    }
    if (typeof limits[name] !== "number" || isNaN(limits[name])) {
      throw new TypeError("Limit " + name + " is not a valid number");
    }
    return limits[name];
  };
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS((exports, module) => {
  function HeaderParser(cfg) {
    EventEmitter2.call(this);
    cfg = cfg || {};
    const self2 = this;
    this.nread = 0;
    this.maxed = false;
    this.npairs = 0;
    this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000);
    this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
    this.buffer = "";
    this.header = {};
    this.finished = false;
    this.ss = new StreamSearch(B_DCRLF);
    this.ss.on("info", function(isMatch, data, start2, end) {
      if (data && !self2.maxed) {
        if (self2.nread + end - start2 >= self2.maxHeaderSize) {
          end = self2.maxHeaderSize - self2.nread + start2;
          self2.nread = self2.maxHeaderSize;
          self2.maxed = true;
        } else {
          self2.nread += end - start2;
        }
        self2.buffer += data.toString("binary", start2, end);
      }
      if (isMatch) {
        self2._finish();
      }
    });
  }
  var EventEmitter2 = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  var getLimit = require_getLimit();
  var StreamSearch = require_sbmh();
  var B_DCRLF = Buffer.from("\r\n\r\n");
  var RE_CRLF = /\r\n/g;
  var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  inherits(HeaderParser, EventEmitter2);
  HeaderParser.prototype.push = function(data) {
    const r = this.ss.push(data);
    if (this.finished) {
      return r;
    }
  };
  HeaderParser.prototype.reset = function() {
    this.finished = false;
    this.buffer = "";
    this.header = {};
    this.ss.reset();
  };
  HeaderParser.prototype._finish = function() {
    if (this.buffer) {
      this._parseHeader();
    }
    this.ss.matches = this.ss.maxMatches;
    const header = this.header;
    this.header = {};
    this.buffer = "";
    this.finished = true;
    this.nread = this.npairs = 0;
    this.maxed = false;
    this.emit("header", header);
  };
  HeaderParser.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs) {
      return;
    }
    const lines = this.buffer.split(RE_CRLF);
    const len = lines.length;
    let m, h2;
    for (var i2 = 0;i2 < len; ++i2) {
      if (lines[i2].length === 0) {
        continue;
      }
      if (lines[i2][0] === "\t" || lines[i2][0] === " ") {
        if (h2) {
          this.header[h2][this.header[h2].length - 1] += lines[i2];
          continue;
        }
      }
      const posColon = lines[i2].indexOf(":");
      if (posColon === -1 || posColon === 0) {
        return;
      }
      m = RE_HDR.exec(lines[i2]);
      h2 = m[1].toLowerCase();
      this.header[h2] = this.header[h2] || [];
      this.header[h2].push(m[2] || "");
      if (++this.npairs === this.maxHeaderPairs) {
        break;
      }
    }
  };
  module.exports = HeaderParser;
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS((exports, module) => {
  function Dicer(cfg) {
    if (!(this instanceof Dicer)) {
      return new Dicer(cfg);
    }
    WritableStream.call(this, cfg);
    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
      throw new TypeError("Boundary required");
    }
    if (typeof cfg.boundary === "string") {
      this.setBoundary(cfg.boundary);
    } else {
      this._bparser = undefined;
    }
    this._headerFirst = cfg.headerFirst;
    this._dashes = 0;
    this._parts = 0;
    this._finished = false;
    this._realFinish = false;
    this._isPreamble = true;
    this._justMatched = false;
    this._firstWrite = true;
    this._inHeader = true;
    this._part = undefined;
    this._cb = undefined;
    this._ignoreData = false;
    this._partOpts = { highWaterMark: cfg.partHwm };
    this._pause = false;
    const self2 = this;
    this._hparser = new HeaderParser(cfg);
    this._hparser.on("header", function(header) {
      self2._inHeader = false;
      self2._part.emit("header", header);
    });
  }
  var WritableStream = __require("node:stream").Writable;
  var inherits = __require("node:util").inherits;
  var StreamSearch = require_sbmh();
  var PartStream = require_PartStream();
  var HeaderParser = require_HeaderParser();
  var DASH = 45;
  var B_ONEDASH = Buffer.from("-");
  var B_CRLF = Buffer.from("\r\n");
  var EMPTY_FN = function() {
  };
  inherits(Dicer, WritableStream);
  Dicer.prototype.emit = function(ev) {
    if (ev === "finish" && !this._realFinish) {
      if (!this._finished) {
        const self2 = this;
        process.nextTick(function() {
          self2.emit("error", new Error("Unexpected end of multipart data"));
          if (self2._part && !self2._ignoreData) {
            const type15 = self2._isPreamble ? "Preamble" : "Part";
            self2._part.emit("error", new Error(type15 + " terminated early due to unexpected end of multipart data"));
            self2._part.push(null);
            process.nextTick(function() {
              self2._realFinish = true;
              self2.emit("finish");
              self2._realFinish = false;
            });
            return;
          }
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        });
      }
    } else {
      WritableStream.prototype.emit.apply(this, arguments);
    }
  };
  Dicer.prototype._write = function(data, encoding, cb) {
    if (!this._hparser && !this._bparser) {
      return cb();
    }
    if (this._headerFirst && this._isPreamble) {
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        if (this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else {
          this._ignore();
        }
      }
      const r = this._hparser.push(data);
      if (!this._inHeader && r !== undefined && r < data.length) {
        data = data.slice(r);
      } else {
        return cb();
      }
    }
    if (this._firstWrite) {
      this._bparser.push(B_CRLF);
      this._firstWrite = false;
    }
    this._bparser.push(data);
    if (this._pause) {
      this._cb = cb;
    } else {
      cb();
    }
  };
  Dicer.prototype.reset = function() {
    this._part = undefined;
    this._bparser = undefined;
    this._hparser = undefined;
  };
  Dicer.prototype.setBoundary = function(boundary) {
    const self2 = this;
    this._bparser = new StreamSearch("\r\n--" + boundary);
    this._bparser.on("info", function(isMatch, data, start2, end) {
      self2._oninfo(isMatch, data, start2, end);
    });
  };
  Dicer.prototype._ignore = function() {
    if (this._part && !this._ignoreData) {
      this._ignoreData = true;
      this._part.on("error", EMPTY_FN);
      this._part.resume();
    }
  };
  Dicer.prototype._oninfo = function(isMatch, data, start2, end) {
    let buf;
    const self2 = this;
    let i2 = 0;
    let r;
    let shouldWriteMore = true;
    if (!this._part && this._justMatched && data) {
      while (this._dashes < 2 && start2 + i2 < end) {
        if (data[start2 + i2] === DASH) {
          ++i2;
          ++this._dashes;
        } else {
          if (this._dashes) {
            buf = B_ONEDASH;
          }
          this._dashes = 0;
          break;
        }
      }
      if (this._dashes === 2) {
        if (start2 + i2 < end && this.listenerCount("trailer") !== 0) {
          this.emit("trailer", data.slice(start2 + i2, end));
        }
        this.reset();
        this._finished = true;
        if (self2._parts === 0) {
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        }
      }
      if (this._dashes) {
        return;
      }
    }
    if (this._justMatched) {
      this._justMatched = false;
    }
    if (!this._part) {
      this._part = new PartStream(this._partOpts);
      this._part._read = function(n2) {
        self2._unpause();
      };
      if (this._isPreamble && this.listenerCount("preamble") !== 0) {
        this.emit("preamble", this._part);
      } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
        this.emit("part", this._part);
      } else {
        this._ignore();
      }
      if (!this._isPreamble) {
        this._inHeader = true;
      }
    }
    if (data && start2 < end && !this._ignoreData) {
      if (this._isPreamble || !this._inHeader) {
        if (buf) {
          shouldWriteMore = this._part.push(buf);
        }
        shouldWriteMore = this._part.push(data.slice(start2, end));
        if (!shouldWriteMore) {
          this._pause = true;
        }
      } else if (!this._isPreamble && this._inHeader) {
        if (buf) {
          this._hparser.push(buf);
        }
        r = this._hparser.push(data.slice(start2, end));
        if (!this._inHeader && r !== undefined && r < end) {
          this._oninfo(false, data, start2 + r, end);
        }
      }
    }
    if (isMatch) {
      this._hparser.reset();
      if (this._isPreamble) {
        this._isPreamble = false;
      } else {
        if (start2 !== end) {
          ++this._parts;
          this._part.on("end", function() {
            if (--self2._parts === 0) {
              if (self2._finished) {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              } else {
                self2._unpause();
              }
            }
          });
        }
      }
      this._part.push(null);
      this._part = undefined;
      this._ignoreData = false;
      this._justMatched = true;
      this._dashes = 0;
    }
  };
  Dicer.prototype._unpause = function() {
    if (!this._pause) {
      return;
    }
    this._pause = false;
    if (this._cb) {
      const cb = this._cb;
      this._cb = undefined;
      cb();
    }
  };
  module.exports = Dicer;
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS((exports, module) => {
  function getDecoder(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  }
  function decodeText(text, sourceEncoding, destEncoding) {
    if (text) {
      return getDecoder(destEncoding)(text, sourceEncoding);
    }
    return text;
  }
  var utf8Decoder = new TextDecoder("utf-8");
  var textDecoders = new Map([
    ["utf-8", utf8Decoder],
    ["utf8", utf8Decoder]
  ]);
  var decoders = {
    utf8: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        return data;
      }
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.base64Slice(0, data.length);
    },
    other: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      if (textDecoders.has(exports.toString())) {
        try {
          return textDecoders.get(exports).decode(data);
        } catch {
        }
      }
      return typeof data === "string" ? data : data.toString();
    }
  };
  module.exports = decodeText;
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS((exports, module) => {
  function encodedReplacer(match) {
    return EncodedLookup[match];
  }
  function parseParams(str) {
    const res = [];
    let state = STATE_KEY;
    let charset = "";
    let inquote = false;
    let escaping = false;
    let p = 0;
    let tmp = "";
    const len = str.length;
    for (var i2 = 0;i2 < len; ++i2) {
      const char = str[i2];
      if (char === "\\" && inquote) {
        if (escaping) {
          escaping = false;
        } else {
          escaping = true;
          continue;
        }
      } else if (char === '"') {
        if (!escaping) {
          if (inquote) {
            inquote = false;
            state = STATE_KEY;
          } else {
            inquote = true;
          }
          continue;
        } else {
          escaping = false;
        }
      } else {
        if (escaping && inquote) {
          tmp += "\\";
        }
        escaping = false;
        if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
          if (state === STATE_CHARSET) {
            state = STATE_LANG;
            charset = tmp.substring(1);
          } else {
            state = STATE_VALUE;
          }
          tmp = "";
          continue;
        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
          state = char === "*" ? STATE_CHARSET : STATE_VALUE;
          res[p] = [tmp, undefined];
          tmp = "";
          continue;
        } else if (!inquote && char === ";") {
          state = STATE_KEY;
          if (charset) {
            if (tmp.length) {
              tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
            }
            charset = "";
          } else if (tmp.length) {
            tmp = decodeText(tmp, "binary", "utf8");
          }
          if (res[p] === undefined) {
            res[p] = tmp;
          } else {
            res[p][1] = tmp;
          }
          tmp = "";
          ++p;
          continue;
        } else if (!inquote && (char === " " || char === "\t")) {
          continue;
        }
      }
      tmp += char;
    }
    if (charset && tmp.length) {
      tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
    } else if (tmp) {
      tmp = decodeText(tmp, "binary", "utf8");
    }
    if (res[p] === undefined) {
      if (tmp) {
        res[p] = tmp;
      }
    } else {
      res[p][1] = tmp;
    }
    return res;
  }
  var decodeText = require_decodeText();
  var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
  var EncodedLookup = {
    "%00": "\0",
    "%01": "\x01",
    "%02": "\x02",
    "%03": "\x03",
    "%04": "\x04",
    "%05": "\x05",
    "%06": "\x06",
    "%07": "\x07",
    "%08": "\b",
    "%09": "\t",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": `\r`,
    "%0D": `\r`,
    "%0e": "\x0E",
    "%0E": "\x0E",
    "%0f": "\x0F",
    "%0F": "\x0F",
    "%10": "\x10",
    "%11": "\x11",
    "%12": "\x12",
    "%13": "\x13",
    "%14": "\x14",
    "%15": "\x15",
    "%16": "\x16",
    "%17": "\x17",
    "%18": "\x18",
    "%19": "\x19",
    "%1a": "\x1A",
    "%1A": "\x1A",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "\x1C",
    "%1C": "\x1C",
    "%1d": "\x1D",
    "%1D": "\x1D",
    "%1e": "\x1E",
    "%1E": "\x1E",
    "%1f": "\x1F",
    "%1F": "\x1F",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "\x7F",
    "%7F": "\x7F",
    "%80": "\x80",
    "%81": "\x81",
    "%82": "\x82",
    "%83": "\x83",
    "%84": "\x84",
    "%85": "\x85",
    "%86": "\x86",
    "%87": "\x87",
    "%88": "\x88",
    "%89": "\x89",
    "%8a": "\x8A",
    "%8A": "\x8A",
    "%8b": "\x8B",
    "%8B": "\x8B",
    "%8c": "\x8C",
    "%8C": "\x8C",
    "%8d": "\x8D",
    "%8D": "\x8D",
    "%8e": "\x8E",
    "%8E": "\x8E",
    "%8f": "\x8F",
    "%8F": "\x8F",
    "%90": "\x90",
    "%91": "\x91",
    "%92": "\x92",
    "%93": "\x93",
    "%94": "\x94",
    "%95": "\x95",
    "%96": "\x96",
    "%97": "\x97",
    "%98": "\x98",
    "%99": "\x99",
    "%9a": "\x9A",
    "%9A": "\x9A",
    "%9b": "\x9B",
    "%9B": "\x9B",
    "%9c": "\x9C",
    "%9C": "\x9C",
    "%9d": "\x9D",
    "%9D": "\x9D",
    "%9e": "\x9E",
    "%9E": "\x9E",
    "%9f": "\x9F",
    "%9F": "\x9F",
    "%a0": "\xA0",
    "%A0": "\xA0",
    "%a1": "\xA1",
    "%A1": "\xA1",
    "%a2": "\xA2",
    "%A2": "\xA2",
    "%a3": "\xA3",
    "%A3": "\xA3",
    "%a4": "\xA4",
    "%A4": "\xA4",
    "%a5": "\xA5",
    "%A5": "\xA5",
    "%a6": "\xA6",
    "%A6": "\xA6",
    "%a7": "\xA7",
    "%A7": "\xA7",
    "%a8": "\xA8",
    "%A8": "\xA8",
    "%a9": "\xA9",
    "%A9": "\xA9",
    "%aa": "\xAA",
    "%Aa": "\xAA",
    "%aA": "\xAA",
    "%AA": "\xAA",
    "%ab": "\xAB",
    "%Ab": "\xAB",
    "%aB": "\xAB",
    "%AB": "\xAB",
    "%ac": "\xAC",
    "%Ac": "\xAC",
    "%aC": "\xAC",
    "%AC": "\xAC",
    "%ad": "\xAD",
    "%Ad": "\xAD",
    "%aD": "\xAD",
    "%AD": "\xAD",
    "%ae": "\xAE",
    "%Ae": "\xAE",
    "%aE": "\xAE",
    "%AE": "\xAE",
    "%af": "\xAF",
    "%Af": "\xAF",
    "%aF": "\xAF",
    "%AF": "\xAF",
    "%b0": "\xB0",
    "%B0": "\xB0",
    "%b1": "\xB1",
    "%B1": "\xB1",
    "%b2": "\xB2",
    "%B2": "\xB2",
    "%b3": "\xB3",
    "%B3": "\xB3",
    "%b4": "\xB4",
    "%B4": "\xB4",
    "%b5": "\xB5",
    "%B5": "\xB5",
    "%b6": "\xB6",
    "%B6": "\xB6",
    "%b7": "\xB7",
    "%B7": "\xB7",
    "%b8": "\xB8",
    "%B8": "\xB8",
    "%b9": "\xB9",
    "%B9": "\xB9",
    "%ba": "\xBA",
    "%Ba": "\xBA",
    "%bA": "\xBA",
    "%BA": "\xBA",
    "%bb": "\xBB",
    "%Bb": "\xBB",
    "%bB": "\xBB",
    "%BB": "\xBB",
    "%bc": "\xBC",
    "%Bc": "\xBC",
    "%bC": "\xBC",
    "%BC": "\xBC",
    "%bd": "\xBD",
    "%Bd": "\xBD",
    "%bD": "\xBD",
    "%BD": "\xBD",
    "%be": "\xBE",
    "%Be": "\xBE",
    "%bE": "\xBE",
    "%BE": "\xBE",
    "%bf": "\xBF",
    "%Bf": "\xBF",
    "%bF": "\xBF",
    "%BF": "\xBF",
    "%c0": "\xC0",
    "%C0": "\xC0",
    "%c1": "\xC1",
    "%C1": "\xC1",
    "%c2": "\xC2",
    "%C2": "\xC2",
    "%c3": "\xC3",
    "%C3": "\xC3",
    "%c4": "\xC4",
    "%C4": "\xC4",
    "%c5": "\xC5",
    "%C5": "\xC5",
    "%c6": "\xC6",
    "%C6": "\xC6",
    "%c7": "\xC7",
    "%C7": "\xC7",
    "%c8": "\xC8",
    "%C8": "\xC8",
    "%c9": "\xC9",
    "%C9": "\xC9",
    "%ca": "\xCA",
    "%Ca": "\xCA",
    "%cA": "\xCA",
    "%CA": "\xCA",
    "%cb": "\xCB",
    "%Cb": "\xCB",
    "%cB": "\xCB",
    "%CB": "\xCB",
    "%cc": "\xCC",
    "%Cc": "\xCC",
    "%cC": "\xCC",
    "%CC": "\xCC",
    "%cd": "\xCD",
    "%Cd": "\xCD",
    "%cD": "\xCD",
    "%CD": "\xCD",
    "%ce": "\xCE",
    "%Ce": "\xCE",
    "%cE": "\xCE",
    "%CE": "\xCE",
    "%cf": "\xCF",
    "%Cf": "\xCF",
    "%cF": "\xCF",
    "%CF": "\xCF",
    "%d0": "\xD0",
    "%D0": "\xD0",
    "%d1": "\xD1",
    "%D1": "\xD1",
    "%d2": "\xD2",
    "%D2": "\xD2",
    "%d3": "\xD3",
    "%D3": "\xD3",
    "%d4": "\xD4",
    "%D4": "\xD4",
    "%d5": "\xD5",
    "%D5": "\xD5",
    "%d6": "\xD6",
    "%D6": "\xD6",
    "%d7": "\xD7",
    "%D7": "\xD7",
    "%d8": "\xD8",
    "%D8": "\xD8",
    "%d9": "\xD9",
    "%D9": "\xD9",
    "%da": "\xDA",
    "%Da": "\xDA",
    "%dA": "\xDA",
    "%DA": "\xDA",
    "%db": "\xDB",
    "%Db": "\xDB",
    "%dB": "\xDB",
    "%DB": "\xDB",
    "%dc": "\xDC",
    "%Dc": "\xDC",
    "%dC": "\xDC",
    "%DC": "\xDC",
    "%dd": "\xDD",
    "%Dd": "\xDD",
    "%dD": "\xDD",
    "%DD": "\xDD",
    "%de": "\xDE",
    "%De": "\xDE",
    "%dE": "\xDE",
    "%DE": "\xDE",
    "%df": "\xDF",
    "%Df": "\xDF",
    "%dF": "\xDF",
    "%DF": "\xDF",
    "%e0": "\xE0",
    "%E0": "\xE0",
    "%e1": "\xE1",
    "%E1": "\xE1",
    "%e2": "\xE2",
    "%E2": "\xE2",
    "%e3": "\xE3",
    "%E3": "\xE3",
    "%e4": "\xE4",
    "%E4": "\xE4",
    "%e5": "\xE5",
    "%E5": "\xE5",
    "%e6": "\xE6",
    "%E6": "\xE6",
    "%e7": "\xE7",
    "%E7": "\xE7",
    "%e8": "\xE8",
    "%E8": "\xE8",
    "%e9": "\xE9",
    "%E9": "\xE9",
    "%ea": "\xEA",
    "%Ea": "\xEA",
    "%eA": "\xEA",
    "%EA": "\xEA",
    "%eb": "\xEB",
    "%Eb": "\xEB",
    "%eB": "\xEB",
    "%EB": "\xEB",
    "%ec": "\xEC",
    "%Ec": "\xEC",
    "%eC": "\xEC",
    "%EC": "\xEC",
    "%ed": "\xED",
    "%Ed": "\xED",
    "%eD": "\xED",
    "%ED": "\xED",
    "%ee": "\xEE",
    "%Ee": "\xEE",
    "%eE": "\xEE",
    "%EE": "\xEE",
    "%ef": "\xEF",
    "%Ef": "\xEF",
    "%eF": "\xEF",
    "%EF": "\xEF",
    "%f0": "\xF0",
    "%F0": "\xF0",
    "%f1": "\xF1",
    "%F1": "\xF1",
    "%f2": "\xF2",
    "%F2": "\xF2",
    "%f3": "\xF3",
    "%F3": "\xF3",
    "%f4": "\xF4",
    "%F4": "\xF4",
    "%f5": "\xF5",
    "%F5": "\xF5",
    "%f6": "\xF6",
    "%F6": "\xF6",
    "%f7": "\xF7",
    "%F7": "\xF7",
    "%f8": "\xF8",
    "%F8": "\xF8",
    "%f9": "\xF9",
    "%F9": "\xF9",
    "%fa": "\xFA",
    "%Fa": "\xFA",
    "%fA": "\xFA",
    "%FA": "\xFA",
    "%fb": "\xFB",
    "%Fb": "\xFB",
    "%fB": "\xFB",
    "%FB": "\xFB",
    "%fc": "\xFC",
    "%Fc": "\xFC",
    "%fC": "\xFC",
    "%FC": "\xFC",
    "%fd": "\xFD",
    "%Fd": "\xFD",
    "%fD": "\xFD",
    "%FD": "\xFD",
    "%fe": "\xFE",
    "%Fe": "\xFE",
    "%fE": "\xFE",
    "%FE": "\xFE",
    "%ff": "\xFF",
    "%Ff": "\xFF",
    "%fF": "\xFF",
    "%FF": "\xFF"
  };
  var STATE_KEY = 0;
  var STATE_VALUE = 1;
  var STATE_CHARSET = 2;
  var STATE_LANG = 3;
  module.exports = parseParams;
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS((exports, module) => {
  module.exports = function basename(path5) {
    if (typeof path5 !== "string") {
      return "";
    }
    for (var i2 = path5.length - 1;i2 >= 0; --i2) {
      switch (path5.charCodeAt(i2)) {
        case 47:
        case 92:
          path5 = path5.slice(i2 + 1);
          return path5 === ".." || path5 === "." ? "" : path5;
      }
    }
    return path5 === ".." || path5 === "." ? "" : path5;
  };
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  function Multipart(boy, cfg) {
    let i2;
    let len;
    const self2 = this;
    let boundary;
    const limits = cfg.limits;
    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== undefined);
    const parsedConType = cfg.parsedConType || [];
    const defCharset = cfg.defCharset || "utf8";
    const preservePath = cfg.preservePath;
    const fileOpts = { highWaterMark: cfg.fileHwm };
    for (i2 = 0, len = parsedConType.length;i2 < len; ++i2) {
      if (Array.isArray(parsedConType[i2]) && RE_BOUNDARY.test(parsedConType[i2][0])) {
        boundary = parsedConType[i2][1];
        break;
      }
    }
    function checkFinished() {
      if (nends === 0 && finished7 && !boy._done) {
        finished7 = false;
        self2.end();
      }
    }
    if (typeof boundary !== "string") {
      throw new Error("Multipart: Boundary not found");
    }
    const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
    const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
    const filesLimit = getLimit(limits, "files", Infinity);
    const fieldsLimit = getLimit(limits, "fields", Infinity);
    const partsLimit = getLimit(limits, "parts", Infinity);
    const headerPairsLimit = getLimit(limits, "headerPairs", 2000);
    const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
    let nfiles = 0;
    let nfields = 0;
    let nends = 0;
    let curFile;
    let curField;
    let finished7 = false;
    this._needDrain = false;
    this._pause = false;
    this._cb = undefined;
    this._nparts = 0;
    this._boy = boy;
    const parserCfg = {
      boundary,
      maxHeaderPairs: headerPairsLimit,
      maxHeaderSize: headerSizeLimit,
      partHwm: fileOpts.highWaterMark,
      highWaterMark: cfg.highWaterMark
    };
    this.parser = new Dicer(parserCfg);
    this.parser.on("drain", function() {
      self2._needDrain = false;
      if (self2._cb && !self2._pause) {
        const cb = self2._cb;
        self2._cb = undefined;
        cb();
      }
    }).on("part", function onPart(part) {
      if (++self2._nparts > partsLimit) {
        self2.parser.removeListener("part", onPart);
        self2.parser.on("part", skipPart);
        boy.hitPartsLimit = true;
        boy.emit("partsLimit");
        return skipPart(part);
      }
      if (curField) {
        const field = curField;
        field.emit("end");
        field.removeAllListeners("end");
      }
      part.on("header", function(header) {
        let contype;
        let fieldname;
        let parsed;
        let charset;
        let encoding;
        let filename;
        let nsize = 0;
        if (header["content-type"]) {
          parsed = parseParams(header["content-type"][0]);
          if (parsed[0]) {
            contype = parsed[0].toLowerCase();
            for (i2 = 0, len = parsed.length;i2 < len; ++i2) {
              if (RE_CHARSET.test(parsed[i2][0])) {
                charset = parsed[i2][1].toLowerCase();
                break;
              }
            }
          }
        }
        if (contype === undefined) {
          contype = "text/plain";
        }
        if (charset === undefined) {
          charset = defCharset;
        }
        if (header["content-disposition"]) {
          parsed = parseParams(header["content-disposition"][0]);
          if (!RE_FIELD.test(parsed[0])) {
            return skipPart(part);
          }
          for (i2 = 0, len = parsed.length;i2 < len; ++i2) {
            if (RE_NAME.test(parsed[i2][0])) {
              fieldname = parsed[i2][1];
            } else if (RE_FILENAME.test(parsed[i2][0])) {
              filename = parsed[i2][1];
              if (!preservePath) {
                filename = basename(filename);
              }
            }
          }
        } else {
          return skipPart(part);
        }
        if (header["content-transfer-encoding"]) {
          encoding = header["content-transfer-encoding"][0].toLowerCase();
        } else {
          encoding = "7bit";
        }
        let onData, onEnd;
        if (isPartAFile(fieldname, contype, filename)) {
          if (nfiles === filesLimit) {
            if (!boy.hitFilesLimit) {
              boy.hitFilesLimit = true;
              boy.emit("filesLimit");
            }
            return skipPart(part);
          }
          ++nfiles;
          if (boy.listenerCount("file") === 0) {
            self2.parser._ignore();
            return;
          }
          ++nends;
          const file = new FileStream(fileOpts);
          curFile = file;
          file.on("end", function() {
            --nends;
            self2._pause = false;
            checkFinished();
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = undefined;
              cb();
            }
          });
          file._read = function(n2) {
            if (!self2._pause) {
              return;
            }
            self2._pause = false;
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = undefined;
              cb();
            }
          };
          boy.emit("file", fieldname, file, filename, encoding, contype);
          onData = function(data) {
            if ((nsize += data.length) > fileSizeLimit) {
              const extralen = fileSizeLimit - nsize + data.length;
              if (extralen > 0) {
                file.push(data.slice(0, extralen));
              }
              file.truncated = true;
              file.bytesRead = fileSizeLimit;
              part.removeAllListeners("data");
              file.emit("limit");
              return;
            } else if (!file.push(data)) {
              self2._pause = true;
            }
            file.bytesRead = nsize;
          };
          onEnd = function() {
            curFile = undefined;
            file.push(null);
          };
        } else {
          if (nfields === fieldsLimit) {
            if (!boy.hitFieldsLimit) {
              boy.hitFieldsLimit = true;
              boy.emit("fieldsLimit");
            }
            return skipPart(part);
          }
          ++nfields;
          ++nends;
          let buffer = "";
          let truncated = false;
          curField = part;
          onData = function(data) {
            if ((nsize += data.length) > fieldSizeLimit) {
              const extralen = fieldSizeLimit - (nsize - data.length);
              buffer += data.toString("binary", 0, extralen);
              truncated = true;
              part.removeAllListeners("data");
            } else {
              buffer += data.toString("binary");
            }
          };
          onEnd = function() {
            curField = undefined;
            if (buffer.length) {
              buffer = decodeText(buffer, "binary", charset);
            }
            boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
            --nends;
            checkFinished();
          };
        }
        part._readableState.sync = false;
        part.on("data", onData);
        part.on("end", onEnd);
      }).on("error", function(err) {
        if (curFile) {
          curFile.emit("error", err);
        }
      });
    }).on("error", function(err) {
      boy.emit("error", err);
    }).on("finish", function() {
      finished7 = true;
      checkFinished();
    });
  }
  function skipPart(part) {
    part.resume();
  }
  function FileStream(opts) {
    Readable4.call(this, opts);
    this.bytesRead = 0;
    this.truncated = false;
  }
  var { Readable: Readable4 } = __require("node:stream");
  var { inherits } = __require("node:util");
  var Dicer = require_Dicer();
  var parseParams = require_parseParams();
  var decodeText = require_decodeText();
  var basename = require_basename();
  var getLimit = require_getLimit();
  var RE_BOUNDARY = /^boundary$/i;
  var RE_FIELD = /^form-data$/i;
  var RE_CHARSET = /^charset$/i;
  var RE_FILENAME = /^filename$/i;
  var RE_NAME = /^name$/i;
  Multipart.detect = /^multipart\/form-data/i;
  Multipart.prototype.write = function(chunk, cb) {
    const r = this.parser.write(chunk);
    if (r && !this._pause) {
      cb();
    } else {
      this._needDrain = !r;
      this._cb = cb;
    }
  };
  Multipart.prototype.end = function() {
    const self2 = this;
    if (self2.parser.writable) {
      self2.parser.end();
    } else if (!self2._boy._done) {
      process.nextTick(function() {
        self2._boy._done = true;
        self2._boy.emit("finish");
      });
    }
  };
  inherits(FileStream, Readable4);
  FileStream.prototype._read = function(n2) {
  };
  module.exports = Multipart;
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS((exports, module) => {
  function Decoder() {
    this.buffer = undefined;
  }
  var RE_PLUS = /\+/g;
  var HEX = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  Decoder.prototype.write = function(str) {
    str = str.replace(RE_PLUS, " ");
    let res = "";
    let i2 = 0;
    let p = 0;
    const len = str.length;
    for (;i2 < len; ++i2) {
      if (this.buffer !== undefined) {
        if (!HEX[str.charCodeAt(i2)]) {
          res += "%" + this.buffer;
          this.buffer = undefined;
          --i2;
        } else {
          this.buffer += str[i2];
          ++p;
          if (this.buffer.length === 2) {
            res += String.fromCharCode(parseInt(this.buffer, 16));
            this.buffer = undefined;
          }
        }
      } else if (str[i2] === "%") {
        if (i2 > p) {
          res += str.substring(p, i2);
          p = i2;
        }
        this.buffer = "";
        ++p;
      }
    }
    if (p < len && this.buffer === undefined) {
      res += str.substring(p);
    }
    return res;
  };
  Decoder.prototype.reset = function() {
    this.buffer = undefined;
  };
  module.exports = Decoder;
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  function UrlEncoded(boy, cfg) {
    const limits = cfg.limits;
    const parsedConType = cfg.parsedConType;
    this.boy = boy;
    this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
    this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
    this.fieldsLimit = getLimit(limits, "fields", Infinity);
    let charset;
    for (var i2 = 0, len = parsedConType.length;i2 < len; ++i2) {
      if (Array.isArray(parsedConType[i2]) && RE_CHARSET.test(parsedConType[i2][0])) {
        charset = parsedConType[i2][1].toLowerCase();
        break;
      }
    }
    if (charset === undefined) {
      charset = cfg.defCharset || "utf8";
    }
    this.decoder = new Decoder;
    this.charset = charset;
    this._fields = 0;
    this._state = "key";
    this._checkingBytes = true;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._key = "";
    this._val = "";
    this._keyTrunc = false;
    this._valTrunc = false;
    this._hitLimit = false;
  }
  var Decoder = require_Decoder();
  var decodeText = require_decodeText();
  var getLimit = require_getLimit();
  var RE_CHARSET = /^charset$/i;
  UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
  UrlEncoded.prototype.write = function(data, cb) {
    if (this._fields === this.fieldsLimit) {
      if (!this.boy.hitFieldsLimit) {
        this.boy.hitFieldsLimit = true;
        this.boy.emit("fieldsLimit");
      }
      return cb();
    }
    let idxeq;
    let idxamp;
    let i2;
    let p = 0;
    const len = data.length;
    while (p < len) {
      if (this._state === "key") {
        idxeq = idxamp = undefined;
        for (i2 = p;i2 < len; ++i2) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i2] === 61) {
            idxeq = i2;
            break;
          } else if (data[i2] === 38) {
            idxamp = i2;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesKey;
          }
        }
        if (idxeq !== undefined) {
          if (idxeq > p) {
            this._key += this.decoder.write(data.toString("binary", p, idxeq));
          }
          this._state = "val";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._val = "";
          this._bytesVal = 0;
          this._valTrunc = false;
          this.decoder.reset();
          p = idxeq + 1;
        } else if (idxamp !== undefined) {
          ++this._fields;
          let key;
          const keyTrunc = this._keyTrunc;
          if (idxamp > p) {
            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
          } else {
            key = this._key;
          }
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          if (key.length) {
            this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
          }
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i2 > p) {
            this._key += this.decoder.write(data.toString("binary", p, i2));
          }
          p = i2;
          if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
            this._checkingBytes = false;
            this._keyTrunc = true;
          }
        } else {
          if (p < len) {
            this._key += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      } else {
        idxamp = undefined;
        for (i2 = p;i2 < len; ++i2) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i2] === 38) {
            idxamp = i2;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesVal;
          }
        }
        if (idxamp !== undefined) {
          ++this._fields;
          if (idxamp > p) {
            this._val += this.decoder.write(data.toString("binary", p, idxamp));
          }
          this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
          this._state = "key";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i2 > p) {
            this._val += this.decoder.write(data.toString("binary", p, i2));
          }
          p = i2;
          if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
            this._checkingBytes = false;
            this._valTrunc = true;
          }
        } else {
          if (p < len) {
            this._val += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      }
    }
    cb();
  };
  UrlEncoded.prototype.end = function() {
    if (this.boy._done) {
      return;
    }
    if (this._state === "key" && this._key.length > 0) {
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
    } else if (this._state === "val") {
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
    }
    this.boy._done = true;
    this.boy.emit("finish");
  };
  module.exports = UrlEncoded;
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS((exports, module) => {
  function Busboy(opts) {
    if (!(this instanceof Busboy)) {
      return new Busboy(opts);
    }
    if (typeof opts !== "object") {
      throw new TypeError("Busboy expected an options-Object.");
    }
    if (typeof opts.headers !== "object") {
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    }
    if (typeof opts.headers["content-type"] !== "string") {
      throw new TypeError("Missing Content-Type-header.");
    }
    const {
      headers,
      ...streamOptions
    } = opts;
    this.opts = {
      autoDestroy: false,
      ...streamOptions
    };
    WritableStream.call(this, this.opts);
    this._done = false;
    this._parser = this.getParserByHeaders(headers);
    this._finished = false;
  }
  var WritableStream = __require("node:stream").Writable;
  var { inherits } = __require("node:util");
  var Dicer = require_Dicer();
  var MultipartParser = require_multipart();
  var UrlencodedParser = require_urlencoded();
  var parseParams = require_parseParams();
  inherits(Busboy, WritableStream);
  Busboy.prototype.emit = function(ev) {
    if (ev === "finish") {
      if (!this._done) {
        this._parser?.end();
        return;
      } else if (this._finished) {
        return;
      }
      this._finished = true;
    }
    WritableStream.prototype.emit.apply(this, arguments);
  };
  Busboy.prototype.getParserByHeaders = function(headers) {
    const parsed = parseParams(headers["content-type"]);
    const cfg = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: parsed,
      preservePath: this.opts.preservePath
    };
    if (MultipartParser.detect.test(parsed[0])) {
      return new MultipartParser(this, cfg);
    }
    if (UrlencodedParser.detect.test(parsed[0])) {
      return new UrlencodedParser(this, cfg);
    }
    throw new Error("Unsupported Content-Type.");
  };
  Busboy.prototype._write = function(chunk, encoding, cb) {
    this._parser.write(chunk, cb);
  };
  module.exports = Busboy;
  module.exports.default = Busboy;
  module.exports.Busboy = Busboy;
  module.exports.Dicer = Dicer;
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var redirectStatusSet = new Set(redirectStatus);
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ];
  var badPortsSet = new Set(badPorts);
  var referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var referrerPolicySet = new Set(referrerPolicy);
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var safeMethodsSet = new Set(safeMethods);
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var forbiddenMethodsSet = new Set(forbiddenMethods);
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var subresourceSet = new Set(subresource);
  var DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })();
  var channel;
  var structuredClone = globalThis.structuredClone ?? function structuredClone(value, options3 = undefined) {
    if (arguments.length === 0) {
      throw new TypeError("missing argument");
    }
    if (!channel) {
      channel = new MessageChannel;
    }
    channel.port1.unref();
    channel.port2.unref();
    channel.port1.postMessage(value, options3?.transfer);
    return receiveMessageOnPort(channel.port2).message;
  };
  module.exports = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS((exports, module) => {
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  function responseURL(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) {
      return null;
    }
    let location = response.headersList.get("location");
    if (location !== null && isValidHeaderValue(location)) {
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i2 = 0;i2 < statusText.length; ++i2) {
      const c3 = statusText.charCodeAt(i2);
      if (!(c3 === 9 || c3 >= 32 && c3 <= 126 || c3 >= 128 && c3 <= 255)) {
        return false;
      }
    }
    return true;
  }
  function isTokenCharCode(c3) {
    switch (c3) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return c3 >= 33 && c3 <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0) {
      return false;
    }
    for (let i2 = 0;i2 < characters.length; ++i2) {
      if (!isTokenCharCode(characters.charCodeAt(i2))) {
        return false;
      }
    }
    return true;
  }
  function isValidHeaderName(potentialValue) {
    return isValidHTTPToken(potentialValue);
  }
  function isValidHeaderValue(potentialValue) {
    if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" ")) {
      return false;
    }
    if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
      return false;
    }
    return true;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i2 = policyHeader.length;i2 !== 0; i2--) {
        const token = policyHeader[i2 - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    }
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return performance2.now();
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert(url instanceof URL);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "file:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto === undefined) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  function parseMetadata(metadata) {
    const result5 = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result5.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result5;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i2 = 1;i2 < metadataList.length; ++i2) {
      const metadata = metadataList[i2];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i2 = 0;i2 < metadataList.length; ++i2) {
      if (metadataList[i2].algo === algorithm) {
        metadataList[pos++] = metadataList[i2];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i2 = 0;i2 < actualValue.length; ++i2) {
      if (actualValue[i2] !== expectedValue[i2]) {
        if (actualValue[i2] === "+" && expectedValue[i2] === "-" || actualValue[i2] === "/" && expectedValue[i2] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
  }
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise2 = new Promise((resolve, reject4) => {
      res = resolve;
      rej = reject4;
    });
    return { promise: promise2, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizeMethodRecord[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result5 = JSON.stringify(value);
    if (result5 === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result5 === "string");
    return result5;
  }
  function makeIterator(iterator, name, kind) {
    const object = {
      index: 0,
      kind,
      target: iterator
    };
    const i2 = {
      next() {
        if (Object.getPrototypeOf(this) !== i2) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const { index, kind: kind2, target } = object;
        const values8 = target();
        const len = values8.length;
        if (index >= len) {
          return { value: undefined, done: true };
        }
        const pair = values8[index];
        object.index = index + 1;
        return iteratorResult(pair, kind2);
      },
      [Symbol.toStringTag]: `${name} Iterator`
    };
    Object.setPrototypeOf(i2, esIteratorPrototype);
    return Object.setPrototypeOf({}, i2);
  }
  function iteratorResult(pair, kind) {
    let result5;
    switch (kind) {
      case "key": {
        result5 = pair[0];
        break;
      }
      case "value": {
        result5 = pair[1];
        break;
      }
      case "key+value": {
        result5 = pair;
        break;
      }
    }
    return { value: result5, done: false };
  }
  async function fullyReadBody(body, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      const result5 = await readAllBytes(reader);
      successSteps(result5);
    } catch (e) {
      errorSteps(e);
    }
  }
  function isReadableStreamLike(stream3) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    return stream3 instanceof ReadableStream2 || stream3[Symbol.toStringTag] === "ReadableStream" && typeof stream3.tee === "function";
  }
  function isomorphicDecode(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
      return String.fromCharCode(...input);
    }
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed")) {
        throw err;
      }
    }
  }
  function isomorphicEncode(input) {
    for (let i2 = 0;i2 < input.length; i2++) {
      assert(input.charCodeAt(i2) <= 255);
    }
    return input;
  }
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array2(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    if (typeof url === "string") {
      return url.startsWith("https:");
    }
    return url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
  var { getGlobalOrigin } = require_global();
  var { performance: performance2 } = __require("perf_hooks");
  var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
  var assert = __require("assert");
  var { isUint8Array: isUint8Array2 } = __require("util/types");
  var supportedHashes = [];
  var crypto;
  try {
    crypto = __require("crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {
  }
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  var normalizeMethodRecord = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(normalizeMethodRecord, null);
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  var ReadableStream2 = globalThis.ReadableStream;
  var MAXIMUM_ARGUMENT_LENGTH = 65535;
  var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  module.exports = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    normalizeMethodRecord,
    parseMetadata
  };
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types } = __require("util");
  var { hasOwn, toUSVString } = require_util2();
  var webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message2) {
    return new TypeError(`${message2.header}: ${message2.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message2 = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message: message2
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = undefined) {
    if (opts?.strict !== false && !(V instanceof I)) {
      throw new TypeError("Illegal invocation");
    } else {
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n2) {
    const r = Math.floor(Math.abs(n2));
    if (n2 < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      }
      const method = V?.[Symbol.iterator]?.();
      const seq = [];
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      }
      const result5 = {};
      if (!types.isProxy(O)) {
        const keys2 = Object.keys(O);
        for (const key of keys2) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result5[typedKey] = typedValue;
        }
        return result5;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result5[typedKey] = typedValue;
        }
      }
      return result5;
    };
  };
  webidl.interfaceConverter = function(i2) {
    return (V, opts = {}) => {
      if (opts.strict !== false && !(V instanceof i2)) {
        throw webidl.errors.exception({
          header: i2.name,
          message: `Expected ${V} to be an instance of ${i2.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      const type15 = webidl.util.Type(dictionary);
      const dict = {};
      if (type15 === "Null" || type15 === "Undefined") {
        return dict;
      } else if (type15 !== "Object") {
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options3 of converters) {
        const { key, defaultValue, required, converter } = options3;
        if (required === true) {
          if (!hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = hasOwn(options3, "defaultValue");
        if (hasDefault && value !== null) {
          value = value ?? defaultValue;
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value);
          if (options3.allowedValues && !options3.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options3.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null) {
        return V;
      }
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw new TypeError("Could not convert argument of type symbol to string.");
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    const x = webidl.converters.DOMString(V);
    for (let index = 0;index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "signed");
    return x;
  };
  webidl.converters["unsigned long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned");
    return x;
  };
  webidl.converters["unsigned long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned");
    return x;
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, opts);
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor);
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, opts);
    }
    throw new TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS((exports, module) => {
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result5 = "";
    while (position.position < input.length && condition(input[position.position])) {
      result5 += input[position.position];
      position.position++;
    }
    return result5;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start2 = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start2);
    }
    position.position = idx;
    return input.slice(start2, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function percentDecode(input) {
    const output3 = [];
    for (let i2 = 0;i2 < input.length; i2++) {
      const byte = input[i2];
      if (byte !== 37) {
        output3.push(byte);
      } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i2 + 1], input[i2 + 2]))) {
        output3.push(37);
      } else {
        const nextTwoBytes = String.fromCharCode(input[i2 + 1], input[i2 + 2]);
        const bytePoint = Number.parseInt(nextTwoBytes, 16);
        output3.push(bytePoint);
        i2 += 2;
      }
    }
    return Uint8Array.from(output3);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type15 = collectASequenceOfCodePointsFast("/", input, position);
    if (type15.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type15)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type15.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
    if (data.length % 4 === 0) {
      data = data.replace(/=?=$/, "");
    }
    if (data.length % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data)) {
      return "failure";
    }
    const binary = atob2(data);
    const bytes = new Uint8Array(binary.length);
    for (let byte = 0;byte < binary.length; byte++) {
      bytes[byte] = binary.charCodeAt(byte);
    }
    return bytes;
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters: parameters3, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters3.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === "\r" || char === "\n" || char === "\t" || char === " ";
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  }
  function isASCIIWhitespace(char) {
    return char === "\r" || char === "\n" || char === "\t" || char === "\f" || char === " ";
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isASCIIWhitespace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isASCIIWhitespace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  }
  var assert = __require("assert");
  var { atob: atob2 } = __require("buffer");
  var { isomorphicDecode } = require_util2();
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
  var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
  var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS((exports, module) => {
  function processBlobParts(parts, options3) {
    const bytes = [];
    for (const element of parts) {
      if (typeof element === "string") {
        let s = element;
        if (options3.endings === "native") {
          s = convertLineEndingsNative(s);
        }
        bytes.push(encoder.encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
        if (!element.buffer) {
          bytes.push(new Uint8Array(element));
        } else {
          bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
        }
      } else if (isBlobLike(element)) {
        bytes.push(element);
      }
    }
    return bytes;
  }
  function convertLineEndingsNative(s) {
    let nativeLineEnding = "\n";
    if (process.platform === "win32") {
      nativeLineEnding = "\r\n";
    }
    return s.replace(/\r?\n/g, nativeLineEnding);
  }
  function isFileLike(object) {
    return NativeFile && object instanceof NativeFile || object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { types } = __require("util");
  var { kState } = require_symbols2();
  var { isBlobLike } = require_util2();
  var { webidl } = require_webidl();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var { kEnumerableProperty } = require_util();
  var encoder = new TextEncoder;

  class File2 extends Blob2 {
    constructor(fileBits, fileName, options3 = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
      fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
      fileName = webidl.converters.USVString(fileName);
      options3 = webidl.converters.FilePropertyBag(options3);
      const n2 = fileName;
      let t = options3.type;
      let d;
      substep: {
        if (t) {
          t = parseMIMEType(t);
          if (t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options3.lastModified;
      }
      super(processBlobParts(fileBits, options3), { type: t });
      this[kState] = {
        name: n2,
        lastModified: d,
        type: t
      };
    }
    get name() {
      webidl.brandCheck(this, File2);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, File2);
      return this[kState].lastModified;
    }
    get type() {
      webidl.brandCheck(this, File2);
      return this[kState].type;
    }
  }

  class FileLike {
    constructor(blobLike, fileName, options3 = {}) {
      const n2 = fileName;
      const t = options3.type;
      const d = options3.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n2,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File2.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: true
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V, opts);
      }
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        value = webidl.converters.DOMString(value);
        value = value.toLowerCase();
        if (value !== "native") {
          value = "transparent";
        }
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  module.exports = { File: File2, FileLike, isFileLike };
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  function makeEntry(name, value, filename) {
    name = Buffer.from(name).toString("utf8");
    if (typeof value === "string") {
      value = Buffer.from(value).toString("utf8");
    } else {
      if (!isFileLike(value)) {
        value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options3 = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options3) : new FileLike(value, filename, options3);
      }
    }
    return { name, value };
  }
  var { isBlobLike, toUSVString, makeIterator } = require_util2();
  var { kState } = require_symbols2();
  var { File: UndiciFile, FileLike, isFileLike } = require_file();
  var { webidl } = require_webidl();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var File2 = NativeFile ?? UndiciFile;

  class FormData2 {
    constructor(form) {
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
      name = webidl.converters.USVString(name);
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
      name = webidl.converters.USVString(name);
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
      name = webidl.converters.USVString(name);
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
      name = webidl.converters.USVString(name);
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? toUSVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    entries() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
    }
    keys() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
    }
    values() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  module.exports = { FormData: FormData2 };
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS((exports, module) => {
  function extractBody(object, keepalive = false) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    let stream3 = null;
    if (object instanceof ReadableStream2) {
      stream3 = object;
    } else if (isBlobLike(object)) {
      stream3 = object.stream();
    } else {
      stream3 = new ReadableStream2({
        async pull(controller) {
          controller.enqueue(typeof source === "string" ? textEncoder3.encode(source) : source);
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: undefined
      });
    }
    assert(isReadableStreamLike(stream3));
    let action = null;
    let source = null;
    let length = null;
    let type15 = null;
    if (typeof object === "string") {
      source = object;
      type15 = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type15 = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer2(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 100000000000)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
      const escape4 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder3.encode(prefix + `; name="${escape4(normalizeLinefeeds(name))}"` + `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder3.encode(`${prefix}; name="${escape4(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape4(value.name)}"` : "") + "\r\n" + `Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder3.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type15 = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type15 = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream3 = object instanceof ReadableStream2 ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream3 = new ReadableStream2({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            if (!isErrored(stream3)) {
              controller.enqueue(new Uint8Array(value));
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: undefined
      });
    }
    const body = { stream: stream3, source, length };
    return [body, type15];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    if (object instanceof ReadableStream2) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(body) {
    const [out1, out2] = body.stream.tee();
    const out2Clone = structuredClone(out2, { transfer: [out2] });
    const [, finalClone] = out2Clone.tee();
    body.stream = out1;
    return {
      stream: finalClone,
      length: body.length,
      source: body.source
    };
  }
  async function* consumeBody(body) {
    if (body) {
      if (isUint8Array2(body)) {
        yield body;
      } else {
        const stream3 = body.stream;
        if (util.isDisturbed(stream3)) {
          throw new TypeError("The body has already been consumed.");
        }
        if (stream3.locked) {
          throw new TypeError("The stream is locked.");
        }
        stream3[kBodyUsed] = true;
        yield* stream3;
      }
    }
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException2("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods3 = {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure") {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance);
        throwIfAborted(this[kState]);
        const contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          const headers = {};
          for (const [key, value] of this.headers)
            headers[key.toLowerCase()] = value;
          const responseFormData = new FormData2;
          let busboy;
          try {
            busboy = new Busboy({
              headers,
              preservePath: true
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          });
          busboy.on("file", (name, value, filename, encoding, mimeType) => {
            const chunks = [];
            if (encoding === "base64" || encoding.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                const end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                base64chunk = base64chunk.slice(end);
              });
              value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64"));
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            } else {
              value.on("data", (chunk) => {
                chunks.push(chunk);
              });
              value.on("end", () => {
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            }
          });
          const busboyResolve = new Promise((resolve, reject4) => {
            busboy.on("finish", resolve);
            busboy.on("error", (err) => reject4(new TypeError(err)));
          });
          if (this.body !== null)
            for await (const chunk of consumeBody(this[kState].body))
              busboy.write(chunk);
          busboy.end();
          await busboyResolve;
          return responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "";
            const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
            for await (const chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array2(chunk)) {
                throw new TypeError("Expected Uint8Array chunk");
              }
              text += streamingDecoder.decode(chunk, { stream: true });
            }
            text += streamingDecoder.decode();
            entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(new TypeError, { cause: err });
          }
          const formData = new FormData2;
          for (const [name, value] of entries) {
            formData.append(name, value);
          }
          return formData;
        } else {
          await Promise.resolve();
          throwIfAborted(this[kState]);
          throw webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
        }
      }
    };
    return methods3;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function specConsumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    throwIfAborted(object[kState]);
    if (bodyUnusable(object[kState].body)) {
      throw new TypeError("Body is unusable");
    }
    const promise2 = createDeferredPromise();
    const errorSteps = (error2) => promise2.reject(error2);
    const successSteps = (data) => {
      try {
        promise2.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(new Uint8Array);
      return promise2.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise2.promise;
  }
  function bodyUnusable(body) {
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output3 = textDecoder2.decode(buffer);
    return output3;
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(object) {
    const { headersList } = object[kState];
    const contentType = headersList.get("content-type");
    if (contentType === null) {
      return "failure";
    }
    return parseMIMEType(contentType);
  }
  var Busboy = require_main();
  var util = require_util();
  var {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = require_util2();
  var { FormData: FormData2 } = require_formdata();
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();
  var { DOMException: DOMException2, structuredClone } = require_constants2();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { isErrored } = require_util();
  var { isUint8Array: isUint8Array2, isArrayBuffer: isArrayBuffer2 } = __require("util/types");
  var { File: UndiciFile } = require_file();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var ReadableStream2 = globalThis.ReadableStream;
  var File2 = NativeFile ?? UndiciFile;
  var textEncoder3 = new TextEncoder;
  var textDecoder2 = new TextDecoder;
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  function processHeaderValue(key, val2, skipAppend) {
    if (val2 && typeof val2 === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    val2 = val2 != null ? `${val2}` : "";
    if (headerCharRegex.exec(val2) !== null) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    return skipAppend ? val2 : `${key}: ${val2}\r\n`;
  }
  function processHeader(request, key, val2, skipAppend = false) {
    if (val2 && (typeof val2 === "object" && !Array.isArray(val2))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val2 === undefined) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val2) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      request.host = val2;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val2, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
      request.contentType = val2;
      if (skipAppend)
        request.headers[key] = processHeaderValue(key, val2, skipAppend);
      else
        request.headers += processHeaderValue(key, val2);
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      const value = typeof val2 === "string" ? val2.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (value === "close") {
        request.reset = true;
      }
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else if (tokenRegExp.exec(key) === null) {
      throw new InvalidArgumentError("invalid header key");
    } else {
      if (Array.isArray(val2)) {
        for (let i2 = 0;i2 < val2.length; i2++) {
          if (skipAppend) {
            if (request.headers[key])
              request.headers[key] += `,${processHeaderValue(key, val2[i2], skipAppend)}`;
            else
              request.headers[key] = processHeaderValue(key, val2[i2], skipAppend);
          } else {
            request.headers += processHeaderValue(key, val2[i2]);
          }
        }
      } else {
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val2, skipAppend);
        else
          request.headers += processHeaderValue(key, val2);
      }
    }
  }
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("assert");
  var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
  var util = require_util();
  var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");
  var channels = {};
  var extractBody;
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create");
    channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
    channels.headers = diagnosticsChannel.channel("undici:request:headers");
    channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
    channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: false };
    channels.bodySent = { hasSubscribers: false };
    channels.headers = { hasSubscribers: false };
    channels.trailers = { hasSubscribers: false };
    channels.error = { hasSubscribers: false };
  }

  class Request {
    constructor(origin, {
      path: path5,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset: reset2,
      throwOnError,
      expectContinue
    }, handler) {
      if (typeof path5 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path5[0] !== "/" && !(path5.startsWith("http://") || path5.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.exec(path5) !== null) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (tokenRegExp.exec(method) === null) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset2 != null && typeof reset2 !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body == null) {
        this.body = null;
      } else if (util.isStream(body)) {
        this.body = body;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            util.destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (util.isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? util.buildURL(path5, query) : path5;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset2 == null ? null : reset2;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = "";
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i2 = 0;i2 < headers.length; i2 += 2) {
          processHeader(this, headers[i2], headers[i2 + 1]);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i2 = 0;i2 < keys.length; i2++) {
          const key = keys[i2];
          processHeader(this, key, headers[key]);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (util.isFormDataLike(this.body)) {
        if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        }
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (this.contentType == null) {
          this.contentType = contentType;
          this.headers += `content-type: ${contentType}\r\n`;
        }
        this.body = bodyStream.stream;
        this.contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
        this.contentType = body.type;
        this.headers += `content-type: ${body.type}\r\n`;
      }
      util.validateHandler(handler, method, upgrade);
      this.servername = util.getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort2) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort2(this.error);
      } else {
        this.abort = abort2;
        return this[kHandler].onConnect(abort2);
      }
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error2) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error: error2 });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error2);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
    static [kHTTP1BuildRequest](origin, opts, handler) {
      return new Request(origin, opts, handler);
    }
    static [kHTTP2BuildRequest](origin, opts, handler) {
      const headers = opts.headers;
      opts = { ...opts, headers: null };
      const request = new Request(origin, opts, handler);
      request.headers = {};
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i2 = 0;i2 < headers.length; i2 += 2) {
          processHeader(request, headers[i2], headers[i2 + 1], true);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i2 = 0;i2 < keys.length; i2++) {
          const key = keys[i2];
          processHeader(request, key, headers[key], true);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      return request;
    }
    static [kHTTP2CopyHeaders](raw) {
      const rawHeaders = raw.split("\r\n");
      const headers = {};
      for (const header of rawHeaders) {
        const [key, value] = header.split(": ");
        if (value == null || value.length === 0)
          continue;
        if (headers[key])
          headers[key] += `,${value}`;
        else
          headers[key] = value;
      }
      return headers;
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events");

  class Dispatcher extends EventEmitter2 {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
  var kDestroyed = Symbol("destroyed");
  var kClosed = Symbol("closed");
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i2 = newInterceptors.length - 1;i2 >= 0; i2--) {
          const interceptor = this[kInterceptors][i2];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject4) => {
          this.close((err, data) => {
            return err ? reject4(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i2 = 0;i2 < callbacks.length; i2++) {
          callbacks[i2](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject4) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject4(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i2 = 0;i2 < callbacks.length; i2++) {
          callbacks[i2](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i2 = this[kInterceptors].length - 1;i2 >= 0; i2--) {
        dispatch = this[kInterceptors][i2](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout: timeout3, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options3 = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout3 = timeout3 == null ? 1e4 : timeout3;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("tls");
        }
        servername = servername || options3.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        const session = sessionCache.get(sessionKey) || null;
        assert(sessionKey);
        socket = tls.connect({
          highWaterMark: 16384,
          ...options3,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port: port || 443,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options3,
          localAddress,
          port: port || 80,
          host: hostname
        });
      }
      if (options3.keepAlive == null || options3.keepAlive) {
        const keepAliveInitialDelay = options3.keepAliveInitialDelay === undefined ? 60000 : options3.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout3);
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  function setupTimeout(onConnectTimeout2, timeout3) {
    if (!timeout3) {
      return () => {
      };
    }
    let s1 = null;
    let s2 = null;
    const timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32") {
          s2 = setImmediate(() => onConnectTimeout2());
        } else {
          onConnectTimeout2();
        }
      });
    }, timeout3);
    return () => {
      clearTimeout(timeoutId);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  }
  function onConnectTimeout(socket) {
    util.destroy(socket, new ConnectTimeoutError);
  }
  var net = __require("net");
  var assert = __require("assert");
  var util = require_util();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var tls;
  var SessionCache;
  if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
        this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== undefined && ref.deref() === undefined) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS((exports) => {
  function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = undefined;
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils2();
  var ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2["OK"] = 0] = "OK";
    ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
    ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
    ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
    ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR2[ERROR2["USER"] = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
    TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
    TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
    FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
    FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
    FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
    FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i2 = "A".charCodeAt(0);i2 <= "Z".charCodeAt(0); i2++) {
    exports.ALPHA.push(String.fromCharCode(i2));
    exports.ALPHA.push(String.fromCharCode(i2 + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "\'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "\'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i2 = 128;i2 <= 255; i2++) {
    exports.URL_CHAR.push(i2);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "\'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i2 = 32;i2 <= 255; i2++) {
    if (i2 !== 127) {
      exports.HEADER_CHARS.push(i2);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c3) => c3 !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS((exports, module) => {
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i2 = 0;i2 < headers.length; i2 += 2) {
      if (headers[i2].toString().toLowerCase() === "location") {
        return headers[i2 + 1];
      }
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util.headerNameToString(header) === "host";
    }
    if (removeContent && util.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i2 = 0;i2 < headers.length; i2 += 2) {
        if (!shouldRemoveHeader(headers[i2], removeContent, unknownOrigin)) {
          ret.push(headers[i2], headers[i2 + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      for (const key of Object.keys(headers)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers[key]);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  }
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort2) {
      this.abort = abort2;
      this.handler.onConnect(abort2, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error2) {
      this.handler.onError(error2);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path5 = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path5;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) {
      } else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS((exports, module) => {
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  }
  var RedirectHandler = require_RedirectHandler();
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/client.js
var require_client = __commonJS((exports, module) => {
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    onError(this[kClient], err);
  }
  function onHttp2FrameError(type15, code, id) {
    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type15}, code ${code}`);
    if (id === 0) {
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
  }
  function onHttp2SessionEnd() {
    util.destroy(this, new SocketError("other side closed"));
    util.destroy(this[kSocket], new SocketError("other side closed"));
  }
  function onHTTP2GoAway(code) {
    const client = this[kClient];
    const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    client[kSocket] = null;
    client[kHTTP2Session] = null;
    if (client.destroyed) {
      assert(this[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i2 = 0;i2 < requests.length; i2++) {
        const request = requests[i2];
        errorRequest(this, request, err);
      }
    } else if (client[kRunning] > 0) {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  }
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start2 = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start2, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!parser.paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_IDLE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  function onSocketReadable() {
    const { [kParser]: parser } = this;
    if (parser) {
      parser.readMore();
    }
  }
  function onSocketError(err) {
    const { [kClient]: client, [kParser]: parser } = this;
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    if (client[kHTTPConnVersion] !== "h2") {
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    this[kError] = err;
    onError(this[kClient], err);
  }
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i2 = 0;i2 < requests.length; i2++) {
        const request = requests[i2];
        errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  function onSocketEnd() {
    const { [kParser]: parser, [kClient]: client } = this;
    if (client[kHTTPConnVersion] !== "h2") {
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  }
  function onSocketClose() {
    const { [kClient]: client, [kParser]: parser } = this;
    if (client[kHTTPConnVersion] === "h1" && parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    client[kSocket] = null;
    if (client.destroyed) {
      assert(client[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i2 = 0;i2 < requests.length; i2++) {
        const request = requests[i2];
        errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  }
  async function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kSocket]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject4) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject4(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", () => {
        }), new ClientDestroyedError);
        return;
      }
      client[kConnecting] = false;
      assert(socket);
      const isH2 = socket.alpnProtocol === "h2";
      if (isH2) {
        if (!h2ExperimentalWarned) {
          h2ExperimentalWarned = true;
          process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          });
        }
        const session = http2.connect(client[kUrl], {
          createConnection: () => socket,
          peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
        });
        client[kHTTPConnVersion] = "h2";
        session[kClient] = client;
        session[kSocket] = socket;
        session.on("error", onHttp2SessionError);
        session.on("frameError", onHttp2FrameError);
        session.on("end", onHttp2SessionEnd);
        session.on("goaway", onHTTP2GoAway);
        session.on("close", onSocketClose);
        session.unref();
        client[kHTTP2Session] = session;
        socket[kHTTP2Session] = session;
      } else {
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kParser] = new Parser(client, socket, llhttpInstance);
      }
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket[kClient] = client;
      socket[kError] = null;
      socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
      client[kSocket] = socket;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) {
        return;
      }
      client[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          const request = client[kQueue][client[kPendingIdx]++];
          errorRequest(client, request, err);
        }
      } else {
        onError(client, err);
      }
      client.emit("connectionError", client[kUrl], [client], err);
    }
    resume(client);
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      const socket = client[kSocket];
      if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request2 = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (client[kPipelining] || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        if (socket && socket.servername !== request.servername) {
          util.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client[kConnecting]) {
        return;
      }
      if (!socket && !client[kHTTP2Session]) {
        connect(client);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
        return;
      }
      if (client[kRunning] > 0 && !request.idempotent) {
        return;
      }
      if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
        return;
      }
      if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
        return;
      }
      if (!request.aborted && write(client, request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function write(client, request) {
    if (client[kHTTPConnVersion] === "h2") {
      writeH2(client, client[kHTTP2Session], request);
      return;
    }
    const { body, method, path: path5, host, upgrade, headers, blocking, reset: reset2 } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    const bodyLength = util.bodyLength(body);
    let contentLength = bodyLength;
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
        util.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset2 != null) {
      socket[kReset] = reset2;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path5} HTTP/1.1\r\n`;
    if (typeof host === "string") {
      header += `host: ${host}\r\n`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += "connection: keep-alive\r\n";
    } else {
      header += "connection: close\r\n";
    }
    if (headers) {
      header += headers;
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body || bodyLength === 0) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r\n`, "latin1");
      }
      request.onRequestSent();
    } else if (util.isBuffer(body)) {
      assert(contentLength === body.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
      socket.write(body);
      socket.uncork();
      request.onBodySent(body);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
      } else {
        writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
      }
    } else if (util.isStream(body)) {
      writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
    } else if (util.isIterable(body)) {
      writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
    } else {
      assert(false);
    }
    return true;
  }
  function writeH2(client, session, request) {
    const { body, method, path: path5, host, upgrade, expectContinue, signal: signal5, headers: reqHeaders } = request;
    let headers;
    if (typeof reqHeaders === "string")
      headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
    else
      headers = reqHeaders;
    if (upgrade) {
      errorRequest(client, request, new Error("Upgrade not supported for H2"));
      return false;
    }
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    let stream3;
    const h2State = client[kHTTP2SessionState];
    headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
    headers[HTTP2_HEADER_METHOD] = method;
    if (method === "CONNECT") {
      session.ref();
      stream3 = session.request(headers, { endStream: false, signal: signal5 });
      if (stream3.id && !stream3.pending) {
        request.onUpgrade(null, null, stream3);
        ++h2State.openStreams;
      } else {
        stream3.once("ready", () => {
          request.onUpgrade(null, null, stream3);
          ++h2State.openStreams;
        });
      }
      stream3.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0)
          session.unref();
      });
      return true;
    }
    headers[HTTP2_HEADER_PATH] = path5;
    headers[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (contentLength == null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null) {
      assert(body, "no body must not have content length");
      headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD";
    if (expectContinue) {
      headers[HTTP2_HEADER_EXPECT] = "100-continue";
      stream3 = session.request(headers, { endStream: shouldEndStream, signal: signal5 });
      stream3.once("continue", writeBodyH2);
    } else {
      stream3 = session.request(headers, {
        endStream: shouldEndStream,
        signal: signal5
      });
      writeBodyH2();
    }
    ++h2State.openStreams;
    stream3.once("response", (headers2) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      if (request.onHeaders(Number(statusCode), realHeaders, stream3.resume.bind(stream3), "") === false) {
        stream3.pause();
      }
    });
    stream3.once("end", () => {
      request.onComplete([]);
    });
    stream3.on("data", (chunk) => {
      if (request.onData(chunk) === false) {
        stream3.pause();
      }
    });
    stream3.once("close", () => {
      h2State.openStreams -= 1;
      if (h2State.openStreams === 0) {
        session.unref();
      }
    });
    stream3.once("error", function(err) {
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util.destroy(stream3, err);
      }
    });
    stream3.once("frameError", (type15, code) => {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type15}, code ${code}`);
      errorRequest(client, request, err);
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util.destroy(stream3, err);
      }
    });
    return true;
    function writeBodyH2() {
      if (!body) {
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        stream3.cork();
        stream3.write(body);
        stream3.uncork();
        stream3.end();
        request.onBodySent(body);
        request.onRequestSent();
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({
            client,
            request,
            contentLength,
            h2stream: stream3,
            expectsPayload,
            body: body.stream(),
            socket: client[kSocket],
            header: ""
          });
        } else {
          writeBlob({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            h2stream: stream3,
            header: "",
            socket: client[kSocket]
          });
        }
      } else if (util.isStream(body)) {
        writeStream({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          socket: client[kSocket],
          h2stream: stream3,
          header: ""
        });
      } else if (util.isIterable(body)) {
        writeIterable({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream3,
          socket: client[kSocket]
        });
      } else {
        assert(false);
      }
    }
  }
  function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    if (client[kHTTPConnVersion] === "h2") {
      let onPipeData = function(chunk) {
        request.onBodySent(chunk);
      };
      const pipe = pipeline4(body, h2stream, (err) => {
        if (err) {
          util.destroy(body, err);
          util.destroy(h2stream, err);
        } else {
          request.onRequestSent();
        }
      });
      pipe.on("data", onPipeData);
      pipe.once("end", () => {
        pipe.removeListener("data", onPipeData);
        util.destroy(pipe);
      });
      return;
    }
    let finished7 = false;
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished7) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished7) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onAbort = function() {
      if (finished7) {
        return;
      }
      const err = new RequestAbortedError;
      queueMicrotask(() => onFinished(err));
    };
    const onFinished = function(err) {
      if (finished7) {
        return;
      }
      finished7 = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
  }
  async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength === body.size, "blob body must have content length");
    const isH2 = client[kHTTPConnVersion] === "h2";
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      if (isH2) {
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
      } else {
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
        socket.write(buffer);
        socket.uncork();
      }
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      resume(client);
    } catch (err) {
      util.destroy(isH2 ? h2stream : socket, err);
    }
  }
  async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject4) => {
      assert(callback === null);
      if (socket[kError]) {
        reject4(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    if (client[kHTTPConnVersion] === "h2") {
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
      } catch (err) {
        h2stream.destroy(err);
      } finally {
        request.onRequestSent();
        h2stream.end();
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
      return;
    }
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  var assert = __require("assert");
  var net = __require("net");
  var http = __require("http");
  var { pipeline: pipeline4 } = __require("stream");
  var util = require_util();
  var timers = require_timers();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kHTTPConnVersion,
    kHost,
    kHTTP2Session,
    kHTTP2SessionState,
    kHTTP2BuildRequest,
    kHTTP2CopyHeaders,
    kHTTP1BuildRequest
  } = require_symbols();
  var http2;
  try {
    http2 = __require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  var h2ExperimentalWarned = false;
  var FastBuffer = Buffer[Symbol.species];
  var kClosedResolve = Symbol("kClosedResolve");
  var channels = {};
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
    channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
    channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
    channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: false };
    channels.beforeConnect = { hasSubscribers: false };
    channels.connectError = { hasSubscribers: false };
    channels.connected = { hasSubscribers: false };
  }

  class Client extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      maxConcurrentStreams
    } = {}) {
      super();
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r\n`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kHTTPConnVersion] = "h1";
      this[kHTTP2Session] = null;
      this[kHTTP2SessionState] = !allowH2 ? null : {
        openStreams: 0,
        maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
      };
      this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {
      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        process.nextTick(resume, this);
      } else {
        resume(this, true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize]) {
          resolve(null);
        } else {
          this[kClosedResolve] = resolve;
        }
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i2 = 0;i2 < requests.length; i2++) {
          const request = requests[i2];
          errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve();
        };
        if (this[kHTTP2Session] != null) {
          util.destroy(this[kHTTP2Session], err);
          this[kHTTP2Session] = null;
          this[kHTTP2SessionState] = null;
        }
        if (!this[kSocket]) {
          queueMicrotask(callback);
        } else {
          util.destroy(this[kSocket].on("close", callback), err);
        }
        resume(this);
      });
    }
  }
  var constants4 = require_constants3();
  var createRedirectInterceptor = require_redirectInterceptor();
  var EMPTY_BUF = Buffer.alloc(0);
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var TIMEOUT_HEADERS = 1;
  var TIMEOUT_BODY = 2;
  var TIMEOUT_IDLE = 3;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants4.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(value, type15) {
      this.timeoutType = type15;
      if (value !== this.timeoutValue) {
        timers.clearTimeout(this.timeout);
        if (value) {
          this.timeout = timers.setTimeout(onParserTimeout, value, this);
          if (this.timeout.unref) {
            this.timeout.unref();
          }
        } else {
          this.timeout = null;
        }
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants4.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants4.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants4.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message2 = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message2 = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message2, constants4.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
        this.connection += buf.toString();
      } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(!socket.destroyed);
      assert(socket === client[kSocket]);
      assert(!this.paused);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
      client[kSocket] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      resume(client);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout3 = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout3 <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout3;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      if (request.aborted) {
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        resume(client);
      }
      return pause ? constants4.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      if (request.onData(buf) === false) {
        return constants4.ERROR.PAUSED;
      }
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(statusCode >= 100);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      request.onComplete(headers);
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert.strictEqual(client[kRunning], 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants4.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants4.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants4.ERROR.PAUSED;
      } else if (client[kPipelining] === 1) {
        setImmediate(resume, client);
      } else {
        resume(client);
      }
    }
  }

  class AsyncWriter {
    constructor({ socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
        } else {
          socket.write(`${header}\r\n`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write("\r\n0\r\n\r\n", "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      resume(client);
    }
    destroy(err) {
      const { socket, client } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        util.destroy(socket, err);
      }
    }
  }
  module.exports = Client;
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined)
        return null;
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
  var kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var PoolStats = require_pool_stats();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue;
      this[kClients] = [];
      this[kQueued] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool[kNeedDrain]) {
          pool[kNeedDrain] = false;
          pool.emit("drain", origin, [pool, ...targets]);
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c3) => c3.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty()) {
        return Promise.all(this[kClients].map((c3) => c3.close()));
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async[kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c3) => c3.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        process.nextTick(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client[kUrl], [this, client]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS((exports, module) => {
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base();
  var Client = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl, kInterceptors } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options3
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      this[kInterceptors] = options3.interceptors && options3.interceptors.Pool && Array.isArray(options3.interceptors.Pool) ? options3.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options3), connect, allowH2 };
      this[kOptions].interceptors = options3.interceptors ? { ...options3.interceptors } : undefined;
      this[kFactory] = factory;
    }
    [kGetDispatcher]() {
      let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
      if (dispatcher) {
        return dispatcher;
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
      }
      return dispatcher;
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  function getGreatestCommonDivisor(a2, b) {
    if (b === 0)
      return a2;
    return getGreatestCommonDivisor(b, a2 % b);
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl, kInterceptors } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a2, b) => a2 && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE) {
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return {
      WeakRef: global.WeakRef || CompatWeakRef,
      FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
    };
  };
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS((exports, module) => {
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }
  var { InvalidArgumentError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client = require_client();
  var util = require_util();
  var createRedirectInterceptor = require_redirectInterceptor();
  var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kFinalizer = Symbol("finalizer");
  var kOptions = Symbol("options");

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options3 } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kInterceptors] = options3.interceptors && options3.interceptors.Agent && Array.isArray(options3.interceptors.Agent) ? options3.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util.deepClone(options3), connect };
      this[kOptions].interceptors = options3.interceptors ? { ...options3.interceptors } : undefined;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kFinalizer] = new FinalizationRegistry((key) => {
        const ref = this[kClients].get(key);
        if (ref !== undefined && ref.deref() === undefined) {
          this[kClients].delete(key);
        }
      });
      const agent = this;
      this[kOnDrain] = (origin, targets) => {
        agent.emit("drain", origin, [agent, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        agent.emit("connect", origin, [agent, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        agent.emit("disconnect", origin, [agent, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        agent.emit("connectionError", origin, [agent, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          ret += client[kRunning];
        }
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      const ref = this[kClients].get(key);
      let dispatcher = ref ? ref.deref() : null;
      if (!dispatcher) {
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, new WeakRef2(dispatcher));
        this[kFinalizer].register(dispatcher, key);
      }
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      const closePromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          closePromises.push(client.close());
        }
      }
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      const destroyPromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          destroyPromises.push(client.destroy(err));
        }
      }
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  }
  function isUnusable(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream3, type15) {
    if (isUnusable(stream3)) {
      throw new TypeError("unusable");
    }
    assert(!stream3[kConsume]);
    return new Promise((resolve, reject4) => {
      stream3[kConsume] = {
        type: type15,
        stream: stream3,
        resolve,
        reject: reject4,
        length: 0,
        body: []
      };
      stream3.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null) {
          consumeFinish(this[kConsume], new RequestAbortedError);
        }
      });
      process.nextTick(consumeStart, stream3[kConsume]);
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    for (const chunk of state.buffer) {
      consumePush(consume2, chunk);
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  }
  function consumeEnd(consume2) {
    const { type: type15, body, resolve, stream: stream3, length } = consume2;
    try {
      if (type15 === "text") {
        resolve(toUSVString(Buffer.concat(body)));
      } else if (type15 === "json") {
        resolve(JSON.parse(Buffer.concat(body)));
      } else if (type15 === "arrayBuffer") {
        const dst = new Uint8Array(length);
        let pos = 0;
        for (const buf of body) {
          dst.set(buf, pos);
          pos += buf.byteLength;
        }
        resolve(dst.buffer);
      } else if (type15 === "blob") {
        if (!Blob2) {
          Blob2 = __require("buffer").Blob;
        }
        resolve(new Blob2(body, { type: stream3[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream3.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  var assert = __require("assert");
  var { Readable: Readable4 } = __require("stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom, toUSVString } = require_util();
  var Blob2;
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("abort");
  var kContentType = Symbol("kContentType");
  var noop3 = () => {
  };
  module.exports = class BodyReadable extends Readable4 {
    constructor({
      resume,
      abort: abort2,
      contentType = "",
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort2;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kReading] = false;
    }
    destroy(err) {
      if (this.destroyed) {
        return this;
      }
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data") {
        this._readableState.dataEmitted = true;
      } else if (ev === "error") {
        this._readableState.errorEmitted = true;
      }
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
      const signal5 = opts && opts.signal;
      if (signal5) {
        try {
          if (typeof signal5 !== "object" || !("aborted" in signal5)) {
            throw new InvalidArgumentError("signal must be an AbortSignal");
          }
          util.throwIfAborted(signal5);
        } catch (err) {
          return Promise.reject(err);
        }
      }
      if (this.closed) {
        return Promise.resolve(null);
      }
      return new Promise((resolve, reject4) => {
        const signalListenerCleanup = signal5 ? util.addAbortListener(signal5, () => {
          this.destroy();
        }) : noop3;
        this.on("close", function() {
          signalListenerCleanup();
          if (signal5 && signal5.aborted) {
            reject4(signal5.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
          } else {
            resolve(null);
          }
        }).on("error", noop3).on("data", function(chunk) {
          limit -= chunk.length;
          if (limit <= 0) {
            this.destroy();
          }
        }).resume();
      });
    }
  };
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [];
    let limit = 0;
    for await (const chunk of body) {
      chunks.push(chunk);
      limit += chunk.length;
      if (limit > 128 * 1024) {
        chunks = null;
        break;
      }
    }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        const payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
    } catch (err) {
    }
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
  }
  var assert = __require("assert");
  var {
    ResponseStatusCodeError
  } = require_errors();
  var { toUSVString } = require_util();
  module.exports = { getResolveErrorBodyCallback };
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  function abort2(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError);
    }
  }
  function addSignal(self2, signal5) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal5) {
      return;
    }
    if (signal5.aborted) {
      abort2(self2);
      return;
    }
    self2[kSignal] = signal5;
    self2[kListener] = () => {
      abort2(self2);
    };
    addAbortListener3(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  var { addAbortListener: addAbortListener3 } = require_util();
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  function request(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject4) => {
        request.call(this, opts, (err, data) => {
          return err ? reject4(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  var Readable4 = require_readable();
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal: signal5, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal5 && typeof signal5.on !== "function" && typeof signal5.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal5);
    }
    onConnect(abort2, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort2;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort: abort2, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const body = new Readable4({ resume, abort: abort2, contentType, highWaterMark });
      this.callback = null;
      this.res = body;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
        }
      }
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      util.parseHeaders(trailers, this.trailers);
      res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res, err);
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  function stream3(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject4) => {
        stream3.call(this, opts, factory, (err, data) => {
          return err ? reject4(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  var { finished: finished7, PassThrough: PassThrough2 } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal: signal5, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal5 && typeof signal5.on !== "function" && typeof signal5.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal5);
    }
    onConnect(abort2, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort2;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough2;
        this.callback = null;
        this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished7(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort: abort2 } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort2();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  module.exports = stream3;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  function pipeline4(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough2().destroy(err);
    }
  }
  var {
    Readable: Readable4,
    Duplex: Duplex4,
    PassThrough: PassThrough2
  } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable4 {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable4 {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal: signal5, method, opaque, onInfo, responseHeaders } = opts;
      if (signal5 && typeof signal5.on !== "function" && typeof signal5.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex4({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort: abort2 } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort2 && err) {
            abort2();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal5);
    }
    onConnect(abort2, context) {
      const { ret, res } = this;
      assert(!res, "pipeline cannot be retried");
      if (ret.destroyed) {
        throw new RequestAbortedError;
      }
      this.abort = abort2;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  module.exports = pipeline4;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  function upgrade(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject4) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject4(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var { AsyncResource } = __require("async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal: signal5, opaque, responseHeaders } = opts;
      if (signal5 && typeof signal5.on !== "function" && typeof signal5.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal5);
    }
    onConnect(abort2, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort2;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  function connect(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject4) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject4(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  var { AsyncResource } = __require("async_hooks");
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal: signal5, opaque, responseHeaders } = opts;
      if (signal5 && typeof signal5.on !== "function" && typeof signal5.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal5);
    }
    onConnect(abort2, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort2;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers = rawHeaders;
      if (headers != null) {
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();

  class MockNotMatchedError extends UndiciError {
    constructor(message2) {
      super(message2);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message2 || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i2 = 0;i2 < headers.length; i2 += 2) {
        if (headers[i2].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i2 + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function safeUrl(path5) {
    if (typeof path5 !== "string") {
      return path5;
    }
    const pathSegments = path5.split("?");
    if (pathSegments.length !== 2) {
      return path5;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path: path5, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path5);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path5 }) => matchValue(safeUrl(path5), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function buildKey(opts) {
    const { path: path5, method, body, headers, query } = opts;
    return {
      path: path5,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error2 !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error2);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.abort = nop;
      handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData(Buffer.from(responseData));
      handler.onComplete(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  }
  function buildMockDispatch() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error2) {
          if (error2 instanceof MockNotMatchedError) {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error2;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildMockOptions(opts) {
    if (opts) {
      const { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { buildURL, nop } = require_util();
  var { STATUS_CODES } = __require("http");
  var {
    types: {
      isPromise
    }
  } = __require("util");
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof data === "undefined") {
        throw new InvalidArgumentError("data must be defined");
      }
      if (typeof responseOptions !== "object") {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyData) {
      if (typeof replyData === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyData(opts);
          if (typeof resolvedData !== "object") {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          this.validateReplyParameters(statusCode2, data2, responseOptions2);
          return {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error2) {
      if (typeof error2 === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify: promisify2 } = __require("util");
  var Client = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify2(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify: promisify2 } = __require("util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify2(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  var plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count2) {
      const one = count2 === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count: count2, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform: Transform2 } = __require("stream");
  var { Console } = __require("console");
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform2({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path: path5, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path5,
        "Status code": statusCode,
        Persistent: persist ? "\u2705" : "\u274C",
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, buildMockOptions } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var Pluralizer = require_pluralizer();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher) {
        dispatcher = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher));
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const ref = this[kClients].get(origin);
      if (ref) {
        return ref.deref();
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        const nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function buildProxyOptions(opts) {
    if (typeof opts === "string") {
      opts = { uri: opts };
    }
    if (!opts || !opts.uri) {
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    }
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i2 = 0;i2 < headers.length; i2 += 2) {
        headersPair[headers[i2]] = headers[i2 + 1];
      }
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
  var { URL: URL2 } = __require("url");
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var buildConnector = require_connect();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      this[kProxy] = buildProxyOptions(opts);
      this[kAgent] = new Agent(opts);
      this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      const resolvedUrl = new URL2(opts.uri);
      const { origin, port, host, username, password } = resolvedUrl;
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(resolvedUrl, { connect });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port) {
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200) {
              socket.on("error", () => {
              }).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      const { host } = new URL2(opts.origin);
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      return this[kAgent].dispatch({
        ...opts,
        headers: {
          ...headers,
          host
        }
      }, handler);
    }
    async[kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS((exports, module) => {
  function calculateRetryAfterHeader(retryAfter) {
    const current = Date.now();
    const diff = new Date(retryAfter).getTime() - current;
    return diff;
  }
  var assert = __require("assert");
  var { kRetryHandlerDefaultRetry } = require_symbols();
  var { RequestRetryError } = require_errors();
  var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();

  class RetryHandler {
    constructor(opts, handlers) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods: methods3,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch;
      this.handler = handlers.handler;
      this.opts = dispatchOpts;
      this.abort = null;
      this.aborted = false;
      this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1000,
        timeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods3 ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE"
        ]
      };
      this.retryCount = 0;
      this.start = 0;
      this.end = null;
      this.etag = null;
      this.resume = null;
      this.handler.onConnect((reason) => {
        this.aborted = true;
        if (this.abort) {
          this.abort(reason);
        } else {
          this.reason = reason;
        }
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) {
        this.handler.onRequestSent();
      }
    }
    onUpgrade(statusCode, headers, socket) {
      if (this.handler.onUpgrade) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
    }
    onConnect(abort2) {
      if (this.aborted) {
        abort2(this.reason);
      } else {
        this.abort = abort2;
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      const { statusCode, code, headers } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        timeout: timeout3,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods: methods3
      } = retryOptions;
      let { counter, currentTimeout } = state;
      currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout3;
      if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods3) && !methods3.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers != null && headers["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1000;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
      state.currentTimeout = retryTimeout;
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers = parseHeaders(rawHeaders);
      this.retryCount += 1;
      if (statusCode >= 300) {
        this.abort(new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        }));
        return false;
      }
      if (this.resume != null) {
        this.resume = null;
        if (statusCode !== 206) {
          return true;
        }
        const contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange) {
          this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            count: this.retryCount
          }));
          return false;
        }
        if (this.etag != null && this.etag !== headers.etag) {
          this.abort(new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            count: this.retryCount
          }));
          return false;
        }
        const { start: start2, size, end = size } = contentRange;
        assert(this.start === start2, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        this.resume = resume;
        return true;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers["content-range"]);
          if (range == null) {
            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          }
          const { start: start2, size, end = size } = range;
          assert(start2 != null && Number.isFinite(start2) && this.start !== start2, "content-range mismatch");
          assert(Number.isFinite(start2));
          assert(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length");
          this.start = start2;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) : null;
        }
        assert(Number.isFinite(this.start));
        assert(this.end == null || Number.isFinite(this.end), "invalid content-length");
        this.resume = resume;
        this.etag = headers.etag != null ? headers.etag : null;
        return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      const err = new RequestRetryError("Request failed", statusCode, {
        headers,
        count: this.retryCount
      });
      this.abort(err);
      return false;
    }
    onData(chunk) {
      this.start += chunk.length;
      return this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      this.retryCount = 0;
      return this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err);
      }
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, onRetry.bind(this));
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err2);
        }
        if (this.start !== 0) {
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`
            }
          };
        }
        try {
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  module.exports = RetryHandler;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS((exports, module) => {
  module.exports = class DecoratorHandler {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i2 = 0;
    let j = potentialValue.length;
    while (j > i2 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i2 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i2)))
      ++i2;
    return i2 === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i2, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object)) {
      for (let i2 = 0;i2 < object.length; ++i2) {
        const header = object[i2];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i2 = 0;i2 < keys.length; ++i2) {
        appendHeader(headers, keys[i2], object[keys[i2]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (headers[kGuard] === "immutable") {
      throw new TypeError("immutable");
    } else if (headers[kGuard] === "request-no-cors") {
    }
    return headers[kHeadersList].append(name, value);
  }
  var { kHeadersList, kConstruct } = require_symbols();
  var { kGuard } = require_symbols2();
  var { kEnumerableProperty } = require_util();
  var {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var { webidl } = require_webidl();
  var assert = __require("assert");
  var kHeadersMap = Symbol("headers map");
  var kHeadersSortedMap = Symbol("headers map sorted");

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    contains(name) {
      name = name.toLowerCase();
      return this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    append(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        this.cookies ??= [];
        this.cookies.push(value);
      }
    }
    set(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name) {
      this[kHeadersSortedMap] = null;
      name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    get(name) {
      const value = this[kHeadersMap].get(name.toLowerCase());
      return value === undefined ? null : value.value;
    }
    *[Symbol.iterator]() {
      for (const [name, { value }] of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this[kHeadersMap].size) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
  }

  class Headers {
    constructor(init = undefined) {
      if (init === kConstruct) {
        return;
      }
      this[kHeadersList] = new HeadersList;
      this[kGuard] = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init);
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      return appendHeader(this, name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      if (!this[kHeadersList].contains(name)) {
        return;
      }
      this[kHeadersList].delete(name);
    }
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].get(name);
    }
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].contains(name);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      this[kHeadersList].set(name, value);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this[kHeadersList].cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap]) {
        return this[kHeadersList][kHeadersSortedMap];
      }
      const headers = [];
      const names = [...this[kHeadersList]].sort((a2, b) => a2[0] < b[0] ? -1 : 1);
      const cookies = this[kHeadersList].cookies;
      for (let i2 = 0;i2 < names.length; ++i2) {
        const [name, value] = names[i2];
        if (name === "set-cookie") {
          for (let j = 0;j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          assert(value !== null);
          headers.push([name, value]);
        }
      }
      this[kHeadersList][kHeadersSortedMap] = headers;
      return headers;
    }
    keys() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
    }
    values() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
    }
    entries() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key+value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      webidl.brandCheck(this, Headers);
      return this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: false },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator]) {
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      }
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    Headers,
    HeadersList
  };
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS((exports, module) => {
  function cloneResponse(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(response.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList,
      urlList: init.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function makeFilteredResponse(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response, type15) {
    if (type15 === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type15 === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type15 === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type15 === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response[kHeaders], init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response.status
        });
      }
      response[kState].body = body.body;
      if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
        response[kState].headersList.append("content-type", body.type);
      }
    }
  }
  var { Headers, HeadersList, fill } = require_headers();
  var { extractBody, cloneBody, mixinBody } = require_body();
  var util = require_util();
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = require_util2();
  var {
    redirectStatusSet,
    nullBodyStatus,
    DOMException: DOMException2
  } = require_constants2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { FormData: FormData2 } = require_formdata();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList, kConstruct } = require_symbols();
  var assert = __require("assert");
  var { types } = __require("util");
  var ReadableStream2 = globalThis.ReadableStream || __require("stream/web").ReadableStream;
  var textEncoder3 = new TextEncoder("utf-8");

  class Response {
    static error() {
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response;
      responseObject[kState] = makeNetworkError();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      return responseObject;
    }
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder3.encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "response";
      responseObject[kHeaders][kRealm] = relevantRealm;
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      const relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(new TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError("Invalid status code " + status);
      }
      const responseObject = new Response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value);
      return responseObject;
    }
    constructor(body = null, init = {}) {
      if (body !== null) {
        body = webidl.converters.BodyInit(body);
      }
      init = webidl.converters.ResponseInit(init);
      this[kRealm] = { settingsObject: {} };
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers(kConstruct);
      this[kHeaders][kGuard] = "response";
      this[kHeaders][kHeadersList] = this[kState].headersList;
      this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type15] = extractBody(body);
        bodyWithType = { body: extractedBody, type: type15 };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response);
      return this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response);
      return this[kState].urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response);
      return this[kState].status;
    }
    get ok() {
      webidl.brandCheck(this, Response);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response);
      return this[kState].statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response);
      if (this.bodyUsed || this.body && this.body.locked) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      const clonedResponseObject = new Response;
      clonedResponseObject[kState] = clonedResponse;
      clonedResponseObject[kRealm] = this[kRealm];
      clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
      clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      return clonedResponseObject;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream2);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false });
    }
    if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
      return webidl.converters.BufferSource(V);
    }
    if (util.isFormDataLike(V)) {
      return webidl.converters.FormData(V, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream2) {
      return webidl.converters.ReadableStream(V);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse
  };
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  function makeRequest(init) {
    const request = {
      method: "GET",
      localURLsOnly: false,
      unsafeRequest: false,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: false,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: false,
      credentials: "same-origin",
      useCredentials: false,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: false,
      historyNavigation: false,
      userActivation: false,
      taintedOrigin: false,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: false,
      done: false,
      timingAllowFailed: false,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
    request.url = request.urlList[0];
    return request;
  }
  function cloneRequest(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(request.body);
    }
    return newRequest;
  }
  var { extractBody, mixinBody, cloneBody } = require_body();
  var { Headers, fill: fillHeaders, HeadersList } = require_headers();
  var { FinalizationRegistry } = require_dispatcher_weakref()();
  var util = require_util();
  var {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer,
    normalizeMethodRecord
  } = require_util2();
  var {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants2();
  var { kEnumerableProperty } = util;
  var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList, kConstruct } = require_symbols();
  var assert = __require("assert");
  var { getMaxListeners, setMaxListeners: setMaxListeners2, getEventListeners, defaultMaxListeners } = __require("events");
  var TransformStream = globalThis.TransformStream;
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry(({ signal: signal5, abort: abort2 }) => {
    signal5.removeEventListener("abort", abort2);
  });

  class Request {
    constructor(input, init = {}) {
      if (input === kConstruct) {
        return;
      }
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request = null;
      let fallbackMode = null;
      const baseUrl = this[kRealm].settingsObject.baseUrl;
      let signal5 = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert(input instanceof Request);
        request = input[kState];
        signal5 = input[kSignal];
      }
      const origin = this[kRealm].settingsObject.origin;
      let window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window2 = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: this[kRealm].settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
            request.referrer = "client";
          } else {
            request.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        if (!isValidHTTPToken(method)) {
          throw new TypeError(`'${method}' is not a valid HTTP method.`);
        }
        if (forbiddenMethodsSet.has(method.toUpperCase())) {
          throw new TypeError(`'${method}' HTTP method is unsupported.`);
        }
        method = normalizeMethodRecord[method] ?? normalizeMethod(method);
        request.method = method;
      }
      if (init.signal !== undefined) {
        signal5 = init.signal;
      }
      this[kState] = request;
      const ac = new AbortController;
      this[kSignal] = ac.signal;
      this[kSignal][kRealm] = this[kRealm];
      if (signal5 != null) {
        if (!signal5 || typeof signal5.aborted !== "boolean" || typeof signal5.addEventListener !== "function") {
          throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        }
        if (signal5.aborted) {
          ac.abort(signal5.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort2 = function() {
            const ac2 = acRef.deref();
            if (ac2 !== undefined) {
              ac2.abort(this.reason);
            }
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal5) === defaultMaxListeners) {
              setMaxListeners2(100, signal5);
            } else if (getEventListeners(signal5, "abort").length >= defaultMaxListeners) {
              setMaxListeners2(100, signal5);
            }
          } catch {
          }
          util.addAbortListener(signal5, abort2);
          requestFinalizer.register(ac, { signal: signal5, abort: abort2 });
        }
      }
      this[kHeaders] = new Headers(kConstruct);
      this[kHeaders][kHeadersList] = request.headersList;
      this[kHeaders][kGuard] = "request";
      this[kHeaders][kRealm] = this[kRealm];
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (initHasKey) {
        const headersList = this[kHeaders][kHeadersList];
        const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers instanceof HeadersList) {
          for (const [key, val2] of headers) {
            headersList.append(key, val2);
          }
          headersList.cookies = headers.cookies;
        } else {
          fillHeaders(this[kHeaders], headers);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        if (!TransformStream) {
          TransformStream = __require("stream/web").TransformStream;
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (this.bodyUsed || this.body?.locked) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const clonedRequestObject = new Request(kConstruct);
      clonedRequestObject[kState] = clonedRequest;
      clonedRequestObject[kRealm] = this[kRealm];
      clonedRequestObject[kHeaders] = new Headers(kConstruct);
      clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
      clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        util.addAbortListener(this.signal, () => {
          ac.abort(this.signal.reason);
        });
      }
      clonedRequestObject[kSignal] = ac.signal;
      return clonedRequestObject;
    }
  }
  mixinBody(Request);
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V);
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal5) => webidl.converters.AbortSignal(signal5, { strict: false }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  module.exports = { Request, makeRequest };
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  function fetch(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    const relevantRealm = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener3(requestObject.signal, () => {
      locallyAborted = true;
      assert(controller != null);
      controller.abort(requestObject.signal.reason);
      abortFetch(p, request, responseObject, requestObject.signal.reason);
    });
    const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
    const processResponse = (response) => {
      if (locallyAborted) {
        return Promise.resolve();
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return Promise.resolve();
      }
      if (response.type === "error") {
        p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
        return Promise.resolve();
      }
      responseObject = new Response;
      responseObject[kState] = response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = response.headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      p.resolve(responseObject);
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
  }
  function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
      performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
    }
  }
  function abortFetch(p, request, responseObject, error2) {
    if (!error2) {
      error2 = new DOMException2("The operation was aborted.", "AbortError");
    }
    p.reject(error2);
    if (request.body != null && isReadable(request.body?.stream)) {
      request.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream)) {
      response.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher
  }) {
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client?.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept")) {
      const value = "*/*";
      request.headersList.append("accept", value);
    }
    if (!request.headersList.contains("accept-language")) {
      request.headersList.append("accept-language", "*");
    }
    if (request.priority === null) {
    }
    if (subresourceSet.has(request.destination)) {
    }
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request = fetchParams.request;
    let response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
      response = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
    if (requestBadPort(request) === "blocked") {
      response = makeNetworkError("bad port");
    }
    if (request.referrerPolicy === "") {
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    }
    if (request.referrer !== "no-referrer") {
      request.referrer = determineRequestsReferrer(request);
    }
    if (response === null) {
      response = await (async () => {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          }
          request.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response;
    }
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors") {
      }
      if (request.responseTainting === "basic") {
        response = filterResponse(response, "basic");
      } else if (request.responseTainting === "cors") {
        response = filterResponse(response, "cors");
      } else if (request.responseTainting === "opaque") {
        response = filterResponse(response, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request.urlList);
    }
    if (!request.timingAllowFailed) {
      response.timingAllowPassed = true;
    }
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
      response = internalResponse = makeNetworkError();
    }
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const bodyWithType = safelyExtractBody(blobURLEntryObject);
        const body = bodyWithType[0];
        const length = isomorphicEncode(`${body.length}`);
        const type15 = bodyWithType[1] ?? "";
        const response = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type15 }]
          ]
        });
        response.body = body;
        return Promise.resolve(response);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  }
  function fetchFinale(fetchParams, response) {
    if (response.type === "error") {
      response.urlList = [fetchParams.request.urlList[0]];
      response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    }
    const processResponseEndOfBody = () => {
      fetchParams.request.done = true;
      if (fetchParams.processResponseEndOfBody != null) {
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
      }
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => fetchParams.processResponse(response));
    }
    if (response.body == null) {
      processResponseEndOfBody();
    } else {
      const identityTransformAlgorithm = (chunk, controller) => {
        controller.enqueue(chunk);
      };
      const transformStream = new TransformStream({
        start() {
        },
        transform: identityTransformAlgorithm,
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response.body = { stream: response.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
      const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
      if (response.body == null) {
        queueMicrotask(() => processBody(null));
      } else {
        return fullyReadBody(response.body, processBody, processBodyError);
      }
      return Promise.resolve();
    }
  }
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {
    }
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy();
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  function httpRedirectFetch(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization");
      request.headersList.delete("proxy-authorization", true);
      request.headersList.delete("cookie");
      request.headersList.delete("host");
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = makeRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    }
    if (contentLength != null && httpRequest.keepalive) {
    }
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent")) {
      httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
      httpRequest.headersList.append("cache-control", "max-age=0");
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma")) {
        httpRequest.headersList.append("pragma", "no-cache");
      }
      if (!httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "no-cache");
      }
    }
    if (httpRequest.headersList.contains("range")) {
      httpRequest.headersList.append("accept-encoding", "identity");
    }
    if (!httpRequest.headersList.contains("accept-encoding")) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
      }
    }
    httpRequest.headersList.delete("host");
    if (includeCredentials) {
    }
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
    }
    if (response == null) {
      if (httpRequest.mode === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
      }
      if (revalidatingFlag && forwardResponse.status === 304) {
      }
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range")) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {
    }
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err) {
        if (!this.destroyed) {
          this.destroyed = true;
          this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {
    } else {
    }
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    const stream3 = new ReadableStream2({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      }
    }, {
      highWaterMark: 0,
      size() {
        return 1;
      }
    });
    response.body = { stream: stream3 };
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
        if (isErrored(stream3)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream3)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream3)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    async function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject4) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort2) {
          const { connection } = fetchParams.controller;
          if (connection.destroyed) {
            abort2(new DOMException2("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort2);
            this.abort = connection.abort = abort2;
          }
        },
        onHeaders(status, headersList, resume, statusText) {
          if (status < 200) {
            return;
          }
          let codings = [];
          let location = "";
          const headers = new Headers;
          if (Array.isArray(headersList)) {
            for (let n2 = 0;n2 < headersList.length; n2 += 2) {
              const key = headersList[n2 + 0].toString("latin1");
              const val2 = headersList[n2 + 1].toString("latin1");
              if (key.toLowerCase() === "content-encoding") {
                codings = val2.toLowerCase().split(",").map((x) => x.trim());
              } else if (key.toLowerCase() === "location") {
                location = val2;
              }
              headers[kHeadersList].append(key, val2);
            }
          } else {
            const keys = Object.keys(headersList);
            for (const key of keys) {
              const val2 = headersList[key];
              if (key.toLowerCase() === "content-encoding") {
                codings = val2.toLowerCase().split(",").map((x) => x.trim()).reverse();
              } else if (key.toLowerCase() === "location") {
                location = val2;
              }
              headers[kHeadersList].append(key, val2);
            }
          }
          this.body = new Readable4({ read: resume });
          const decoders = [];
          const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            for (const coding of codings) {
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "deflate") {
                decoders.push(zlib.createInflate());
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress());
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length ? pipeline4(this.body, ...decoders, () => {
            }) : this.body.on("error", () => {
            })
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error2) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error2);
          fetchParams.controller.terminate(error2);
          reject4(error2);
        },
        onUpgrade(status, headersList, socket) {
          if (status !== 101) {
            return;
          }
          const headers = new Headers;
          for (let n2 = 0;n2 < headersList.length; n2 += 2) {
            const key = headersList[n2 + 0].toString("latin1");
            const val2 = headersList[n2 + 1].toString("latin1");
            headers[kHeadersList].append(key, val2);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList: headers[kHeadersList],
            socket
          });
          return true;
        }
      }));
    }
  }
  var {
    Response,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = require_response();
  var { Headers } = require_headers();
  var { Request, makeRequest } = require_request2();
  var zlib = __require("zlib");
  var {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = require_util2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var assert = __require("assert");
  var { safelyExtractBody } = require_body();
  var {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet,
    DOMException: DOMException2
  } = require_constants2();
  var { kHeadersList } = require_symbols();
  var EE = __require("events");
  var { Readable: Readable4, pipeline: pipeline4 } = __require("stream");
  var { addAbortListener: addAbortListener3, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
  var { dataURLProcessor, serializeAMimeType } = require_dataURL();
  var { TransformStream } = __require("stream/web");
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("http");
  var GET_OR_HEAD = ["GET", "HEAD"];
  var resolveObjectURL;
  var ReadableStream2 = globalThis.ReadableStream;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
      this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error2) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error2) {
        error2 = new DOMException2("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error2;
      this.connection?.destroy(error2);
      this.emit("terminated", error2);
    }
  }
  module.exports = {
    fetch,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type15, eventInitDict = {}) {
      type15 = webidl.converters.DOMString(type15);
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type15, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  function readOperation(fr, blob, type15, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException2("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream3 = blob.stream();
    const reader = stream3.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result5 = packageData(bytes, type15, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result5;
                fireAProgressEvent("load", fr);
              } catch (error2) {
                fr[kError] = error2;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error2) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error2;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type15, mimeType, encodingName) {
    switch (type15) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder3("latin1");
        for (const chunk of bytes) {
          dataURL += btoa2(decoder.write(chunk));
        }
        dataURL += btoa2(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName) {
          encoding = getEncoding(encodingName);
        }
        if (encoding === "failure" && mimeType) {
          const type16 = parseMIMEType(mimeType);
          if (type16 !== "failure") {
            encoding = getEncoding(type16.parameters.get("charset"));
          }
        }
        if (encoding === "failure") {
          encoding = "UTF-8";
        }
        return decode(bytes, encoding);
      }
      case "ArrayBuffer": {
        const sequence2 = combineByteSequences(bytes);
        return sequence2.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder3("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode(ioQueue, encoding) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a2, b, c3] = ioQueue;
    if (a2 === 239 && b === 187 && c3 === 191) {
      return "UTF-8";
    } else if (a2 === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a2 === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a2, b) => {
      return a2 + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a2, b) => {
      a2.set(b, offset);
      offset += b.byteLength;
      return a2;
    }, new Uint8Array(size));
  }
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3();
  var { ProgressEvent } = require_progressevent();
  var { getEncoding } = require_encoding();
  var { DOMException: DOMException2 } = require_constants2();
  var { serializeAMimeType, parseMIMEType } = require_dataURL();
  var { types } = __require("util");
  var { StringDecoder: StringDecoder3 } = __require("string_decoder");
  var { btoa: btoa2 } = __require("buffer");
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4();
  var {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = undefined) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding !== undefined) {
        encoding = webidl.converters.DOMString(encoding);
      }
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: require_symbols().kConstruct
  };
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function fieldValues(header) {
    assert(header !== null);
    const values8 = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (!value.length) {
        continue;
      } else if (!isValidHeaderName(value)) {
        continue;
      }
      values8.push(value);
    }
    return values8;
  }
  var assert = __require("assert");
  var { URLSerializer } = require_dataURL();
  var { isValidHeaderName } = require_util2();
  module.exports = {
    urlEquals,
    fieldValues
  };
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { urlEquals, fieldValues: getFieldValues } = require_util5();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { kHeadersList } = require_symbols();
  var { webidl } = require_webidl();
  var { Response, cloneResponse } = require_response();
  var { Request } = require_request2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
  var assert = __require("assert");
  var { getGlobalDispatcher } = require_global2();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options3 = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
      request = webidl.converters.RequestInfo(request);
      options3 = webidl.converters.CacheQueryOptions(options3);
      const p = await this.matchAll(request, options3);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options3 = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options3 = webidl.converters.CacheQueryOptions(options3);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options3.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options3);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = new Response(response.body?.source ?? null);
        const body = responseObject[kState].body;
        responseObject[kState] = response;
        responseObject[kState].body = body;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
      request = webidl.converters.RequestInfo(request);
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
      requests = webidl.converters["sequence<RequestInfo>"](requests);
      const responsePromises = [];
      const requestList = [];
      for (const request of requests) {
        if (typeof request === "string") {
          continue;
        }
        const r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
      request = webidl.converters.RequestInfo(request);
      response = webidl.converters.Response(response);
      let innerRequest = null;
      if (request instanceof Request) {
        innerRequest = request[kState];
      } else {
        innerRequest = new Request(request)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream3 = innerResponse.body.stream;
        const reader = stream3.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options3 = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
      request = webidl.converters.RequestInfo(request);
      options3 = webidl.converters.CacheQueryOptions(options3);
      let r = null;
      if (request instanceof Request) {
        r = request[kState];
        if (r.method !== "GET" && !options3.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = new Request(request)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options: options3
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options3 = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options3 = webidl.converters.CacheQueryOptions(options3);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options3.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const promise2 = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options3);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = new Request("https://a");
          requestObject[kState] = request2;
          requestObject[kHeaders][kHeadersList] = request2.headersList;
          requestObject[kHeaders][kGuard] = "immutable";
          requestObject[kRealm] = request2.client;
          requestList.push(requestObject);
        }
        promise2.resolve(Object.freeze(requestList));
      });
      return promise2.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options3, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options3)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options3) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options3?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options3?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { Cache } = require_cache();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
    }
    async match(request, options3 = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
      request = webidl.converters.RequestInfo(request);
      options3 = webidl.converters.MultiCacheQueryOptions(options3);
      if (options3.cacheName != null) {
        if (this.#caches.has(options3.cacheName)) {
          const cacheList = this.#caches.get(options3.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options3);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options3);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
      cacheName = webidl.converters.DOMString(cacheName);
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  function isCTLExcludingHtab(value) {
    if (value.length === 0) {
      return false;
    }
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
        return false;
      }
    }
  }
  function validateCookieName(name) {
    for (const char of name) {
      const code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
        throw new Error("Invalid header value");
      }
    }
  }
  function validateCookiePath(path5) {
    for (const char of path5) {
      const code = char.charCodeAt(0);
      if (code < 33 || char === ";") {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    const days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    const dayName = days[date.getUTCDay()];
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();
    const hour = date.getUTCHours().toString().padStart(2, "0");
    const minute = date.getUTCMinutes().toString().padStart(2, "0");
    const second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  function getHeadersList(headers) {
    if (headers[kHeadersList]) {
      return headers[kHeadersList];
    }
    if (!kHeadersListNode) {
      kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol) => symbol.description === "headers list");
      assert(kHeadersListNode, "Headers cannot be parsed");
    }
    const headersList = headers[kHeadersListNode];
    assert(headersList);
    return headersList;
  }
  var assert = __require("assert");
  var { kHeadersList } = require_symbols();
  var kHeadersListNode;
  module.exports = {
    isCTLExcludingHtab,
    stringify,
    getHeadersList
  };
});

// node_modules/undici/lib/cookies/parse.js
var require_parse3 = __commonJS((exports, module) => {
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
  var { isCTLExcludingHtab } = require_util6();
  var { collectASequenceOfCodePointsFast } = require_dataURL();
  var assert = __require("assert");
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    name = webidl.converters.DOMString(name);
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookies = getHeadersList(headers).cookies;
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
  }
  function setCookie(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("Set-Cookie", stringify(cookie));
    }
  }
  var { parseSetCookie } = require_parse3();
  var { stringify, getHeadersList } = require_util6();
  var { webidl } = require_webidl();
  var { Headers } = require_headers();
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 2 ** 16 - 1;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  module.exports = {
    uid,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer
  };
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { MessagePort } = __require("worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type15, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
      type15 = webidl.converters.DOMString(type15);
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type15, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type15, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
      return new MessageEvent(type15, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }

  class CloseEvent extends Event {
    #eventInit;
    constructor(type15, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
      type15 = webidl.converters.DOMString(type15);
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type15, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type15, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type15, eventInitDict);
      type15 = webidl.converters.DOMString(type15);
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
    const event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type15, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type15 === opcodes.TEXT) {
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type15 === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = new Uint8Array(data).buffer;
      }
    }
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (const char of protocol) {
      const code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response } = ws;
    controller.abort();
    if (response?.socket && !response.socket.destroyed) {
      response.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, ErrorEvent, {
        error: new Error(reason)
      });
    }
  }
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
  var { states, opcodes } = require_constants5();
  var { MessageEvent, ErrorEvent } = require_events();
  module.exports = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  function establishWebSocketConnection(url, protocols, ws, onEstablish, options3) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options3.headers) {
      const headersList = new Headers(options3.headers)[kHeadersList];
      request.headersList = headersList;
    }
    const keyValue = crypto.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue);
    request.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "";
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options3.dispatcher ?? getGlobalDispatcher(),
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        response.socket.on("data", onSocketData);
        response.socket.on("close", onSocketClose);
        response.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response);
      }
    });
    return controller;
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose() {
    const { ws } = this;
    const wasClean = ws[kSentClose] && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result5 = ws[kByteParser].closingInfo;
    if (result5) {
      code = result5.code ?? 1005;
      reason = result5.reason;
    } else if (!ws[kSentClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error2) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error2);
    }
    this.destroy();
  }
  var diagnosticsChannel = __require("diagnostics_channel");
  var { uid, states } = require_constants5();
  var {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = require_symbols5();
  var { fireEvent, failWebsocketConnection } = require_util7();
  var { CloseEvent } = require_events();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers } = require_headers();
  var { getGlobalDispatcher } = require_global2();
  var { kHeadersList } = require_symbols();
  var channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }
  module.exports = {
    establishWebSocketConnection
  };
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants5();
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
      this.maskKey = crypto.randomBytes(4);
    }
    createFrame(opcode) {
      const bodyLength = this.frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0;
      buffer[0] |= 128;
      buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer[offset - 4] = this.maskKey[0];
      buffer[offset - 3] = this.maskKey[1];
      buffer[offset - 2] = this.maskKey[2];
      buffer[offset - 1] = this.maskKey[3];
      buffer[1] = payloadLength;
      if (payloadLength === 126) {
        buffer.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer[2] = buffer[3] = 0;
        buffer.writeUIntBE(bodyLength, 4, 6);
      }
      buffer[1] |= 128;
      for (let i2 = 0;i2 < bodyLength; i2++) {
        buffer[offset + i2] = this.frameData[i2] ^ this.maskKey[i2 % 4];
      }
      return buffer;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable: Writable4 } = __require("stream");
  var diagnosticsChannel = __require("diagnostics_channel");
  var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
  var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
  var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
  var { WebsocketFrameSend } = require_frame();
  var channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

  class ByteParser extends Writable4 {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.run(callback);
    }
    run(callback) {
      while (true) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.fin = (buffer[0] & 128) !== 0;
          this.#info.opcode = buffer[0] & 15;
          this.#info.originalOpcode ??= this.#info.opcode;
          this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
          if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const payloadLength = buffer[1] & 127;
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const body = this.consume(payloadLength);
            this.#info.closeInfo = this.parseCloseBody(false, body);
            if (!this.ws[kSentClose]) {
              const body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
              const closeFrame = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                if (!err) {
                  this.ws[kSentClose] = true;
                }
              });
            }
            this.ws[kReadyState] = states.CLOSING;
            this.ws[kReceivedClose] = true;
            this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            const body = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              const frame = new WebsocketFrameSend(body);
              this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
              if (channels.ping.hasSubscribers) {
                channels.ping.publish({
                  payload: body
                });
              }
            }
            this.#state = parserStates.INFO;
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            const body = this.consume(payloadLength);
            if (channels.pong.hasSubscribers) {
              channels.pong.publish({
                payload: body
              });
            }
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          } else if (this.#byteOffset >= this.#info.payloadLength) {
            const body = this.consume(this.#info.payloadLength);
            this.#fragments.push(body);
            if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              const fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
              this.#info = {};
              this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0) {
          continue;
        } else {
          callback();
          break;
        }
      }
    }
    consume(n2) {
      if (n2 > this.#byteOffset) {
        return null;
      } else if (n2 === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n2) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n2);
      let offset = 0;
      while (offset !== n2) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n2) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n2) {
          buffer.set(next.subarray(0, n2 - offset), offset);
          this.#buffers[0] = next.subarray(n2 - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n2;
      return buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (onlyCode) {
        if (!isValidStatusCode(code)) {
          return null;
        }
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return null;
      }
      try {
        reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { DOMException: DOMException2 } = require_constants2();
  var { URLSerializer } = require_dataURL();
  var { getGlobalOrigin } = require_global();
  var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
  var {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5();
  var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
  var { establishWebSocketConnection } = require_connection();
  var { WebsocketFrameSend } = require_frame();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty, isBlobLike } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { types } = __require("util");
  var experimentalWarned = false;

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    constructor(url, protocols = []) {
      super();
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      }
      const options3 = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url);
      protocols = options3.protocols;
      const baseURL = getGlobalOrigin();
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException2("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options3);
      this[kReadyState] = WebSocket.CONNECTING;
      this[kBinaryType] = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, { clamp: true });
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason);
      }
      if (code !== undefined) {
        if (code !== 1000 && (code < 3000 || code > 4999)) {
          throw new DOMException2("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== undefined) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        }
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {
      } else if (!isEstablished(this)) {
        failWebsocketConnection(this, "Connection was closed before it was established.");
        this[kReadyState] = WebSocket.CLOSING;
      } else if (!isClosing(this)) {
        const frame = new WebsocketFrameSend;
        if (code !== undefined && reason === undefined) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== undefined && reason !== undefined) {
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        const socket = this[kResponse].socket;
        socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
          if (!err) {
            this[kSentClose] = true;
          }
        });
        this[kReadyState] = states.CLOSING;
      } else {
        this[kReadyState] = WebSocket.CLOSING;
      }
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
      data = webidl.converters.WebSocketSendData(data);
      if (this[kReadyState] === WebSocket.CONNECTING) {
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      const socket = this[kResponse].socket;
      if (typeof data === "string") {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        const ab = Buffer.from(data, data.byteOffset, data.byteLength);
        const frame = new WebsocketFrameSend(ab);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        const frame = new WebsocketFrameSend;
        data.arrayBuffer().then((ab) => {
          const value = Buffer.from(ab);
          frame.frameData = value;
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type15) {
      webidl.brandCheck(this, WebSocket);
      if (type15 !== "blob" && type15 !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type15;
      }
    }
    #onConnectionEstablished(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path5 = opts.path;
        if (!opts.path.startsWith("/")) {
          path5 = `/${path5}`;
        }
        url = new URL(util.parseOrigin(url).origin + path5);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  var Client = require_client();
  var Dispatcher = require_dispatcher();
  var errors = require_errors();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var Agent = require_agent();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var mockErrors = require_mock_errors();
  var ProxyAgent = require_proxy_agent();
  var RetryHandler = require_RetryHandler();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_DecoratorHandler();
  var RedirectHandler = require_RedirectHandler();
  var createRedirectInterceptor = require_redirectInterceptor();
  var hasCrypto;
  try {
    __require("crypto");
    hasCrypto = true;
  } catch {
    hasCrypto = false;
  }
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
    let fetchImpl = null;
    exports.fetch = async function fetch(resource) {
      if (!fetchImpl) {
        fetchImpl = require_fetch().fetch;
      }
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        if (typeof err === "object") {
          Error.captureStackTrace(err, this);
        }
        throw err;
      }
    };
    exports.Headers = require_headers().Headers;
    exports.Response = require_response().Response;
    exports.Request = require_request2().Request;
    exports.FormData = require_formdata().FormData;
    exports.File = require_file().File;
    exports.FileReader = require_filereader().FileReader;
    const { setGlobalOrigin, getGlobalOrigin } = require_global();
    exports.setGlobalOrigin = setGlobalOrigin;
    exports.getGlobalOrigin = getGlobalOrigin;
    const { CacheStorage } = require_cachestorage();
    const { kConstruct } = require_symbols4();
    exports.caches = new CacheStorage(kConstruct);
  }
  if (util.nodeMajor >= 16) {
    const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
    exports.deleteCookie = deleteCookie;
    exports.getCookies = getCookies;
    exports.getSetCookies = getSetCookies;
    exports.setCookie = setCookie;
    const { parseMIMEType, serializeAMimeType } = require_dataURL();
    exports.parseMIMEType = parseMIMEType;
    exports.serializeAMimeType = serializeAMimeType;
  }
  if (util.nodeMajor >= 18 && hasCrypto) {
    const { WebSocket } = require_websocket();
    exports.WebSocket = WebSocket;
  }
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS((exports) => {
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var pm = __importStar(require_proxy());
  var tunnel = __importStar(require_tunnel());
  var undici_1 = require_undici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  exports.getProxyUrl = getProxyUrl;
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  var HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  var ExponentialBackoffCeiling = 10;
  var ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message2, statusCode) {
      super(message2);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message2) {
      this.message = message2;
    }
    readBody() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          let output3 = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output3 = Buffer.concat([output3, chunk]);
          });
          this.message.on("end", () => {
            resolve(output3.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  exports.isHttps = isHttps;

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = userAgent;
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream3, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request(verb, requestUrl, stream3, additionalHeaders);
      });
    }
    getJson(requestUrl, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info2 = this._prepareRequest(verb, parsedUrl, headers);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        do {
          response = yield this.requestRaw(info2, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info2, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info2 = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = yield this.requestRaw(info2, data);
            redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    requestRaw(info2, data) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject4) => {
          function callbackForResult(err, res) {
            if (err) {
              reject4(err);
            } else if (!res) {
              reject4(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info2, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info2, data, onResult) {
      if (typeof data === "string") {
        if (!info2.options.headers) {
          info2.options.headers = {};
        }
        info2.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult2(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info2.httpModule.request(info2.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult2(undefined, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 60000, () => {
        if (socket) {
          socket.end();
        }
        handleResult2(new Error(`Request timeout: ${info2.options.path}`));
      });
      req.on("error", function(err) {
        handleResult2(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      const info2 = {};
      info2.parsedUrl = requestUrl;
      const usingSsl = info2.parsedUrl.protocol === "https:";
      info2.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info2.options = {};
      info2.options.host = info2.parsedUrl.hostname;
      info2.options.port = info2.parsedUrl.port ? parseInt(info2.parsedUrl.port) : defaultPort;
      info2.options.path = (info2.parsedUrl.pathname || "") + (info2.parsedUrl.search || "");
      info2.options.method = method;
      info2.options.headers = this._mergeHeaders(headers);
      if (this.userAgent != null) {
        info2.options.headers["user-agent"] = this.userAgent;
      }
      info2.options.agent = this._getAgent(info2.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info2.options);
        }
      }
      return info2;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      }
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
      }
      return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent = this._proxyAgent;
      }
      if (!useProxy) {
        agent = this._agent;
      }
      if (agent) {
        return agent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        }
        agent = tunnelAgent(agentOptions);
        this._proxyAgent = agent;
      }
      if (!agent) {
        const options3 = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options3) : new http.Agent(options3);
        this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError) {
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive) {
        proxyAgent = this._proxyAgentDispatcher;
      }
      if (proxyAgent) {
        return proxyAgent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, undefined, undefined, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options3) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject4) => __awaiter(this, undefined, undefined, function* () {
          const statusCode = res.message.statusCode || 0;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a2 = new Date(value);
              if (!isNaN(a2.valueOf())) {
                return a2;
              }
            }
            return value;
          }
          let obj;
          let contents6;
          try {
            contents6 = yield res.readBody();
            if (contents6 && contents6.length > 0) {
              if (options3 && options3.deserializeDates) {
                obj = JSON.parse(contents6, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents6);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {
          }
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents6 && contents6.length > 0) {
              msg = contents6;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response.result;
            reject4(err);
          } else {
            resolve(response);
          }
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c3, k) => (c3[k.toLowerCase()] = obj[k], c3), {});
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = undefined;

  class BasicCredentialHandler {
    constructor(username, password) {
      this.username = username;
      this.password = password;
    }
    prepareRequest(options3) {
      if (!options3.headers) {
        throw Error("The request has no headers");
      }
      options3.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BasicCredentialHandler = BasicCredentialHandler;

  class BearerCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options3) {
      if (!options3.headers) {
        throw Error("The request has no headers");
      }
      options3.headers["Authorization"] = `Bearer ${this.token}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BearerCredentialHandler = BearerCredentialHandler;

  class PersonalAccessTokenCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options3) {
      if (!options3.headers) {
        throw Error("The request has no headers");
      }
      options3.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OidcClient = undefined;
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var core_1 = require_core();

  class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
      const requestOptions = {
        allowRetries: allowRetry,
        maxRetries: maxRetry
      };
      return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
      const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
      if (!token) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      }
      return token;
    }
    static getIDTokenUrl() {
      const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
      if (!runtimeUrl) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      }
      return runtimeUrl;
    }
    static getCall(id_token_url) {
      var _a;
      return __awaiter(this, undefined, undefined, function* () {
        const httpclient = OidcClient.createHttpClient();
        const res = yield httpclient.getJson(id_token_url).catch((error2) => {
          throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error2.statusCode}\n 
        Error Message: ${error2.message}`);
        });
        const id_token = (_a = res.result) === null || _a === undefined ? undefined : _a.value;
        if (!id_token) {
          throw new Error("Response json body do not have ID Token field");
        }
        return id_token;
      });
    }
    static getIDToken(audience) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          let id_token_url = OidcClient.getIDTokenUrl();
          if (audience) {
            const encodedAudience = encodeURIComponent(audience);
            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
          }
          core_1.debug(`ID token url is ${id_token_url}`);
          const id_token = yield OidcClient.getCall(id_token_url);
          core_1.setSecret(id_token);
          return id_token;
        } catch (error2) {
          throw new Error(`Error message: ${error2.message}`);
        }
      });
    }
  }
  exports.OidcClient = OidcClient;
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = undefined;
  var os_1 = __require("os");
  var fs_1 = __require("fs");
  var { access, appendFile, writeFile } = fs_1.promises;
  exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
  exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";

  class Summary {
    constructor() {
      this._buffer = "";
    }
    filePath() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._filePath) {
          return this._filePath;
        }
        const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
        if (!pathFromEnv) {
          throw new Error(`Unable to find environment variable for \$${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
        }
        try {
          yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
        } catch (_a) {
          throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
        }
        this._filePath = pathFromEnv;
        return this._filePath;
      });
    }
    wrap(tag, content, attrs = {}) {
      const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
      if (!content) {
        return `<${tag}${htmlAttrs}>`;
      }
      return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    write(options3) {
      return __awaiter(this, undefined, undefined, function* () {
        const overwrite = !!(options3 === null || options3 === undefined ? undefined : options3.overwrite);
        const filePath = yield this.filePath();
        const writeFunc = overwrite ? writeFile : appendFile;
        yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
        return this.emptyBuffer();
      });
    }
    clear() {
      return __awaiter(this, undefined, undefined, function* () {
        return this.emptyBuffer().write({ overwrite: true });
      });
    }
    stringify() {
      return this._buffer;
    }
    isEmptyBuffer() {
      return this._buffer.length === 0;
    }
    emptyBuffer() {
      this._buffer = "";
      return this;
    }
    addRaw(text, addEOL = false) {
      this._buffer += text;
      return addEOL ? this.addEOL() : this;
    }
    addEOL() {
      return this.addRaw(os_1.EOL);
    }
    addCodeBlock(code, lang) {
      const attrs = Object.assign({}, lang && { lang });
      const element = this.wrap("pre", this.wrap("code", code), attrs);
      return this.addRaw(element).addEOL();
    }
    addList(items, ordered = false) {
      const tag = ordered ? "ol" : "ul";
      const listItems = items.map((item) => this.wrap("li", item)).join("");
      const element = this.wrap(tag, listItems);
      return this.addRaw(element).addEOL();
    }
    addTable(rows) {
      const tableBody = rows.map((row) => {
        const cells = row.map((cell) => {
          if (typeof cell === "string") {
            return this.wrap("td", cell);
          }
          const { header, data, colspan, rowspan } = cell;
          const tag = header ? "th" : "td";
          const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
          return this.wrap(tag, data, attrs);
        }).join("");
        return this.wrap("tr", cells);
      }).join("");
      const element = this.wrap("table", tableBody);
      return this.addRaw(element).addEOL();
    }
    addDetails(label, content) {
      const element = this.wrap("details", this.wrap("summary", label) + content);
      return this.addRaw(element).addEOL();
    }
    addImage(src, alt, options3) {
      const { width, height } = options3 || {};
      const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
      const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
      return this.addRaw(element).addEOL();
    }
    addHeading(text, level) {
      const tag = `h${level}`;
      const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
      const element = this.wrap(allowedTag, text);
      return this.addRaw(element).addEOL();
    }
    addSeparator() {
      const element = this.wrap("hr", null);
      return this.addRaw(element).addEOL();
    }
    addBreak() {
      const element = this.wrap("br", null);
      return this.addRaw(element).addEOL();
    }
    addQuote(text, cite) {
      const attrs = Object.assign({}, cite && { cite });
      const element = this.wrap("blockquote", text, attrs);
      return this.addRaw(element).addEOL();
    }
    addLink(text, href) {
      const element = this.wrap("a", text, { href });
      return this.addRaw(element).addEOL();
    }
  }
  var _summary = new Summary;
  exports.markdownSummary = _summary;
  exports.summary = _summary;
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS((exports) => {
  function toPosixPath(pth) {
    return pth.replace(/[\\]/g, "/");
  }
  function toWin32Path(pth) {
    return pth.replace(/[/]/g, "\\");
  }
  function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path5.sep);
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = undefined;
  var path5 = __importStar(__require("path"));
  exports.toPosixPath = toPosixPath;
  exports.toWin32Path = toWin32Path;
  exports.toPlatformPath = toPlatformPath;
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports) => {
  function exportVariable(name, val2) {
    const convertedVal = utils_1.toCommandValue(val2);
    process.env[name] = convertedVal;
    const filePath = process.env["GITHUB_ENV"] || "";
    if (filePath) {
      return file_command_1.issueFileCommand("ENV", file_command_1.prepareKeyValueMessage(name, val2));
    }
    command_1.issueCommand("set-env", { name }, convertedVal);
  }
  function setSecret(secret) {
    command_1.issueCommand("add-mask", {}, secret);
  }
  function addPath(inputPath) {
    const filePath = process.env["GITHUB_PATH"] || "";
    if (filePath) {
      file_command_1.issueFileCommand("PATH", inputPath);
    } else {
      command_1.issueCommand("add-path", {}, inputPath);
    }
    process.env["PATH"] = `${inputPath}${path5.delimiter}${process.env["PATH"]}`;
  }
  function getInput(name, options3) {
    const val2 = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options3 && options3.required && !val2) {
      throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options3 && options3.trimWhitespace === false) {
      return val2;
    }
    return val2.trim();
  }
  function getMultilineInput(name, options3) {
    const inputs = getInput(name, options3).split("\n").filter((x) => x !== "");
    if (options3 && options3.trimWhitespace === false) {
      return inputs;
    }
    return inputs.map((input) => input.trim());
  }
  function getBooleanInput(name, options3) {
    const trueValue = ["true", "True", "TRUE"];
    const falseValue = ["false", "False", "FALSE"];
    const val2 = getInput(name, options3);
    if (trueValue.includes(val2))
      return true;
    if (falseValue.includes(val2))
      return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` + `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
  }
  function setOutput(name, value) {
    const filePath = process.env["GITHUB_OUTPUT"] || "";
    if (filePath) {
      return file_command_1.issueFileCommand("OUTPUT", file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand("set-output", { name }, utils_1.toCommandValue(value));
  }
  function setCommandEcho(enabled) {
    command_1.issue("echo", enabled ? "on" : "off");
  }
  function setFailed(message2) {
    process.exitCode = ExitCode.Failure;
    error2(message2);
  }
  function isDebug() {
    return process.env["RUNNER_DEBUG"] === "1";
  }
  function debug(message2) {
    command_1.issueCommand("debug", {}, message2);
  }
  function error2(message2, properties = {}) {
    command_1.issueCommand("error", utils_1.toCommandProperties(properties), message2 instanceof Error ? message2.toString() : message2);
  }
  function warning(message2, properties = {}) {
    command_1.issueCommand("warning", utils_1.toCommandProperties(properties), message2 instanceof Error ? message2.toString() : message2);
  }
  function notice(message2, properties = {}) {
    command_1.issueCommand("notice", utils_1.toCommandProperties(properties), message2 instanceof Error ? message2.toString() : message2);
  }
  function info2(message2) {
    process.stdout.write(message2 + os.EOL);
  }
  function startGroup(name) {
    command_1.issue("group", name);
  }
  function endGroup() {
    command_1.issue("endgroup");
  }
  function group(name, fn) {
    return __awaiter(this, undefined, undefined, function* () {
      startGroup(name);
      let result5;
      try {
        result5 = yield fn();
      } finally {
        endGroup();
      }
      return result5;
    });
  }
  function saveState(name, value) {
    const filePath = process.env["GITHUB_STATE"] || "";
    if (filePath) {
      return file_command_1.issueFileCommand("STATE", file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand("save-state", { name }, utils_1.toCommandValue(value));
  }
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  function getIDToken(aud) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = undefined;
  var command_1 = require_command();
  var file_command_1 = require_file_command();
  var utils_1 = require_utils();
  var os = __importStar(__require("os"));
  var path5 = __importStar(__require("path"));
  var oidc_utils_1 = require_oidc_utils();
  var ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2["Success"] = 0] = "Success";
    ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
  })(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
  exports.exportVariable = exportVariable;
  exports.setSecret = setSecret;
  exports.addPath = addPath;
  exports.getInput = getInput;
  exports.getMultilineInput = getMultilineInput;
  exports.getBooleanInput = getBooleanInput;
  exports.setOutput = setOutput;
  exports.setCommandEcho = setCommandEcho;
  exports.setFailed = setFailed;
  exports.isDebug = isDebug;
  exports.debug = debug;
  exports.error = error2;
  exports.warning = warning;
  exports.notice = notice;
  exports.info = info2;
  exports.startGroup = startGroup;
  exports.endGroup = endGroup;
  exports.group = group;
  exports.saveState = saveState;
  exports.getState = getState;
  exports.getIDToken = getIDToken;
  var summary_1 = require_summary();
  Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
    return summary_1.summary;
  } });
  var summary_2 = require_summary();
  Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
    return summary_2.markdownSummary;
  } });
  var path_utils_1 = require_path_utils();
  Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
    return path_utils_1.toPosixPath;
  } });
  Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
    return path_utils_1.toWin32Path;
  } });
  Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
    return path_utils_1.toPlatformPath;
  } });
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports) => {
  function exists(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      try {
        yield exports.stat(fsPath);
      } catch (err) {
        if (err.code === "ENOENT") {
          return false;
        }
        throw err;
      }
      return true;
    });
  }
  function isDirectory(fsPath, useStat = false) {
    return __awaiter(this, undefined, undefined, function* () {
      const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
      return stats.isDirectory();
    });
  }
  function isRooted(p) {
    p = normalizeSeparators(p);
    if (!p) {
      throw new Error('isRooted() parameter "p" cannot be empty');
    }
    if (exports.IS_WINDOWS) {
      return p.startsWith("\\") || /^[A-Z]:/i.test(p);
    }
    return p.startsWith("/");
  }
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, undefined, undefined, function* () {
      let stats = undefined;
      try {
        stats = yield exports.stat(filePath);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
      }
      if (stats && stats.isFile()) {
        if (exports.IS_WINDOWS) {
          const upperExt = path5.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
            return filePath;
          }
        } else {
          if (isUnixExecutable(stats)) {
            return filePath;
          }
        }
      }
      const originalFilePath = filePath;
      for (const extension of extensions) {
        filePath = originalFilePath + extension;
        stats = undefined;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            try {
              const directory = path5.dirname(filePath);
              const upperName = path5.basename(filePath).toUpperCase();
              for (const actualName of yield exports.readdir(directory)) {
                if (upperName === actualName.toUpperCase()) {
                  filePath = path5.join(directory, actualName);
                  break;
                }
              }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
      }
      return "";
    });
  }
  function normalizeSeparators(p) {
    p = p || "";
    if (exports.IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      return p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
  }
  function getCmdPath() {
    var _a2;
    return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== undefined ? _a2 : `cmd.exe`;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = undefined;
  var fs = __importStar(__require("fs"));
  var path5 = __importStar(__require("path"));
  _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
  exports.IS_WINDOWS = process.platform === "win32";
  exports.UV_FS_O_EXLOCK = 268435456;
  exports.READONLY = fs.constants.O_RDONLY;
  exports.exists = exists;
  exports.isDirectory = isDirectory;
  exports.isRooted = isRooted;
  exports.tryGetExecutablePath = tryGetExecutablePath;
  exports.getCmdPath = getCmdPath;
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports) => {
  function cp(source, dest, options3 = {}) {
    return __awaiter(this, undefined, undefined, function* () {
      const { force, recursive, copySourceDirectory } = readCopyOptions(options3);
      const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path5.join(dest, path5.basename(source)) : dest;
      if (!(yield ioUtil.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path5.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  function mv(source, dest, options3 = {}) {
    return __awaiter(this, undefined, undefined, function* () {
      if (yield ioUtil.exists(dest)) {
        let destExists = true;
        if (yield ioUtil.isDirectory(dest)) {
          dest = path5.join(dest, path5.basename(source));
          destExists = yield ioUtil.exists(dest);
        }
        if (destExists) {
          if (options3.force == null || options3.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path5.dirname(dest));
      yield ioUtil.rename(source, dest);
    });
  }
  function rmRF(inputPath) {
    return __awaiter(this, undefined, undefined, function* () {
      if (ioUtil.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath)) {
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        }
      }
      try {
        yield ioUtil.rm(inputPath, {
          force: true,
          maxRetries: 3,
          recursive: true,
          retryDelay: 300
        });
      } catch (err) {
        throw new Error(`File was unable to be removed ${err}`);
      }
    });
  }
  function mkdirP(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      assert_1.ok(fsPath, "a path argument must be provided");
      yield ioUtil.mkdir(fsPath, { recursive: true });
    });
  }
  function which(tool, check) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result5 = yield which(tool, false);
        if (!result5) {
          if (ioUtil.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
        return result5;
      }
      const matches = yield findInPath(tool);
      if (matches && matches.length > 0) {
        return matches[0];
      }
      return "";
    });
  }
  function findInPath(tool) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      const extensions = [];
      if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
        for (const extension of process.env["PATHEXT"].split(path5.delimiter)) {
          if (extension) {
            extensions.push(extension);
          }
        }
      }
      if (ioUtil.isRooted(tool)) {
        const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
        if (filePath) {
          return [filePath];
        }
        return [];
      }
      if (tool.includes(path5.sep)) {
        return [];
      }
      const directories = [];
      if (process.env.PATH) {
        for (const p of process.env.PATH.split(path5.delimiter)) {
          if (p) {
            directories.push(p);
          }
        }
      }
      const matches = [];
      for (const directory of directories) {
        const filePath = yield ioUtil.tryGetExecutablePath(path5.join(directory, tool), extensions);
        if (filePath) {
          matches.push(filePath);
        }
      }
      return matches;
    });
  }
  function readCopyOptions(options3) {
    const force = options3.force == null ? true : options3.force;
    const recursive = Boolean(options3.recursive);
    const copySourceDirectory = options3.copySourceDirectory == null ? true : Boolean(options3.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile);
          yield ioUtil.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil.chmod(destFile, "0666");
            yield ioUtil.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil.exists(destFile)) || force) {
        yield ioUtil.copyFile(srcFile, destFile);
      }
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = undefined;
  var assert_1 = __require("assert");
  var path5 = __importStar(__require("path"));
  var ioUtil = __importStar(require_io_util());
  exports.cp = cp;
  exports.mv = mv;
  exports.rmRF = rmRF;
  exports.mkdirP = mkdirP;
  exports.which = which;
  exports.findInPath = findInPath;
});

// node_modules/@actions/tool-cache/node_modules/semver/semver.js
var require_semver = __commonJS((exports, module) => {
  function tok(n2) {
    t[n2] = R++;
  }
  function makeSafeRe(value) {
    for (var i3 = 0;i3 < safeRegexReplacements.length; i3++) {
      var token = safeRegexReplacements[i3][0];
      var max = safeRegexReplacements[i3][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  function parse(version, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options3.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options3);
    } catch (er) {
      return null;
    }
  }
  function valid(version, options3) {
    var v = parse(version, options3);
    return v ? v.version : null;
  }
  function clean(version, options3) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options3);
    return s ? s.version : null;
  }
  function SemVer(version, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options3.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options3);
    }
    debug("SemVer", version, options3);
    this.options = options3;
    this.loose = !!options3.loose;
    var m = version.trim().match(options3.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  function compareIdentifiers(a2, b) {
    var anum = numeric.test(a2);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a2 = +a2;
      b = +b;
    }
    return a2 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b ? -1 : 1;
  }
  function rcompareIdentifiers(a2, b) {
    return compareIdentifiers(b, a2);
  }
  function major(a2, loose) {
    return new SemVer(a2, loose).major;
  }
  function minor(a2, loose) {
    return new SemVer(a2, loose).minor;
  }
  function patch(a2, loose) {
    return new SemVer(a2, loose).patch;
  }
  function compare(a2, b, loose) {
    return new SemVer(a2, loose).compare(new SemVer(b, loose));
  }
  function compareLoose(a2, b) {
    return compare(a2, b, true);
  }
  function compareBuild(a2, b, loose) {
    var versionA = new SemVer(a2, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  function rcompare(a2, b, loose) {
    return compare(b, a2, loose);
  }
  function sort(list, loose) {
    return list.sort(function(a2, b) {
      return exports.compareBuild(a2, b, loose);
    });
  }
  function rsort(list, loose) {
    return list.sort(function(a2, b) {
      return exports.compareBuild(b, a2, loose);
    });
  }
  function gt(a2, b, loose) {
    return compare(a2, b, loose) > 0;
  }
  function lt(a2, b, loose) {
    return compare(a2, b, loose) < 0;
  }
  function eq(a2, b, loose) {
    return compare(a2, b, loose) === 0;
  }
  function neq(a2, b, loose) {
    return compare(a2, b, loose) !== 0;
  }
  function gte(a2, b, loose) {
    return compare(a2, b, loose) >= 0;
  }
  function lte(a2, b, loose) {
    return compare(a2, b, loose) <= 0;
  }
  function cmp(a2, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b === "object")
          b = b.version;
        return a2 === b;
      case "!==":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b === "object")
          b = b.version;
        return a2 !== b;
      case "":
      case "=":
      case "==":
        return eq(a2, b, loose);
      case "!=":
        return neq(a2, b, loose);
      case ">":
        return gt(a2, b, loose);
      case ">=":
        return gte(a2, b, loose);
      case "<":
        return lt(a2, b, loose);
      case "<=":
        return lte(a2, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  function Comparator(comp, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options3.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options3);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options3);
    this.options = options3;
    this.loose = !!options3.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  function Range(range, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options3.loose && range.includePrerelease === !!options3.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options3);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options3);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options3);
    }
    this.options = options3;
    this.loose = !!options3.loose;
    this.includePrerelease = !!options3.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c3) {
      return c3.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  }
  function isSatisfiable(comparators, options3) {
    var result5 = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result5 && remainingComparators.length) {
      result5 = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options3);
      });
      testComparator = remainingComparators.pop();
    }
    return result5;
  }
  function toComparators(range, options3) {
    return new Range(range, options3).set.map(function(comp) {
      return comp.map(function(c3) {
        return c3.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options3) {
    debug("comp", comp, options3);
    comp = replaceCarets(comp, options3);
    debug("caret", comp);
    comp = replaceTildes(comp, options3);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options3);
    debug("xrange", comp);
    comp = replaceStars(comp, options3);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options3) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options3);
    }).join(" ");
  }
  function replaceTilde(comp, options3) {
    var r = options3.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options3) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options3);
    }).join(" ");
  }
  function replaceCaret(comp, options3) {
    debug("caret", comp, options3);
    var r = options3.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options3) {
    debug("replaceXRanges", comp, options3);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options3);
    }).join(" ");
  }
  function replaceXRange(comp, options3) {
    comp = comp.trim();
    var r = options3.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options3.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options3) {
    debug("replaceStars", comp, options3);
    return comp.trim().replace(safeRe[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  function testSet(set, version, options3) {
    for (var i3 = 0;i3 < set.length; i3++) {
      if (!set[i3].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options3.includePrerelease) {
      for (i3 = 0;i3 < set.length; i3++) {
        debug(set[i3].semver);
        if (set[i3].semver === ANY) {
          continue;
        }
        if (set[i3].semver.prerelease.length > 0) {
          var allowed = set[i3].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  function satisfies(version, range, options3) {
    try {
      range = new Range(range, options3);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  function maxSatisfying(versions, range, options3) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options3);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options3);
        }
      }
    });
    return max;
  }
  function minSatisfying(versions, range, options3) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options3);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options3);
        }
      }
    });
    return min;
  }
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  function validRange(range, options3) {
    try {
      return new Range(range, options3).range || "*";
    } catch (er) {
      return null;
    }
  }
  function ltr(version, range, options3) {
    return outside(version, range, "<", options3);
  }
  function gtr(version, range, options3) {
    return outside(version, range, ">", options3);
  }
  function outside(version, range, hilo, options3) {
    version = new SemVer(version, options3);
    range = new Range(range, options3);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options3)) {
      return false;
    }
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options3)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options3)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  function prerelease(version, options3) {
    var parsed = parse(version, options3);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  function intersects(r1, r2, options3) {
    r1 = new Range(r1, options3);
    r2 = new Range(r2, options3);
    return r1.intersects(r2);
  }
  function coerce(version, options3) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options3 = options3 || {};
    var match = null;
    if (!options3.rtl) {
      match = version.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options3);
  }
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])" + "(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAIN] + ")" + "\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i2 = 0;i2 < R; i2++) {
    debug(i2, src[i2]);
    if (!re[i2]) {
      re[i2] = new RegExp(src[i2]);
      safeRe[i2] = new RegExp(makeSafeRe(src[i2]));
    }
  }
  var i2;
  exports.parse = parse;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i3 = 0;
    do {
      var a2 = this.prerelease[i3];
      var b = other.prerelease[i3];
      debug("prerelease compare", i3, a2, b);
      if (a2 === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b) {
        continue;
      } else {
        return compareIdentifiers(a2, b);
      }
    } while (++i3);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i3 = 0;
    do {
      var a2 = this.build[i3];
      var b = other.build[i3];
      debug("prerelease compare", i3, a2, b);
      if (a2 === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b) {
        continue;
      } else {
        return compareIdentifiers(a2, b);
      }
    } while (++i3);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i3 = this.prerelease.length;
          while (--i3 >= 0) {
            if (typeof this.prerelease[i3] === "number") {
              this.prerelease[i3]++;
              i3 = -2;
            }
          }
          if (i3 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options3) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options3);
      return satisfies(this.value, rangeTmp, options3);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options3);
      return satisfies(comp.semver, rangeTmp, options3);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options3) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options3) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options3) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options3) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options3) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options3);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i3 = 0;i3 < this.set.length; i3++) {
      if (testSet(this.set[i3], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce;
});

// node_modules/@actions/tool-cache/lib/manifest.js
var require_manifest = __commonJS((exports, module) => {
  function _findMatch(versionSpec, stable, candidates, archFilter) {
    return __awaiter(this, undefined, undefined, function* () {
      const platFilter = os.platform();
      let result5;
      let match;
      let file;
      for (const candidate of candidates) {
        const version = candidate.version;
        core_1.debug(`check ${version} satisfies ${versionSpec}`);
        if (semver.satisfies(version, versionSpec) && (!stable || candidate.stable === stable)) {
          file = candidate.files.find((item) => {
            core_1.debug(`${item.arch}===${archFilter} && ${item.platform}===${platFilter}`);
            let chk = item.arch === archFilter && item.platform === platFilter;
            if (chk && item.platform_version) {
              const osVersion = module.exports._getOsVersion();
              if (osVersion === item.platform_version) {
                chk = true;
              } else {
                chk = semver.satisfies(osVersion, item.platform_version);
              }
            }
            return chk;
          });
          if (file) {
            core_1.debug(`matched ${candidate.version}`);
            match = candidate;
            break;
          }
        }
      }
      if (match && file) {
        result5 = Object.assign({}, match);
        result5.files = [file];
      }
      return result5;
    });
  }
  function _getOsVersion() {
    const plat = os.platform();
    let version = "";
    if (plat === "darwin") {
      version = cp.execSync("sw_vers -productVersion").toString();
    } else if (plat === "linux") {
      const lsbContents = module.exports._readLinuxVersionFile();
      if (lsbContents) {
        const lines = lsbContents.split("\n");
        for (const line of lines) {
          const parts = line.split("=");
          if (parts.length === 2 && (parts[0].trim() === "VERSION_ID" || parts[0].trim() === "DISTRIB_RELEASE")) {
            version = parts[1].trim().replace(/^"/, "").replace(/"$/, "");
            break;
          }
        }
      }
    }
    return version;
  }
  function _readLinuxVersionFile() {
    const lsbReleaseFile = "/etc/lsb-release";
    const osReleaseFile = "/etc/os-release";
    let contents6 = "";
    if (fs.existsSync(lsbReleaseFile)) {
      contents6 = fs.readFileSync(lsbReleaseFile).toString();
    } else if (fs.existsSync(osReleaseFile)) {
      contents6 = fs.readFileSync(osReleaseFile).toString();
    }
    return contents6;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._readLinuxVersionFile = exports._getOsVersion = exports._findMatch = undefined;
  var semver = __importStar(require_semver());
  var core_1 = require_core();
  var os = __require("os");
  var cp = __require("child_process");
  var fs = __require("fs");
  exports._findMatch = _findMatch;
  exports._getOsVersion = _getOsVersion;
  exports._readLinuxVersionFile = _readLinuxVersionFile;
});

// node_modules/uuid/lib/rng.js
var require_rng2 = __commonJS((exports, module) => {
  var crypto = __require("crypto");
  module.exports = function nodeRNG() {
    return crypto.randomBytes(16);
  };
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports, module) => {
  function bytesToUuid(buf, offset) {
    var i3 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i3++]],
      bth[buf[i3++]],
      bth[buf[i3++]],
      bth[buf[i3++]],
      "-",
      bth[buf[i3++]],
      bth[buf[i3++]],
      "-",
      bth[buf[i3++]],
      bth[buf[i3++]],
      "-",
      bth[buf[i3++]],
      bth[buf[i3++]],
      "-",
      bth[buf[i3++]],
      bth[buf[i3++]],
      bth[buf[i3++]],
      bth[buf[i3++]],
      bth[buf[i3++]],
      bth[buf[i3++]]
    ].join("");
  }
  var byteToHex = [];
  for (i2 = 0;i2 < 256; ++i2) {
    byteToHex[i2] = (i2 + 256).toString(16).substr(1);
  }
  var i2;
  module.exports = bytesToUuid;
});

// node_modules/uuid/v4.js
var require_v42 = __commonJS((exports, module) => {
  function v4(options3, buf, offset) {
    var i2 = buf && offset || 0;
    if (typeof options3 == "string") {
      buf = options3 === "binary" ? new Array(16) : null;
      options3 = null;
    }
    options3 = options3 || {};
    var rnds = options3.random || (options3.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0;ii < 16; ++ii) {
        buf[i2 + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  var rng = require_rng2();
  var bytesToUuid = require_bytesToUuid();
  module.exports = v4;
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports) => {
  function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = "";
    function append(c3) {
      if (escaped && c3 !== '"') {
        arg += "\\";
      }
      arg += c3;
      escaped = false;
    }
    for (let i2 = 0;i2 < argString.length; i2++) {
      const c3 = argString.charAt(i2);
      if (c3 === '"') {
        if (!escaped) {
          inQuotes = !inQuotes;
        } else {
          append(c3);
        }
        continue;
      }
      if (c3 === "\\" && escaped) {
        append(c3);
        continue;
      }
      if (c3 === "\\" && inQuotes) {
        escaped = true;
        continue;
      }
      if (c3 === " " && !inQuotes) {
        if (arg.length > 0) {
          args.push(arg);
          arg = "";
        }
        continue;
      }
      append(c3);
    }
    if (arg.length > 0) {
      args.push(arg.trim());
    }
    return args;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argStringToArray = exports.ToolRunner = undefined;
  var os = __importStar(__require("os"));
  var events = __importStar(__require("events"));
  var child = __importStar(__require("child_process"));
  var path5 = __importStar(__require("path"));
  var io = __importStar(require_io());
  var ioUtil = __importStar(require_io_util());
  var timers_1 = __require("timers");
  var IS_WINDOWS = process.platform === "win32";

  class ToolRunner extends events.EventEmitter {
    constructor(toolPath, args, options3) {
      super();
      if (!toolPath) {
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      }
      this.toolPath = toolPath;
      this.args = args || [];
      this.options = options3 || {};
    }
    _debug(message2) {
      if (this.options.listeners && this.options.listeners.debug) {
        this.options.listeners.debug(message2);
      }
    }
    _getCommandString(options3, noPrefix) {
      const toolPath = this._getSpawnFileName();
      const args = this._getSpawnArgs(options3);
      let cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (const a2 of args) {
            cmd += ` ${a2}`;
          }
        } else if (options3.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (const a2 of args) {
            cmd += ` ${a2}`;
          }
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (const a2 of args) {
            cmd += ` ${this._windowsQuoteCmdArg(a2)}`;
          }
        }
      } else {
        cmd += toolPath;
        for (const a2 of args) {
          cmd += ` ${a2}`;
        }
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString();
        let n2 = s.indexOf(os.EOL);
        while (n2 > -1) {
          const line = s.substring(0, n2);
          onLine(line);
          s = s.substring(n2 + os.EOL.length);
          n2 = s.indexOf(os.EOL);
        }
        return s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
        return "";
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          return process.env["COMSPEC"] || "cmd.exe";
        }
      }
      return this.toolPath;
    }
    _getSpawnArgs(options3) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (const a2 of this.args) {
            argline += " ";
            argline += options3.windowsVerbatimArguments ? a2 : this._windowsQuoteCmdArg(a2);
          }
          argline += '"';
          return [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      const upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile()) {
        return this._uvQuoteCmdArg(arg);
      }
      if (!arg) {
        return '""';
      }
      const cmdSpecialChars = [
        " ",
        "\t",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let needsQuotes = false;
      for (const char of arg) {
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = true;
          break;
        }
      }
      if (!needsQuotes) {
        return arg;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i2 = arg.length;i2 > 0; i2--) {
        reverse += arg[i2 - 1];
        if (quoteHit && arg[i2 - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i2 - 1] === '"') {
          quoteHit = true;
          reverse += '"';
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg) {
        return '""';
      }
      if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"')) {
        return arg;
      }
      if (!arg.includes('"') && !arg.includes("\\")) {
        return `"${arg}"`;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i2 = arg.length;i2 > 0; i2--) {
        reverse += arg[i2 - 1];
        if (quoteHit && arg[i2 - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i2 - 1] === '"') {
          quoteHit = true;
          reverse += "\\";
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options3) {
      options3 = options3 || {};
      const result5 = {
        cwd: options3.cwd || process.cwd(),
        env: options3.env || process.env,
        silent: options3.silent || false,
        windowsVerbatimArguments: options3.windowsVerbatimArguments || false,
        failOnStdErr: options3.failOnStdErr || false,
        ignoreReturnCode: options3.ignoreReturnCode || false,
        delay: options3.delay || 1e4
      };
      result5.outStream = options3.outStream || process.stdout;
      result5.errStream = options3.errStream || process.stderr;
      return result5;
    }
    _getSpawnOptions(options3, toolPath) {
      options3 = options3 || {};
      const result5 = {};
      result5.cwd = options3.cwd;
      result5.env = options3.env;
      result5["windowsVerbatimArguments"] = options3.windowsVerbatimArguments || this._isCmdFile();
      if (options3.windowsVerbatimArguments) {
        result5.argv0 = `"${toolPath}"`;
      }
      return result5;
    }
    exec() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
          this.toolPath = path5.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        }
        this.toolPath = yield io.which(this.toolPath, true);
        return new Promise((resolve, reject4) => __awaiter(this, undefined, undefined, function* () {
          this._debug(`exec tool: ${this.toolPath}`);
          this._debug("arguments:");
          for (const arg of this.args) {
            this._debug(`   ${arg}`);
          }
          const optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream) {
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          }
          const state = new ExecState(optionsNonNull, this.toolPath);
          state.on("debug", (message2) => {
            this._debug(message2);
          });
          if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
            return reject4(new Error(`The cwd: ${this.options.cwd} does not exist!`));
          }
          const fileName = this._getSpawnFileName();
          const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
          let stdbuffer = "";
          if (cp.stdout) {
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout) {
                this.options.listeners.stdout(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(data);
              }
              stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline) {
                  this.options.listeners.stdline(line);
                }
              });
            });
          }
          let errbuffer = "";
          if (cp.stderr) {
            cp.stderr.on("data", (data) => {
              state.processStderr = true;
              if (this.options.listeners && this.options.listeners.stderr) {
                this.options.listeners.stderr(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                s.write(data);
              }
              errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline) {
                  this.options.listeners.errline(line);
                }
              });
            });
          }
          cp.on("error", (err) => {
            state.processError = err.message;
            state.processExited = true;
            state.processClosed = true;
            state.CheckComplete();
          });
          cp.on("exit", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          cp.on("close", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            state.processClosed = true;
            this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          state.on("done", (error2, exitCode) => {
            if (stdbuffer.length > 0) {
              this.emit("stdline", stdbuffer);
            }
            if (errbuffer.length > 0) {
              this.emit("errline", errbuffer);
            }
            cp.removeAllListeners();
            if (error2) {
              reject4(error2);
            } else {
              resolve(exitCode);
            }
          });
          if (this.options.input) {
            if (!cp.stdin) {
              throw new Error("child process missing stdin");
            }
            cp.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  exports.ToolRunner = ToolRunner;
  exports.argStringToArray = argStringToArray;

  class ExecState extends events.EventEmitter {
    constructor(options3, toolPath) {
      super();
      this.processClosed = false;
      this.processError = "";
      this.processExitCode = 0;
      this.processExited = false;
      this.processStderr = false;
      this.delay = 1e4;
      this.done = false;
      this.timeout = null;
      if (!toolPath) {
        throw new Error("toolPath must not be empty");
      }
      this.options = options3;
      this.toolPath = toolPath;
      if (options3.delay) {
        this.delay = options3.delay;
      }
    }
    CheckComplete() {
      if (this.done) {
        return;
      }
      if (this.processClosed) {
        this._setResult();
      } else if (this.processExited) {
        this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
      }
    }
    _debug(message2) {
      this.emit("debug", message2);
    }
    _setResult() {
      let error2;
      if (this.processExited) {
        if (this.processError) {
          error2 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
          error2 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        } else if (this.processStderr && this.options.failOnStdErr) {
          error2 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
        }
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.done = true;
      this.emit("done", error2, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (state.done) {
        return;
      }
      if (!state.processClosed && state.processExited) {
        const message2 = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state._debug(message2);
      }
      state._setResult();
    }
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports) => {
  function exec(commandLine, args, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      const commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0) {
        throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
      }
      const toolPath = commandArgs[0];
      args = commandArgs.slice(1).concat(args || []);
      const runner = new tr.ToolRunner(toolPath, args, options3);
      return runner.exec();
    });
  }
  function getExecOutput(commandLine, args, options3) {
    var _a, _b;
    return __awaiter(this, undefined, undefined, function* () {
      let stdout = "";
      let stderr = "";
      const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
      const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
      const originalStdoutListener = (_a = options3 === null || options3 === undefined ? undefined : options3.listeners) === null || _a === undefined ? undefined : _a.stdout;
      const originalStdErrListener = (_b = options3 === null || options3 === undefined ? undefined : options3.listeners) === null || _b === undefined ? undefined : _b.stderr;
      const stdErrListener = (data) => {
        stderr += stderrDecoder.write(data);
        if (originalStdErrListener) {
          originalStdErrListener(data);
        }
      };
      const stdOutListener = (data) => {
        stdout += stdoutDecoder.write(data);
        if (originalStdoutListener) {
          originalStdoutListener(data);
        }
      };
      const listeners = Object.assign(Object.assign({}, options3 === null || options3 === undefined ? undefined : options3.listeners), { stdout: stdOutListener, stderr: stdErrListener });
      const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options3), { listeners }));
      stdout += stdoutDecoder.end();
      stderr += stderrDecoder.end();
      return {
        exitCode,
        stdout,
        stderr
      };
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getExecOutput = exports.exec = undefined;
  var string_decoder_1 = __require("string_decoder");
  var tr = __importStar(require_toolrunner());
  exports.exec = exec;
  exports.getExecOutput = getExecOutput;
});

// node_modules/@actions/tool-cache/lib/retry-helper.js
var require_retry_helper = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RetryHelper = undefined;
  var core2 = __importStar(require_core());

  class RetryHelper {
    constructor(maxAttempts, minSeconds, maxSeconds) {
      if (maxAttempts < 1) {
        throw new Error("max attempts should be greater than or equal to 1");
      }
      this.maxAttempts = maxAttempts;
      this.minSeconds = Math.floor(minSeconds);
      this.maxSeconds = Math.floor(maxSeconds);
      if (this.minSeconds > this.maxSeconds) {
        throw new Error("min seconds should be less than or equal to max seconds");
      }
    }
    execute(action, isRetryable) {
      return __awaiter(this, undefined, undefined, function* () {
        let attempt = 1;
        while (attempt < this.maxAttempts) {
          try {
            return yield action();
          } catch (err) {
            if (isRetryable && !isRetryable(err)) {
              throw err;
            }
            core2.info(err.message);
          }
          const seconds = this.getSleepAmount();
          core2.info(`Waiting ${seconds} seconds before trying again`);
          yield this.sleep(seconds);
          attempt++;
        }
        return yield action();
      });
    }
    getSleepAmount() {
      return Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) + this.minSeconds;
    }
    sleep(seconds) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
      });
    }
  }
  exports.RetryHelper = RetryHelper;
});

// node_modules/@actions/tool-cache/lib/tool-cache.js
var require_tool_cache = __commonJS((exports) => {
  function downloadTool(url, dest, auth, headers) {
    return __awaiter(this, undefined, undefined, function* () {
      dest = dest || path5.join(_getTempDirectory(), v4_1.default());
      yield io.mkdirP(path5.dirname(dest));
      core2.debug(`Downloading ${url}`);
      core2.debug(`Destination ${dest}`);
      const maxAttempts = 3;
      const minSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS", 10);
      const maxSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS", 20);
      const retryHelper = new retry_helper_1.RetryHelper(maxAttempts, minSeconds, maxSeconds);
      return yield retryHelper.execute(() => __awaiter(this, undefined, undefined, function* () {
        return yield downloadToolAttempt(url, dest || "", auth, headers);
      }), (err) => {
        if (err instanceof HTTPError && err.httpStatusCode) {
          if (err.httpStatusCode < 500 && err.httpStatusCode !== 408 && err.httpStatusCode !== 429) {
            return false;
          }
        }
        return true;
      });
    });
  }
  function downloadToolAttempt(url, dest, auth, headers) {
    return __awaiter(this, undefined, undefined, function* () {
      if (fs.existsSync(dest)) {
        throw new Error(`Destination file path ${dest} already exists`);
      }
      const http = new httpm.HttpClient(userAgent, [], {
        allowRetries: false
      });
      if (auth) {
        core2.debug("set auth");
        if (headers === undefined) {
          headers = {};
        }
        headers.authorization = auth;
      }
      const response = yield http.get(url, headers);
      if (response.message.statusCode !== 200) {
        const err = new HTTPError(response.message.statusCode);
        core2.debug(`Failed to download from "${url}". Code(${response.message.statusCode}) Message(${response.message.statusMessage})`);
        throw err;
      }
      const pipeline4 = util.promisify(stream3.pipeline);
      const responseMessageFactory = _getGlobal("TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY", () => response.message);
      const readStream = responseMessageFactory();
      let succeeded = false;
      try {
        yield pipeline4(readStream, fs.createWriteStream(dest));
        core2.debug("download complete");
        succeeded = true;
        return dest;
      } finally {
        if (!succeeded) {
          core2.debug("download failed");
          try {
            yield io.rmRF(dest);
          } catch (err) {
            core2.debug(`Failed to delete '${dest}'. ${err.message}`);
          }
        }
      }
    });
  }
  function extract7z(file, dest, _7zPath) {
    return __awaiter(this, undefined, undefined, function* () {
      assert_1.ok(IS_WINDOWS, "extract7z() not supported on current OS");
      assert_1.ok(file, 'parameter "file" is required');
      dest = yield _createExtractFolder(dest);
      const originalCwd = process.cwd();
      process.chdir(dest);
      if (_7zPath) {
        try {
          const logLevel = core2.isDebug() ? "-bb1" : "-bb0";
          const args = [
            "x",
            logLevel,
            "-bd",
            "-sccUTF-8",
            file
          ];
          const options3 = {
            silent: true
          };
          yield exec_1.exec(`"${_7zPath}"`, args, options3);
        } finally {
          process.chdir(originalCwd);
        }
      } else {
        const escapedScript = path5.join(__dirname, "..", "scripts", "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const escapedTarget = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const command4 = `& '${escapedScript}' -Source '${escapedFile}' -Target '${escapedTarget}'`;
        const args = [
          "-NoLogo",
          "-Sta",
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Unrestricted",
          "-Command",
          command4
        ];
        const options3 = {
          silent: true
        };
        try {
          const powershellPath = yield io.which("powershell", true);
          yield exec_1.exec(`"${powershellPath}"`, args, options3);
        } finally {
          process.chdir(originalCwd);
        }
      }
      return dest;
    });
  }
  function extractTar(file, dest, flags = "xz") {
    return __awaiter(this, undefined, undefined, function* () {
      if (!file) {
        throw new Error("parameter 'file' is required");
      }
      dest = yield _createExtractFolder(dest);
      core2.debug("Checking tar --version");
      let versionOutput = "";
      yield exec_1.exec("tar --version", [], {
        ignoreReturnCode: true,
        silent: true,
        listeners: {
          stdout: (data) => versionOutput += data.toString(),
          stderr: (data) => versionOutput += data.toString()
        }
      });
      core2.debug(versionOutput.trim());
      const isGnuTar = versionOutput.toUpperCase().includes("GNU TAR");
      let args;
      if (flags instanceof Array) {
        args = flags;
      } else {
        args = [flags];
      }
      if (core2.isDebug() && !flags.includes("v")) {
        args.push("-v");
      }
      let destArg = dest;
      let fileArg = file;
      if (IS_WINDOWS && isGnuTar) {
        args.push("--force-local");
        destArg = dest.replace(/\\/g, "/");
        fileArg = file.replace(/\\/g, "/");
      }
      if (isGnuTar) {
        args.push("--warning=no-unknown-keyword");
        args.push("--overwrite");
      }
      args.push("-C", destArg, "-f", fileArg);
      yield exec_1.exec(`tar`, args);
      return dest;
    });
  }
  function extractXar(file, dest, flags = []) {
    return __awaiter(this, undefined, undefined, function* () {
      assert_1.ok(IS_MAC, "extractXar() not supported on current OS");
      assert_1.ok(file, 'parameter "file" is required');
      dest = yield _createExtractFolder(dest);
      let args;
      if (flags instanceof Array) {
        args = flags;
      } else {
        args = [flags];
      }
      args.push("-x", "-C", dest, "-f", file);
      if (core2.isDebug()) {
        args.push("-v");
      }
      const xarPath = yield io.which("xar", true);
      yield exec_1.exec(`"${xarPath}"`, _unique(args));
      return dest;
    });
  }
  function extractZip(file, dest) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!file) {
        throw new Error("parameter 'file' is required");
      }
      dest = yield _createExtractFolder(dest);
      if (IS_WINDOWS) {
        yield extractZipWin(file, dest);
      } else {
        yield extractZipNix(file, dest);
      }
      return dest;
    });
  }
  function extractZipWin(file, dest) {
    return __awaiter(this, undefined, undefined, function* () {
      const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
      const escapedDest = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
      const pwshPath = yield io.which("pwsh", false);
      if (pwshPath) {
        const pwshCommand = [
          `\$ErrorActionPreference = 'Stop' ;`,
          `try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;`,
          `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', \$true) }`,
          `catch { if ((\$_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or (\$_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force } else { throw \$_ } } ;`
        ].join(" ");
        const args = [
          "-NoLogo",
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Unrestricted",
          "-Command",
          pwshCommand
        ];
        core2.debug(`Using pwsh at path: ${pwshPath}`);
        yield exec_1.exec(`"${pwshPath}"`, args);
      } else {
        const powershellCommand = [
          `\$ErrorActionPreference = 'Stop' ;`,
          `try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;`,
          `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force }`,
          `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', \$true) }`
        ].join(" ");
        const args = [
          "-NoLogo",
          "-Sta",
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Unrestricted",
          "-Command",
          powershellCommand
        ];
        const powershellPath = yield io.which("powershell", true);
        core2.debug(`Using powershell at path: ${powershellPath}`);
        yield exec_1.exec(`"${powershellPath}"`, args);
      }
    });
  }
  function extractZipNix(file, dest) {
    return __awaiter(this, undefined, undefined, function* () {
      const unzipPath = yield io.which("unzip", true);
      const args = [file];
      if (!core2.isDebug()) {
        args.unshift("-q");
      }
      args.unshift("-o");
      yield exec_1.exec(`"${unzipPath}"`, args, { cwd: dest });
    });
  }
  function cacheDir(sourceDir, tool, version, arch) {
    return __awaiter(this, undefined, undefined, function* () {
      version = semver.clean(version) || version;
      arch = arch || os.arch();
      core2.debug(`Caching tool ${tool} ${version} ${arch}`);
      core2.debug(`source dir: ${sourceDir}`);
      if (!fs.statSync(sourceDir).isDirectory()) {
        throw new Error("sourceDir is not a directory");
      }
      const destPath = yield _createToolPath(tool, version, arch);
      for (const itemName of fs.readdirSync(sourceDir)) {
        const s = path5.join(sourceDir, itemName);
        yield io.cp(s, destPath, { recursive: true });
      }
      _completeToolPath(tool, version, arch);
      return destPath;
    });
  }
  function cacheFile(sourceFile, targetFile, tool, version, arch) {
    return __awaiter(this, undefined, undefined, function* () {
      version = semver.clean(version) || version;
      arch = arch || os.arch();
      core2.debug(`Caching tool ${tool} ${version} ${arch}`);
      core2.debug(`source file: ${sourceFile}`);
      if (!fs.statSync(sourceFile).isFile()) {
        throw new Error("sourceFile is not a file");
      }
      const destFolder = yield _createToolPath(tool, version, arch);
      const destPath = path5.join(destFolder, targetFile);
      core2.debug(`destination file ${destPath}`);
      yield io.cp(sourceFile, destPath);
      _completeToolPath(tool, version, arch);
      return destFolder;
    });
  }
  function find(toolName, versionSpec, arch) {
    if (!toolName) {
      throw new Error("toolName parameter is required");
    }
    if (!versionSpec) {
      throw new Error("versionSpec parameter is required");
    }
    arch = arch || os.arch();
    if (!isExplicitVersion(versionSpec)) {
      const localVersions = findAllVersions(toolName, arch);
      const match = evaluateVersions(localVersions, versionSpec);
      versionSpec = match;
    }
    let toolPath = "";
    if (versionSpec) {
      versionSpec = semver.clean(versionSpec) || "";
      const cachePath = path5.join(_getCacheDirectory(), toolName, versionSpec, arch);
      core2.debug(`checking cache: ${cachePath}`);
      if (fs.existsSync(cachePath) && fs.existsSync(`${cachePath}.complete`)) {
        core2.debug(`Found tool in cache ${toolName} ${versionSpec} ${arch}`);
        toolPath = cachePath;
      } else {
        core2.debug("not found");
      }
    }
    return toolPath;
  }
  function findAllVersions(toolName, arch) {
    const versions = [];
    arch = arch || os.arch();
    const toolPath = path5.join(_getCacheDirectory(), toolName);
    if (fs.existsSync(toolPath)) {
      const children = fs.readdirSync(toolPath);
      for (const child of children) {
        if (isExplicitVersion(child)) {
          const fullPath = path5.join(toolPath, child, arch || "");
          if (fs.existsSync(fullPath) && fs.existsSync(`${fullPath}.complete`)) {
            versions.push(child);
          }
        }
      }
    }
    return versions;
  }
  function getManifestFromRepo(owner, repo, auth, branch = "master") {
    return __awaiter(this, undefined, undefined, function* () {
      let releases = [];
      const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}`;
      const http = new httpm.HttpClient("tool-cache");
      const headers = {};
      if (auth) {
        core2.debug("set auth");
        headers.authorization = auth;
      }
      const response = yield http.getJson(treeUrl, headers);
      if (!response.result) {
        return releases;
      }
      let manifestUrl = "";
      for (const item of response.result.tree) {
        if (item.path === "versions-manifest.json") {
          manifestUrl = item.url;
          break;
        }
      }
      headers["accept"] = "application/vnd.github.VERSION.raw";
      let versionsRaw = yield (yield http.get(manifestUrl, headers)).readBody();
      if (versionsRaw) {
        versionsRaw = versionsRaw.replace(/^\uFEFF/, "");
        try {
          releases = JSON.parse(versionsRaw);
        } catch (_a) {
          core2.debug("Invalid json");
        }
      }
      return releases;
    });
  }
  function findFromManifest(versionSpec, stable, manifest, archFilter = os.arch()) {
    return __awaiter(this, undefined, undefined, function* () {
      const match = yield mm._findMatch(versionSpec, stable, manifest, archFilter);
      return match;
    });
  }
  function _createExtractFolder(dest) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!dest) {
        dest = path5.join(_getTempDirectory(), v4_1.default());
      }
      yield io.mkdirP(dest);
      return dest;
    });
  }
  function _createToolPath(tool, version, arch) {
    return __awaiter(this, undefined, undefined, function* () {
      const folderPath = path5.join(_getCacheDirectory(), tool, semver.clean(version) || version, arch || "");
      core2.debug(`destination ${folderPath}`);
      const markerPath = `${folderPath}.complete`;
      yield io.rmRF(folderPath);
      yield io.rmRF(markerPath);
      yield io.mkdirP(folderPath);
      return folderPath;
    });
  }
  function _completeToolPath(tool, version, arch) {
    const folderPath = path5.join(_getCacheDirectory(), tool, semver.clean(version) || version, arch || "");
    const markerPath = `${folderPath}.complete`;
    fs.writeFileSync(markerPath, "");
    core2.debug("finished caching tool");
  }
  function isExplicitVersion(versionSpec) {
    const c3 = semver.clean(versionSpec) || "";
    core2.debug(`isExplicit: ${c3}`);
    const valid = semver.valid(c3) != null;
    core2.debug(`explicit? ${valid}`);
    return valid;
  }
  function evaluateVersions(versions, versionSpec) {
    let version = "";
    core2.debug(`evaluating ${versions.length} versions`);
    versions = versions.sort((a2, b) => {
      if (semver.gt(a2, b)) {
        return 1;
      }
      return -1;
    });
    for (let i2 = versions.length - 1;i2 >= 0; i2--) {
      const potential = versions[i2];
      const satisfied = semver.satisfies(potential, versionSpec);
      if (satisfied) {
        version = potential;
        break;
      }
    }
    if (version) {
      core2.debug(`matched: ${version}`);
    } else {
      core2.debug("match not found");
    }
    return version;
  }
  function _getCacheDirectory() {
    const cacheDirectory = process.env["RUNNER_TOOL_CACHE"] || "";
    assert_1.ok(cacheDirectory, "Expected RUNNER_TOOL_CACHE to be defined");
    return cacheDirectory;
  }
  function _getTempDirectory() {
    const tempDirectory = process.env["RUNNER_TEMP"] || "";
    assert_1.ok(tempDirectory, "Expected RUNNER_TEMP to be defined");
    return tempDirectory;
  }
  function _getGlobal(key, defaultValue) {
    const value = global[key];
    return value !== undefined ? value : defaultValue;
  }
  function _unique(values8) {
    return Array.from(new Set(values8));
  }
  var __dirname = "/Users/s01059/Documents/actions/setup-fluttergen/node_modules/@actions/tool-cache/lib";
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.evaluateVersions = exports.isExplicitVersion = exports.findFromManifest = exports.getManifestFromRepo = exports.findAllVersions = exports.find = exports.cacheFile = exports.cacheDir = exports.extractZip = exports.extractXar = exports.extractTar = exports.extract7z = exports.downloadTool = exports.HTTPError = undefined;
  var core2 = __importStar(require_core());
  var io = __importStar(require_io());
  var fs = __importStar(__require("fs"));
  var mm = __importStar(require_manifest());
  var os = __importStar(__require("os"));
  var path5 = __importStar(__require("path"));
  var httpm = __importStar(require_lib());
  var semver = __importStar(require_semver());
  var stream3 = __importStar(__require("stream"));
  var util = __importStar(__require("util"));
  var assert_1 = __require("assert");
  var v4_1 = __importDefault(require_v42());
  var exec_1 = require_exec();
  var retry_helper_1 = require_retry_helper();

  class HTTPError extends Error {
    constructor(httpStatusCode) {
      super(`Unexpected HTTP response: ${httpStatusCode}`);
      this.httpStatusCode = httpStatusCode;
      Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  exports.HTTPError = HTTPError;
  var IS_WINDOWS = process.platform === "win32";
  var IS_MAC = process.platform === "darwin";
  var userAgent = "actions/tool-cache";
  exports.downloadTool = downloadTool;
  exports.extract7z = extract7z;
  exports.extractTar = extractTar;
  exports.extractXar = extractXar;
  exports.extractZip = extractZip;
  exports.cacheDir = cacheDir;
  exports.cacheFile = cacheFile;
  exports.find = find;
  exports.findAllVersions = findAllVersions;
  exports.getManifestFromRepo = getManifestFromRepo;
  exports.findFromManifest = findFromManifest;
  exports.isExplicitVersion = isExplicitVersion;
  exports.evaluateVersions = evaluateVersions;
});

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS((exports) => {
  function getOptions(copy) {
    const result5 = {
      followSymbolicLinks: true,
      implicitDescendants: true,
      omitBrokenSymbolicLinks: true
    };
    if (copy) {
      if (typeof copy.followSymbolicLinks === "boolean") {
        result5.followSymbolicLinks = copy.followSymbolicLinks;
        core2.debug(`followSymbolicLinks '${result5.followSymbolicLinks}'`);
      }
      if (typeof copy.implicitDescendants === "boolean") {
        result5.implicitDescendants = copy.implicitDescendants;
        core2.debug(`implicitDescendants '${result5.implicitDescendants}'`);
      }
      if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
        result5.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
        core2.debug(`omitBrokenSymbolicLinks '${result5.omitBrokenSymbolicLinks}'`);
      }
    }
    return result5;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOptions = undefined;
  var core2 = __importStar(require_core());
  exports.getOptions = getOptions;
});

// node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS((exports) => {
  function dirname(p) {
    p = safeTrimTrailingSeparator(p);
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
      return p;
    }
    let result5 = path5.dirname(p);
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result5)) {
      result5 = safeTrimTrailingSeparator(result5);
    }
    return result5;
  }
  function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    if (hasAbsoluteRoot(itemPath)) {
      return itemPath;
    }
    if (IS_WINDOWS) {
      if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let cwd3 = process.cwd();
        assert_1.default(cwd3.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd3}'`);
        if (itemPath[0].toUpperCase() === cwd3[0].toUpperCase()) {
          if (itemPath.length === 2) {
            return `${itemPath[0]}:\\${cwd3.substr(3)}`;
          } else {
            if (!cwd3.endsWith("\\")) {
              cwd3 += "\\";
            }
            return `${itemPath[0]}:\\${cwd3.substr(3)}${itemPath.substr(2)}`;
          }
        } else {
          return `${itemPath[0]}:\\${itemPath.substr(2)}`;
        }
      } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
        const cwd3 = process.cwd();
        assert_1.default(cwd3.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd3}'`);
        return `${cwd3[0]}:\\${itemPath.substr(1)}`;
      }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) {
    } else {
      root += path5.sep;
    }
    return root + itemPath;
  }
  function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  function normalizeSeparators(p) {
    p = p || "";
    if (IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      const isUnc = /^\\\\+[^\\]/.test(p);
      return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  function safeTrimTrailingSeparator(p) {
    if (!p) {
      return "";
    }
    p = normalizeSeparators(p);
    if (!p.endsWith(path5.sep)) {
      return p;
    }
    if (p === path5.sep) {
      return p;
    }
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
      return p;
    }
    return p.substr(0, p.length - 1);
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = undefined;
  var path5 = __importStar(__require("path"));
  var assert_1 = __importDefault(__require("assert"));
  var IS_WINDOWS = process.platform === "win32";
  exports.dirname = dirname;
  exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
  exports.hasAbsoluteRoot = hasAbsoluteRoot;
  exports.hasRoot = hasRoot;
  exports.normalizeSeparators = normalizeSeparators;
  exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
});

// node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MatchKind = undefined;
  var MatchKind;
  (function(MatchKind2) {
    MatchKind2[MatchKind2["None"] = 0] = "None";
    MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
    MatchKind2[MatchKind2["File"] = 2] = "File";
    MatchKind2[MatchKind2["All"] = 3] = "All";
  })(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
});

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS((exports) => {
  function getSearchPaths(patterns) {
    patterns = patterns.filter((x) => !x.negate);
    const searchPathMap = {};
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      searchPathMap[key] = "candidate";
    }
    const result5 = [];
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      if (searchPathMap[key] === "included") {
        continue;
      }
      let foundAncestor = false;
      let tempKey = key;
      let parent = pathHelper.dirname(tempKey);
      while (parent !== tempKey) {
        if (searchPathMap[parent]) {
          foundAncestor = true;
          break;
        }
        tempKey = parent;
        parent = pathHelper.dirname(tempKey);
      }
      if (!foundAncestor) {
        result5.push(pattern.searchPath);
        searchPathMap[key] = "included";
      }
    }
    return result5;
  }
  function match(patterns, itemPath) {
    let result5 = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
      if (pattern.negate) {
        result5 &= ~pattern.match(itemPath);
      } else {
        result5 |= pattern.match(itemPath);
      }
    }
    return result5;
  }
  function partialMatch(patterns, itemPath) {
    return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partialMatch = exports.match = exports.getSearchPaths = undefined;
  var pathHelper = __importStar(require_internal_path_helper());
  var internal_match_kind_1 = require_internal_match_kind();
  var IS_WINDOWS = process.platform === "win32";
  exports.getSearchPaths = getSearchPaths;
  exports.match = match;
  exports.partialMatch = partialMatch;
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports, module) => {
  module.exports = function(xs, fn) {
    var res = [];
    for (var i2 = 0;i2 < xs.length; i2++) {
      var x = fn(xs[i2], i2);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  function balanced(a2, b, str) {
    if (a2 instanceof RegExp)
      a2 = maybeMatch(a2, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a2, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a2.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  function range(a2, b, str) {
    var begs, beg, left, right, result5;
    var ai = str.indexOf(a2);
    var bi = str.indexOf(b, ai + 1);
    var i2 = ai;
    if (ai >= 0 && bi > 0) {
      if (a2 === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i2 >= 0 && !result5) {
        if (i2 == ai) {
          begs.push(i2);
          ai = str.indexOf(a2, i2 + 1);
        } else if (begs.length == 1) {
          result5 = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i2 + 1);
        }
        i2 = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result5 = [left, right];
      }
    }
    return result5;
  }
  module.exports = balanced;
  balanced.range = range;
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i2, y) {
    return i2 <= y;
  }
  function gte(i2, y) {
    return i2 >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n2;
    if (isSequence) {
      n2 = m.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m.body);
      if (n2.length === 1) {
        n2 = expand(n2[0], false).map(embrace);
        if (n2.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n2[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n2[0]);
      var y = numeric(n2[1]);
      var width = Math.max(n2[0].length, n2[1].length);
      var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n2.some(isPadded);
      N = [];
      for (var i2 = x;test(i2, y); i2 += incr) {
        var c3;
        if (isAlphaSequence) {
          c3 = String.fromCharCode(i2);
          if (c3 === "\\")
            c3 = "";
        } else {
          c3 = String(i2);
          if (pad) {
            var need = width - c3.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i2 < 0)
                c3 = "-" + z + c3.slice(1);
              else
                c3 = z + c3;
            }
          }
        }
        N.push(c3);
      }
    } else {
      N = concatMap(n2, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0;j < N.length; j++) {
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  function charSet(s) {
    return s.split("").reduce(function(set, c3) {
      set[c3] = true;
      return set;
    }, {});
  }
  function filter(pattern, options3) {
    options3 = options3 || {};
    return function(p, i2, list) {
      return minimatch(p, pattern, options3);
    };
  }
  function ext(a2, b) {
    b = b || {};
    var t = {};
    Object.keys(a2).forEach(function(k) {
      t[k] = a2[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  function minimatch(p, pattern, options3) {
    assertValidPattern(pattern);
    if (!options3)
      options3 = {};
    if (!options3.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options3).match(p);
  }
  function Minimatch(pattern, options3) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options3);
    }
    assertValidPattern(pattern);
    if (!options3)
      options3 = {};
    pattern = pattern.trim();
    if (!options3.allowWindowsEscape && path5.sep !== "/") {
      pattern = pattern.split(path5.sep).join("/");
    }
    this.options = options3;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options3.partial;
    this.make();
  }
  function make() {
    var pattern = this.pattern;
    var options3 = this.options;
    if (!options3.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options3.debug)
      this.debug = function debug() {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options3 = this.options;
    var negateOffset = 0;
    if (options3.nonegate)
      return;
    for (var i2 = 0, l = pattern.length;i2 < l && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  function braceExpand(pattern, options3) {
    if (!options3) {
      if (this instanceof Minimatch) {
        options3 = this.options;
      } else {
        options3 = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options3.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  function parse(pattern, isSub) {
    assertValidPattern(pattern);
    var options3 = this.options;
    if (pattern === "**") {
      if (!options3.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options3.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options3.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i2 = 0, len = pattern.length, c3;i2 < len && (c3 = pattern.charAt(i2)); i2++) {
      this.debug("%s\t%s %s %j", pattern, i2, re, c3);
      if (escaping && reSpecials[c3]) {
        re += "\\" + c3;
        escaping = false;
        continue;
      }
      switch (c3) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s\t%s %s %j <-- stateChar", pattern, i2, re, c3);
          if (inClass) {
            this.debug("  in class");
            if (c3 === "!" && i2 === classStart + 1)
              c3 = "^";
            re += c3;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c3;
          if (options3.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i2 - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c3;
            continue;
          }
          inClass = true;
          classStart = i2;
          reClassStart = re.length;
          re += c3;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re += "\\" + c3;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i2);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c3;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c3] && !(c3 === "^" && inClass)) {
            re += "\\";
          }
          re += c3;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n2 = negativeLists.length - 1;n2 > -1; n2--) {
      var nl = negativeLists[n2];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i2 = 0;i2 < openParensBefore; i2++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options3.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options3 = this.options;
    var twoStar = options3.noglobstar ? star : options3.dot ? twoStarDot : twoStarNoDot;
    var flags = options3.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  module.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path5 = function() {
    try {
      return __require("path");
    } catch (e) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path5.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch(p, pattern, options3) {
      return orig(p, pattern, ext(def, options3));
    };
    m.Minimatch = function Minimatch(pattern, options3) {
      return new orig.Minimatch(pattern, ext(def, options3));
    };
    m.Minimatch.defaults = function defaults(options3) {
      return orig.defaults(ext(def, options3)).Minimatch;
    };
    m.filter = function filter(pattern, options3) {
      return orig.filter(pattern, ext(def, options3));
    };
    m.defaults = function defaults(options3) {
      return orig.defaults(ext(def, options3));
    };
    m.makeRe = function makeRe(pattern, options3) {
      return orig.makeRe(pattern, ext(def, options3));
    };
    m.braceExpand = function braceExpand(pattern, options3) {
      return orig.braceExpand(pattern, ext(def, options3));
    };
    m.match = function(list, pattern, options3) {
      return orig.match(list, pattern, ext(def, options3));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  Minimatch.prototype.parseNegate = parseNegate;
  minimatch.braceExpand = function(pattern, options3) {
    return braceExpand(pattern, options3);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  minimatch.makeRe = function(pattern, options3) {
    return new Minimatch(pattern, options3 || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  minimatch.match = function(list, pattern, options3) {
    options3 = options3 || {};
    var mm = new Minimatch(pattern, options3);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined")
      partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options3 = this.options;
    if (path5.sep !== "/") {
      f = f.split(path5.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i2;
    for (i2 = f.length - 1;i2 >= 0; i2--) {
      filename = f[i2];
      if (filename)
        break;
    }
    for (i2 = 0;i2 < set.length; i2++) {
      var pattern = set[i2];
      var file = f;
      if (options3.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options3.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options3.flipNegate)
      return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options3 = this.options;
    this.debug("matchOne", { this: this, file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options3.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options3.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
});

// node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Path = undefined;
  var path5 = __importStar(__require("path"));
  var pathHelper = __importStar(require_internal_path_helper());
  var assert_1 = __importDefault(__require("assert"));
  var IS_WINDOWS = process.platform === "win32";

  class Path {
    constructor(itemPath) {
      this.segments = [];
      if (typeof itemPath === "string") {
        assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (!pathHelper.hasRoot(itemPath)) {
          this.segments = itemPath.split(path5.sep);
        } else {
          let remaining = itemPath;
          let dir = pathHelper.dirname(remaining);
          while (dir !== remaining) {
            const basename = path5.basename(remaining);
            this.segments.unshift(basename);
            remaining = dir;
            dir = pathHelper.dirname(remaining);
          }
          this.segments.unshift(remaining);
        }
      } else {
        assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
        for (let i2 = 0;i2 < itemPath.length; i2++) {
          let segment = itemPath[i2];
          assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
          segment = pathHelper.normalizeSeparators(itemPath[i2]);
          if (i2 === 0 && pathHelper.hasRoot(segment)) {
            segment = pathHelper.safeTrimTrailingSeparator(segment);
            assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
            this.segments.push(segment);
          } else {
            assert_1.default(!segment.includes(path5.sep), `Parameter 'itemPath' contains unexpected path separators`);
            this.segments.push(segment);
          }
        }
      }
    }
    toString() {
      let result5 = this.segments[0];
      let skipSlash = result5.endsWith(path5.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result5);
      for (let i2 = 1;i2 < this.segments.length; i2++) {
        if (skipSlash) {
          skipSlash = false;
        } else {
          result5 += path5.sep;
        }
        result5 += this.segments[i2];
      }
      return result5;
    }
  }
  exports.Path = Path;
});

// node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pattern = undefined;
  var os = __importStar(__require("os"));
  var path5 = __importStar(__require("path"));
  var pathHelper = __importStar(require_internal_path_helper());
  var assert_1 = __importDefault(__require("assert"));
  var minimatch_1 = require_minimatch();
  var internal_match_kind_1 = require_internal_match_kind();
  var internal_path_1 = require_internal_path();
  var IS_WINDOWS = process.platform === "win32";

  class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
      this.negate = false;
      let pattern;
      if (typeof patternOrNegate === "string") {
        pattern = patternOrNegate.trim();
      } else {
        segments = segments || [];
        assert_1.default(segments.length, `Parameter 'segments' must not empty`);
        const root = Pattern.getLiteral(segments[0]);
        assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
        pattern = new internal_path_1.Path(segments).toString().trim();
        if (patternOrNegate) {
          pattern = `!${pattern}`;
        }
      }
      while (pattern.startsWith("!")) {
        this.negate = !this.negate;
        pattern = pattern.substr(1).trim();
      }
      pattern = Pattern.fixupPattern(pattern, homedir);
      this.segments = new internal_path_1.Path(pattern).segments;
      this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path5.sep);
      pattern = pathHelper.safeTrimTrailingSeparator(pattern);
      let foundGlob = false;
      const searchSegments = this.segments.map((x) => Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
      this.searchPath = new internal_path_1.Path(searchSegments).toString();
      this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
      this.isImplicitPattern = isImplicitPattern;
      const minimatchOptions = {
        dot: true,
        nobrace: true,
        nocase: IS_WINDOWS,
        nocomment: true,
        noext: true,
        nonegate: true
      };
      pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
      this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    match(itemPath) {
      if (this.segments[this.segments.length - 1] === "**") {
        itemPath = pathHelper.normalizeSeparators(itemPath);
        if (!itemPath.endsWith(path5.sep) && this.isImplicitPattern === false) {
          itemPath = `${itemPath}${path5.sep}`;
        }
      } else {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      }
      if (this.minimatch.match(itemPath)) {
        return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
      }
      return internal_match_kind_1.MatchKind.None;
    }
    partialMatch(itemPath) {
      itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      if (pathHelper.dirname(itemPath) === itemPath) {
        return this.rootRegExp.test(itemPath);
      }
      return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    static globEscape(s) {
      return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
    }
    static fixupPattern(pattern, homedir) {
      assert_1.default(pattern, "pattern cannot be empty");
      const literalSegments = new internal_path_1.Path(pattern).segments.map((x) => Pattern.getLiteral(x));
      assert_1.default(literalSegments.every((x, i2) => (x !== "." || i2 === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
      assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
      pattern = pathHelper.normalizeSeparators(pattern);
      if (pattern === "." || pattern.startsWith(`.${path5.sep}`)) {
        pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
      } else if (pattern === "~" || pattern.startsWith(`~${path5.sep}`)) {
        homedir = homedir || os.homedir();
        assert_1.default(homedir, "Unable to determine HOME directory");
        assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
        pattern = Pattern.globEscape(homedir) + pattern.substr(1);
      } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
        if (pattern.length > 2 && !root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(2);
      } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        if (!root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(1);
      } else {
        pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
      }
      return pathHelper.normalizeSeparators(pattern);
    }
    static getLiteral(segment) {
      let literal = "";
      for (let i2 = 0;i2 < segment.length; i2++) {
        const c3 = segment[i2];
        if (c3 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
          literal += segment[++i2];
          continue;
        } else if (c3 === "*" || c3 === "?") {
          return "";
        } else if (c3 === "[" && i2 + 1 < segment.length) {
          let set = "";
          let closed = -1;
          for (let i22 = i2 + 1;i22 < segment.length; i22++) {
            const c22 = segment[i22];
            if (c22 === "\\" && !IS_WINDOWS && i22 + 1 < segment.length) {
              set += segment[++i22];
              continue;
            } else if (c22 === "]") {
              closed = i22;
              break;
            } else {
              set += c22;
            }
          }
          if (closed >= 0) {
            if (set.length > 1) {
              return "";
            }
            if (set) {
              literal += set;
              i2 = closed;
              continue;
            }
          }
        }
        literal += c3;
      }
      return literal;
    }
    static regExpEscape(s) {
      return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  }
  exports.Pattern = Pattern;
});

// node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SearchState = undefined;

  class SearchState {
    constructor(path5, level) {
      this.path = path5;
      this.level = level;
    }
  }
  exports.SearchState = SearchState;
});

// node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o2, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = exports && exports.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o2[Symbol.asyncIterator], i2;
    return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v) {
        return new Promise(function(resolve, reject4) {
          v = o2[n2](v), settle(resolve, reject4, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject4, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject4);
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator4) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator4.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n2) {
      if (g[n2])
        i2[n2] = function(v) {
          return new Promise(function(a2, b) {
            q.push([n2, v, a2, b]) > 1 || resume(n2, v);
          });
        };
    }
    function resume(n2, v) {
      try {
        step(g[n2](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject4) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject4(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultGlobber = undefined;
  var core2 = __importStar(require_core());
  var fs = __importStar(__require("fs"));
  var globOptionsHelper = __importStar(require_internal_glob_options_helper());
  var path5 = __importStar(__require("path"));
  var patternHelper = __importStar(require_internal_pattern_helper());
  var internal_match_kind_1 = require_internal_match_kind();
  var internal_pattern_1 = require_internal_pattern();
  var internal_search_state_1 = require_internal_search_state();
  var IS_WINDOWS = process.platform === "win32";

  class DefaultGlobber {
    constructor(options3) {
      this.patterns = [];
      this.searchPaths = [];
      this.options = globOptionsHelper.getOptions(options3);
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var e_1, _a;
      return __awaiter(this, undefined, undefined, function* () {
        const result5 = [];
        try {
          for (var _b = __asyncValues(this.globGenerator()), _c;_c = yield _b.next(), !_c.done; ) {
            const itemPath = _c.value;
            result5.push(itemPath);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              yield _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result5;
      });
    }
    globGenerator() {
      return __asyncGenerator(this, arguments, function* globGenerator_1() {
        const options3 = globOptionsHelper.getOptions(this.options);
        const patterns = [];
        for (const pattern of this.patterns) {
          patterns.push(pattern);
          if (options3.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
            patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
          }
        }
        const stack = [];
        for (const searchPath of patternHelper.getSearchPaths(patterns)) {
          core2.debug(`Search path '${searchPath}'`);
          try {
            yield __await(fs.promises.lstat(searchPath));
          } catch (err) {
            if (err.code === "ENOENT") {
              continue;
            }
            throw err;
          }
          stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
        }
        const traversalChain = [];
        while (stack.length) {
          const item = stack.pop();
          const match = patternHelper.match(patterns, item.path);
          const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
          if (!match && !partialMatch) {
            continue;
          }
          const stats = yield __await(DefaultGlobber.stat(item, options3, traversalChain));
          if (!stats) {
            continue;
          }
          if (stats.isDirectory()) {
            if (match & internal_match_kind_1.MatchKind.Directory) {
              yield yield __await(item.path);
            } else if (!partialMatch) {
              continue;
            }
            const childLevel = item.level + 1;
            const childItems = (yield __await(fs.promises.readdir(item.path))).map((x) => new internal_search_state_1.SearchState(path5.join(item.path, x), childLevel));
            stack.push(...childItems.reverse());
          } else if (match & internal_match_kind_1.MatchKind.File) {
            yield yield __await(item.path);
          }
        }
      });
    }
    static create(patterns, options3) {
      return __awaiter(this, undefined, undefined, function* () {
        const result5 = new DefaultGlobber(options3);
        if (IS_WINDOWS) {
          patterns = patterns.replace(/\r\n/g, "\n");
          patterns = patterns.replace(/\r/g, "\n");
        }
        const lines = patterns.split("\n").map((x) => x.trim());
        for (const line of lines) {
          if (!line || line.startsWith("#")) {
            continue;
          } else {
            result5.patterns.push(new internal_pattern_1.Pattern(line));
          }
        }
        result5.searchPaths.push(...patternHelper.getSearchPaths(result5.patterns));
        return result5;
      });
    }
    static stat(item, options3, traversalChain) {
      return __awaiter(this, undefined, undefined, function* () {
        let stats;
        if (options3.followSymbolicLinks) {
          try {
            stats = yield fs.promises.stat(item.path);
          } catch (err) {
            if (err.code === "ENOENT") {
              if (options3.omitBrokenSymbolicLinks) {
                core2.debug(`Broken symlink '${item.path}'`);
                return;
              }
              throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
            }
            throw err;
          }
        } else {
          stats = yield fs.promises.lstat(item.path);
        }
        if (stats.isDirectory() && options3.followSymbolicLinks) {
          const realPath = yield fs.promises.realpath(item.path);
          while (traversalChain.length >= item.level) {
            traversalChain.pop();
          }
          if (traversalChain.some((x) => x === realPath)) {
            core2.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
            return;
          }
          traversalChain.push(realPath);
        }
        return stats;
      });
    }
  }
  exports.DefaultGlobber = DefaultGlobber;
});

// node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS((exports) => {
  function create2(patterns, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield internal_globber_1.DefaultGlobber.create(patterns, options3);
    });
  }
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.create = undefined;
  var internal_globber_1 = require_internal_globber();
  exports.create = create2;
});

// node_modules/@actions/cache/node_modules/semver/semver.js
var require_semver2 = __commonJS((exports, module) => {
  function tok(n2) {
    t[n2] = R++;
  }
  function makeSafeRe(value) {
    for (var i3 = 0;i3 < safeRegexReplacements.length; i3++) {
      var token = safeRegexReplacements[i3][0];
      var max = safeRegexReplacements[i3][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  function parse(version, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options3.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options3);
    } catch (er) {
      return null;
    }
  }
  function valid(version, options3) {
    var v = parse(version, options3);
    return v ? v.version : null;
  }
  function clean(version, options3) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options3);
    return s ? s.version : null;
  }
  function SemVer(version, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options3.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options3);
    }
    debug("SemVer", version, options3);
    this.options = options3;
    this.loose = !!options3.loose;
    var m = version.trim().match(options3.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  function compareIdentifiers(a2, b) {
    var anum = numeric.test(a2);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a2 = +a2;
      b = +b;
    }
    return a2 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b ? -1 : 1;
  }
  function rcompareIdentifiers(a2, b) {
    return compareIdentifiers(b, a2);
  }
  function major(a2, loose) {
    return new SemVer(a2, loose).major;
  }
  function minor(a2, loose) {
    return new SemVer(a2, loose).minor;
  }
  function patch(a2, loose) {
    return new SemVer(a2, loose).patch;
  }
  function compare(a2, b, loose) {
    return new SemVer(a2, loose).compare(new SemVer(b, loose));
  }
  function compareLoose(a2, b) {
    return compare(a2, b, true);
  }
  function compareBuild(a2, b, loose) {
    var versionA = new SemVer(a2, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  function rcompare(a2, b, loose) {
    return compare(b, a2, loose);
  }
  function sort(list, loose) {
    return list.sort(function(a2, b) {
      return exports.compareBuild(a2, b, loose);
    });
  }
  function rsort(list, loose) {
    return list.sort(function(a2, b) {
      return exports.compareBuild(b, a2, loose);
    });
  }
  function gt(a2, b, loose) {
    return compare(a2, b, loose) > 0;
  }
  function lt(a2, b, loose) {
    return compare(a2, b, loose) < 0;
  }
  function eq(a2, b, loose) {
    return compare(a2, b, loose) === 0;
  }
  function neq(a2, b, loose) {
    return compare(a2, b, loose) !== 0;
  }
  function gte(a2, b, loose) {
    return compare(a2, b, loose) >= 0;
  }
  function lte(a2, b, loose) {
    return compare(a2, b, loose) <= 0;
  }
  function cmp(a2, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b === "object")
          b = b.version;
        return a2 === b;
      case "!==":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b === "object")
          b = b.version;
        return a2 !== b;
      case "":
      case "=":
      case "==":
        return eq(a2, b, loose);
      case "!=":
        return neq(a2, b, loose);
      case ">":
        return gt(a2, b, loose);
      case ">=":
        return gte(a2, b, loose);
      case "<":
        return lt(a2, b, loose);
      case "<=":
        return lte(a2, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  function Comparator(comp, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options3.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options3);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options3);
    this.options = options3;
    this.loose = !!options3.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  function Range(range, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options3.loose && range.includePrerelease === !!options3.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options3);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options3);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options3);
    }
    this.options = options3;
    this.loose = !!options3.loose;
    this.includePrerelease = !!options3.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c3) {
      return c3.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  }
  function isSatisfiable(comparators, options3) {
    var result5 = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result5 && remainingComparators.length) {
      result5 = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options3);
      });
      testComparator = remainingComparators.pop();
    }
    return result5;
  }
  function toComparators(range, options3) {
    return new Range(range, options3).set.map(function(comp) {
      return comp.map(function(c3) {
        return c3.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options3) {
    debug("comp", comp, options3);
    comp = replaceCarets(comp, options3);
    debug("caret", comp);
    comp = replaceTildes(comp, options3);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options3);
    debug("xrange", comp);
    comp = replaceStars(comp, options3);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options3) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options3);
    }).join(" ");
  }
  function replaceTilde(comp, options3) {
    var r = options3.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options3) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options3);
    }).join(" ");
  }
  function replaceCaret(comp, options3) {
    debug("caret", comp, options3);
    var r = options3.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options3) {
    debug("replaceXRanges", comp, options3);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options3);
    }).join(" ");
  }
  function replaceXRange(comp, options3) {
    comp = comp.trim();
    var r = options3.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options3.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options3) {
    debug("replaceStars", comp, options3);
    return comp.trim().replace(safeRe[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  function testSet(set, version, options3) {
    for (var i3 = 0;i3 < set.length; i3++) {
      if (!set[i3].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options3.includePrerelease) {
      for (i3 = 0;i3 < set.length; i3++) {
        debug(set[i3].semver);
        if (set[i3].semver === ANY) {
          continue;
        }
        if (set[i3].semver.prerelease.length > 0) {
          var allowed = set[i3].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  function satisfies(version, range, options3) {
    try {
      range = new Range(range, options3);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  function maxSatisfying(versions, range, options3) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options3);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options3);
        }
      }
    });
    return max;
  }
  function minSatisfying(versions, range, options3) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options3);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options3);
        }
      }
    });
    return min;
  }
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  function validRange(range, options3) {
    try {
      return new Range(range, options3).range || "*";
    } catch (er) {
      return null;
    }
  }
  function ltr(version, range, options3) {
    return outside(version, range, "<", options3);
  }
  function gtr(version, range, options3) {
    return outside(version, range, ">", options3);
  }
  function outside(version, range, hilo, options3) {
    version = new SemVer(version, options3);
    range = new Range(range, options3);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options3)) {
      return false;
    }
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options3)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options3)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  function prerelease(version, options3) {
    var parsed = parse(version, options3);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  function intersects(r1, r2, options3) {
    r1 = new Range(r1, options3);
    r2 = new Range(r2, options3);
    return r1.intersects(r2);
  }
  function coerce(version, options3) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options3 = options3 || {};
    var match = null;
    if (!options3.rtl) {
      match = version.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options3);
  }
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])" + "(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAIN] + ")" + "\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i2 = 0;i2 < R; i2++) {
    debug(i2, src[i2]);
    if (!re[i2]) {
      re[i2] = new RegExp(src[i2]);
      safeRe[i2] = new RegExp(makeSafeRe(src[i2]));
    }
  }
  var i2;
  exports.parse = parse;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i3 = 0;
    do {
      var a2 = this.prerelease[i3];
      var b = other.prerelease[i3];
      debug("prerelease compare", i3, a2, b);
      if (a2 === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b) {
        continue;
      } else {
        return compareIdentifiers(a2, b);
      }
    } while (++i3);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i3 = 0;
    do {
      var a2 = this.build[i3];
      var b = other.build[i3];
      debug("prerelease compare", i3, a2, b);
      if (a2 === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b) {
        continue;
      } else {
        return compareIdentifiers(a2, b);
      }
    } while (++i3);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i3 = this.prerelease.length;
          while (--i3 >= 0) {
            if (typeof this.prerelease[i3] === "number") {
              this.prerelease[i3]++;
              i3 = -2;
            }
          }
          if (i3 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options3) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options3);
      return satisfies(this.value, rangeTmp, options3);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options3);
      return satisfies(comp.semver, rangeTmp, options3);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options3) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options3) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options3) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options3) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options3) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options3);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i3 = 0;i3 < this.set.length; i3++) {
      if (testSet(this.set[i3], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce;
});

// node_modules/uuid/v1.js
var require_v12 = __commonJS((exports, module) => {
  function v1(options3, buf, offset) {
    var i2 = buf && offset || 0;
    var b = buf || [];
    options3 = options3 || {};
    var node3 = options3.node || _nodeId;
    var clockseq = options3.clockseq !== undefined ? options3.clockseq : _clockseq;
    if (node3 == null || clockseq == null) {
      var seedBytes = rng();
      if (node3 == null) {
        node3 = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options3.msecs !== undefined ? options3.msecs : new Date().getTime();
    var nsecs = options3.nsecs !== undefined ? options3.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options3.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options3.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can\'t create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i2++] = tl >>> 24 & 255;
    b[i2++] = tl >>> 16 & 255;
    b[i2++] = tl >>> 8 & 255;
    b[i2++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i2++] = tmh >>> 8 & 255;
    b[i2++] = tmh & 255;
    b[i2++] = tmh >>> 24 & 15 | 16;
    b[i2++] = tmh >>> 16 & 255;
    b[i2++] = clockseq >>> 8 | 128;
    b[i2++] = clockseq & 255;
    for (var n2 = 0;n2 < 6; ++n2) {
      b[i2 + n2] = node3[n2];
    }
    return buf ? buf : bytesToUuid(b);
  }
  var rng = require_rng2();
  var bytesToUuid = require_bytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  module.exports = v1;
});

// node_modules/uuid/index.js
var require_uuid = __commonJS((exports, module) => {
  var v1 = require_v12();
  var v4 = require_v42();
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  module.exports = uuid;
});

// node_modules/@actions/cache/lib/internal/constants.js
var require_constants6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ManifestFilename = exports.TarFilename = exports.SystemTarPathOnWindows = exports.GnuTarPathOnWindows = exports.SocketTimeout = exports.DefaultRetryDelay = exports.DefaultRetryAttempts = exports.ArchiveToolType = exports.CompressionMethod = exports.CacheFilename = undefined;
  var CacheFilename;
  (function(CacheFilename2) {
    CacheFilename2["Gzip"] = "cache.tgz";
    CacheFilename2["Zstd"] = "cache.tzst";
  })(CacheFilename || (exports.CacheFilename = CacheFilename = {}));
  var CompressionMethod;
  (function(CompressionMethod2) {
    CompressionMethod2["Gzip"] = "gzip";
    CompressionMethod2["ZstdWithoutLong"] = "zstd-without-long";
    CompressionMethod2["Zstd"] = "zstd";
  })(CompressionMethod || (exports.CompressionMethod = CompressionMethod = {}));
  var ArchiveToolType;
  (function(ArchiveToolType2) {
    ArchiveToolType2["GNU"] = "gnu";
    ArchiveToolType2["BSD"] = "bsd";
  })(ArchiveToolType || (exports.ArchiveToolType = ArchiveToolType = {}));
  exports.DefaultRetryAttempts = 2;
  exports.DefaultRetryDelay = 5000;
  exports.SocketTimeout = 5000;
  exports.GnuTarPathOnWindows = `${process.env["PROGRAMFILES"]}\\Git\\usr\\bin\\tar.exe`;
  exports.SystemTarPathOnWindows = `${process.env["SYSTEMDRIVE"]}\\Windows\\System32\\tar.exe`;
  exports.TarFilename = "cache.tar";
  exports.ManifestFilename = "manifest.txt";
});

// node_modules/@actions/cache/lib/internal/cacheUtils.js
var require_cacheUtils = __commonJS((exports) => {
  function createTempDirectory() {
    return __awaiter(this, undefined, undefined, function* () {
      const IS_WINDOWS = process.platform === "win32";
      let tempDirectory = process.env["RUNNER_TEMP"] || "";
      if (!tempDirectory) {
        let baseLocation;
        if (IS_WINDOWS) {
          baseLocation = process.env["USERPROFILE"] || "C:\\";
        } else {
          if (process.platform === "darwin") {
            baseLocation = "/Users";
          } else {
            baseLocation = "/home";
          }
        }
        tempDirectory = path5.join(baseLocation, "actions", "temp");
      }
      const dest = path5.join(tempDirectory, (0, uuid_1.v4)());
      yield io.mkdirP(dest);
      return dest;
    });
  }
  function getArchiveFileSizeInBytes(filePath) {
    return fs.statSync(filePath).size;
  }
  function resolvePaths(patterns) {
    var _a, e_1, _b, _c;
    var _d;
    return __awaiter(this, undefined, undefined, function* () {
      const paths = [];
      const workspace = (_d = process.env["GITHUB_WORKSPACE"]) !== null && _d !== undefined ? _d : process.cwd();
      const globber = yield glob.create(patterns.join("\n"), {
        implicitDescendants: false
      });
      try {
        for (var _e = true, _f = __asyncValues(globber.globGenerator()), _g;_g = yield _f.next(), _a = _g.done, !_a; _e = true) {
          _c = _g.value;
          _e = false;
          const file = _c;
          const relativeFile = path5.relative(workspace, file).replace(new RegExp(`\\${path5.sep}`, "g"), "/");
          core2.debug(`Matched: ${relativeFile}`);
          if (relativeFile === "") {
            paths.push(".");
          } else {
            paths.push(`${relativeFile}`);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e && !_a && (_b = _f.return))
            yield _b.call(_f);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return paths;
    });
  }
  function unlinkFile(filePath) {
    return __awaiter(this, undefined, undefined, function* () {
      return util.promisify(fs.unlink)(filePath);
    });
  }
  function getVersion(app, additionalArgs = []) {
    return __awaiter(this, undefined, undefined, function* () {
      let versionOutput = "";
      additionalArgs.push("--version");
      core2.debug(`Checking ${app} ${additionalArgs.join(" ")}`);
      try {
        yield exec.exec(`${app}`, additionalArgs, {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
      } catch (err) {
        core2.debug(err.message);
      }
      versionOutput = versionOutput.trim();
      core2.debug(versionOutput);
      return versionOutput;
    });
  }
  function getCompressionMethod() {
    return __awaiter(this, undefined, undefined, function* () {
      const versionOutput = yield getVersion("zstd", ["--quiet"]);
      const version = semver.clean(versionOutput);
      core2.debug(`zstd version: ${version}`);
      if (versionOutput === "") {
        return constants_1.CompressionMethod.Gzip;
      } else {
        return constants_1.CompressionMethod.ZstdWithoutLong;
      }
    });
  }
  function getCacheFileName(compressionMethod) {
    return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
  }
  function getGnuTarPathOnWindows() {
    return __awaiter(this, undefined, undefined, function* () {
      if (fs.existsSync(constants_1.GnuTarPathOnWindows)) {
        return constants_1.GnuTarPathOnWindows;
      }
      const versionOutput = yield getVersion("tar");
      return versionOutput.toLowerCase().includes("gnu tar") ? io.which("tar") : "";
    });
  }
  function assertDefined(name, value) {
    if (value === undefined) {
      throw Error(`Expected ${name} but value was undefiend`);
    }
    return value;
  }
  function isGhes() {
    const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
    const hostname = ghUrl.hostname.trimEnd().toUpperCase();
    const isGitHubHost = hostname === "GITHUB.COM";
    const isGheHost = hostname.endsWith(".GHE.COM") || hostname.endsWith(".GHE.LOCALHOST");
    return !isGitHubHost && !isGheHost;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = exports && exports.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o2[Symbol.asyncIterator], i2;
    return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v) {
        return new Promise(function(resolve, reject4) {
          v = o2[n2](v), settle(resolve, reject4, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject4, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject4);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isGhes = exports.assertDefined = exports.getGnuTarPathOnWindows = exports.getCacheFileName = exports.getCompressionMethod = exports.unlinkFile = exports.resolvePaths = exports.getArchiveFileSizeInBytes = exports.createTempDirectory = undefined;
  var core2 = __importStar(require_core());
  var exec = __importStar(require_exec());
  var glob = __importStar(require_glob());
  var io = __importStar(require_io());
  var fs = __importStar(__require("fs"));
  var path5 = __importStar(__require("path"));
  var semver = __importStar(require_semver2());
  var util = __importStar(__require("util"));
  var uuid_1 = require_uuid();
  var constants_1 = require_constants6();
  exports.createTempDirectory = createTempDirectory;
  exports.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
  exports.resolvePaths = resolvePaths;
  exports.unlinkFile = unlinkFile;
  exports.getCompressionMethod = getCompressionMethod;
  exports.getCacheFileName = getCacheFileName;
  exports.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
  exports.assertDefined = assertDefined;
  exports.isGhes = isGhes;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline = __commonJS((exports) => {
  function createEmptyPipeline() {
    return HttpPipeline.create();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEmptyPipeline = createEmptyPipeline;
  var ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);

  class HttpPipeline {
    constructor(policies) {
      var _a;
      this._policies = [];
      this._policies = (_a = policies === null || policies === undefined ? undefined : policies.slice(0)) !== null && _a !== undefined ? _a : [];
      this._orderedPolicies = undefined;
    }
    addPolicy(policy, options3 = {}) {
      if (options3.phase && options3.afterPhase) {
        throw new Error("Policies inside a phase cannot specify afterPhase.");
      }
      if (options3.phase && !ValidPhaseNames.has(options3.phase)) {
        throw new Error(`Invalid phase name: ${options3.phase}`);
      }
      if (options3.afterPhase && !ValidPhaseNames.has(options3.afterPhase)) {
        throw new Error(`Invalid afterPhase name: ${options3.afterPhase}`);
      }
      this._policies.push({
        policy,
        options: options3
      });
      this._orderedPolicies = undefined;
    }
    removePolicy(options3) {
      const removedPolicies = [];
      this._policies = this._policies.filter((policyDescriptor) => {
        if (options3.name && policyDescriptor.policy.name === options3.name || options3.phase && policyDescriptor.options.phase === options3.phase) {
          removedPolicies.push(policyDescriptor.policy);
          return false;
        } else {
          return true;
        }
      });
      this._orderedPolicies = undefined;
      return removedPolicies;
    }
    sendRequest(httpClient, request) {
      const policies = this.getOrderedPolicies();
      const pipeline4 = policies.reduceRight((next, policy) => {
        return (req) => {
          return policy.sendRequest(req, next);
        };
      }, (req) => httpClient.sendRequest(req));
      return pipeline4(request);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies) {
        this._orderedPolicies = this.orderPolicies();
      }
      return this._orderedPolicies;
    }
    clone() {
      return new HttpPipeline(this._policies);
    }
    static create() {
      return new HttpPipeline;
    }
    orderPolicies() {
      const result5 = [];
      const policyMap = new Map;
      function createPhase(name) {
        return {
          name,
          policies: new Set,
          hasRun: false,
          hasAfterPolicies: false
        };
      }
      const serializePhase = createPhase("Serialize");
      const noPhase = createPhase("None");
      const deserializePhase = createPhase("Deserialize");
      const retryPhase = createPhase("Retry");
      const signPhase = createPhase("Sign");
      const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      function getPhase(phase) {
        if (phase === "Retry") {
          return retryPhase;
        } else if (phase === "Serialize") {
          return serializePhase;
        } else if (phase === "Deserialize") {
          return deserializePhase;
        } else if (phase === "Sign") {
          return signPhase;
        } else {
          return noPhase;
        }
      }
      for (const descriptor of this._policies) {
        const policy = descriptor.policy;
        const options3 = descriptor.options;
        const policyName = policy.name;
        if (policyMap.has(policyName)) {
          throw new Error("Duplicate policy names not allowed in pipeline");
        }
        const node3 = {
          policy,
          dependsOn: new Set,
          dependants: new Set
        };
        if (options3.afterPhase) {
          node3.afterPhase = getPhase(options3.afterPhase);
          node3.afterPhase.hasAfterPolicies = true;
        }
        policyMap.set(policyName, node3);
        const phase = getPhase(options3.phase);
        phase.policies.add(node3);
      }
      for (const descriptor of this._policies) {
        const { policy, options: options3 } = descriptor;
        const policyName = policy.name;
        const node3 = policyMap.get(policyName);
        if (!node3) {
          throw new Error(`Missing node for policy ${policyName}`);
        }
        if (options3.afterPolicies) {
          for (const afterPolicyName of options3.afterPolicies) {
            const afterNode = policyMap.get(afterPolicyName);
            if (afterNode) {
              node3.dependsOn.add(afterNode);
              afterNode.dependants.add(node3);
            }
          }
        }
        if (options3.beforePolicies) {
          for (const beforePolicyName of options3.beforePolicies) {
            const beforeNode = policyMap.get(beforePolicyName);
            if (beforeNode) {
              beforeNode.dependsOn.add(node3);
              node3.dependants.add(beforeNode);
            }
          }
        }
      }
      function walkPhase(phase) {
        phase.hasRun = true;
        for (const node3 of phase.policies) {
          if (node3.afterPhase && (!node3.afterPhase.hasRun || node3.afterPhase.policies.size)) {
            continue;
          }
          if (node3.dependsOn.size === 0) {
            result5.push(node3.policy);
            for (const dependant of node3.dependants) {
              dependant.dependsOn.delete(node3);
            }
            policyMap.delete(node3.policy.name);
            phase.policies.delete(node3);
          }
        }
      }
      function walkPhases() {
        for (const phase of orderedPhases) {
          walkPhase(phase);
          if (phase.policies.size > 0 && phase !== noPhase) {
            if (!noPhase.hasRun) {
              walkPhase(noPhase);
            }
            return;
          }
          if (phase.hasAfterPolicies) {
            walkPhase(noPhase);
          }
        }
      }
      let iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        const initialResultLength = result5.length;
        walkPhases();
        if (result5.length <= initialResultLength && iteration > 1) {
          throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
      }
      return result5;
    }
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values2;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i2 = 1, n2 = arguments.length;i2 < n2; i2++) {
        s = arguments[i2];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
          if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
            t[p[i2]] = s[p[i2]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d = decorators[i2])
            r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result5 = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result5 === undefined)
            continue;
          if (result5 === null || typeof result5 !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result5.get))
            descriptor.get = _;
          if (_ = accept(result5.set))
            descriptor.set = _;
          if (_ = accept(result5.init))
            initializers.unshift(_);
        } else if (_ = accept(result5)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0;i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator4) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject4) {
        function fulfilled(value) {
          try {
            step(generator4.next(value));
          } catch (e) {
            reject4(e);
          }
        }
        function rejected(value) {
          try {
            step(generator4["throw"](value));
          } catch (e) {
            reject4(e);
          }
        }
        function step(result5) {
          result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
        }
        step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o2, p))
          __createBinding(o2, m, p);
    };
    __createBinding = Object.create ? function(o2, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o2[k2] = m[k];
    };
    __values2 = function(o2) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o2[s], i2 = 0;
      if (m)
        return m.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = undefined;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o2, n2) {
      var m = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m)
        return o2;
      var i2 = m.call(o2), r, ar = [], e;
      try {
        while ((n2 === undefined || n2-- > 0) && !(r = i2.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k = 0, i2 = 0;i2 < il; i2++)
        for (var a2 = arguments[i2], j = 0, jl = a2.length;j < jl; j++, k++)
          r[k] = a2[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l = from.length, ar;i2 < l; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator4) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator4.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject4);
        };
      }
      function verb(n2, f) {
        if (g[n2]) {
          i2[n2] = function(v) {
            return new Promise(function(a2, b) {
              q.push([n2, v, a2, b]) > 1 || resume(n2, v);
            });
          };
          if (f)
            i2[n2] = f(i2[n2]);
        }
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject4) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject4(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p;
      return i2 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f) {
        i2[n2] = o2[n2] ? function(v) {
          return (p = !p) ? { value: __await(o2[n2](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o2[Symbol.asyncIterator], i2;
      return m ? m.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve, reject4) {
            v = o2[n2](v), settle(resolve, reject4, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject4, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject4);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result5 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result5, mod, k);
      }
      __setModuleDefault(result5, mod);
      return result5;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message2) {
      var e = new Error(message2);
      return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result5 = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result5).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// node_modules/@azure/logger/dist/commonjs/log.js
var require_log = __commonJS((exports) => {
  function log6(message2, ...args) {
    process10.stderr.write(`${node_util_1.default.format(message2, ...args)}${node_os_1.EOL}`);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.log = log6;
  var tslib_1 = require_tslib();
  var node_os_1 = __require("node:os");
  var node_util_1 = tslib_1.__importDefault(__require("node:util"));
  var process10 = tslib_1.__importStar(__require("node:process"));
});

// node_modules/@azure/logger/dist/commonjs/debug.js
var require_debug = __commonJS((exports) => {
  function enable(namespaces) {
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    const wildcard = /\*/g;
    const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
    for (const ns of namespaceList) {
      if (ns.startsWith("-")) {
        skippedNamespaces.push(new RegExp(`^${ns.substr(1)}\$`));
      } else {
        enabledNamespaces.push(new RegExp(`^${ns}\$`));
      }
    }
    for (const instance of debuggers) {
      instance.enabled = enabled(instance.namespace);
    }
  }
  function enabled(namespace) {
    if (namespace.endsWith("*")) {
      return true;
    }
    for (const skipped of skippedNamespaces) {
      if (skipped.test(namespace)) {
        return false;
      }
    }
    for (const enabledNamespace of enabledNamespaces) {
      if (enabledNamespace.test(namespace)) {
        return true;
      }
    }
    return false;
  }
  function disable() {
    const result5 = enabledString || "";
    enable("");
    return result5;
  }
  function createDebugger(namespace) {
    const newDebugger = Object.assign(debug, {
      enabled: enabled(namespace),
      destroy,
      log: debugObj.log,
      namespace,
      extend
    });
    function debug(...args) {
      if (!newDebugger.enabled) {
        return;
      }
      if (args.length > 0) {
        args[0] = `${namespace} ${args[0]}`;
      }
      newDebugger.log(...args);
    }
    debuggers.push(newDebugger);
    return newDebugger;
  }
  function destroy() {
    const index = debuggers.indexOf(this);
    if (index >= 0) {
      debuggers.splice(index, 1);
      return true;
    }
    return false;
  }
  function extend(namespace) {
    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var log_js_1 = require_log();
  var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || undefined;
  var enabledString;
  var enabledNamespaces = [];
  var skippedNamespaces = [];
  var debuggers = [];
  if (debugEnvVariable) {
    enable(debugEnvVariable);
  }
  var debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
  }, {
    enable,
    enabled,
    disable,
    log: log_js_1.log
  });
  exports.default = debugObj;
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  function setLogLevel(level) {
    if (level && !isAzureLogLevel(level)) {
      throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    }
    azureLogLevel = level;
    const enabledNamespaces = [];
    for (const logger of registeredLoggers) {
      if (shouldEnable(logger)) {
        enabledNamespaces.push(logger.namespace);
      }
    }
    debug_js_1.default.enable(enabledNamespaces.join(","));
  }
  function getLogLevel() {
    return azureLogLevel;
  }
  function createClientLogger(namespace) {
    const clientRootLogger = exports.AzureLogger.extend(namespace);
    patchLogMethod(exports.AzureLogger, clientRootLogger);
    return {
      error: createLogger(clientRootLogger, "error"),
      warning: createLogger(clientRootLogger, "warning"),
      info: createLogger(clientRootLogger, "info"),
      verbose: createLogger(clientRootLogger, "verbose")
    };
  }
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
      level
    });
    patchLogMethod(parent, logger);
    if (shouldEnable(logger)) {
      const enabledNamespaces = debug_js_1.default.disable();
      debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
    }
    registeredLoggers.add(logger);
    return logger;
  }
  function shouldEnable(logger) {
    return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
  }
  function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureLogger = undefined;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var tslib_1 = require_tslib();
  var debug_js_1 = tslib_1.__importDefault(require_debug());
  var registeredLoggers = new Set;
  var logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || undefined;
  var azureLogLevel;
  exports.AzureLogger = (0, debug_js_1.default)("azure");
  exports.AzureLogger.log = (...args) => {
    debug_js_1.default.log(...args);
  };
  var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
  if (logLevelFromEnv) {
    if (isAzureLogLevel(logLevelFromEnv)) {
      setLogLevel(logLevelFromEnv);
    } else {
      console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
    }
  }
  var levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs();
  exports.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS((exports) => {
  function createAbortablePromise(buildPromise, options3) {
    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options3 !== null && options3 !== undefined ? options3 : {};
    return new Promise((resolve, reject4) => {
      function rejectOnAbort() {
        reject4(new abort_controller_1.AbortError(abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal === null || abortSignal === undefined || abortSignal.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort === null || cleanupBeforeAbort === undefined || cleanupBeforeAbort();
        removeListeners();
        rejectOnAbort();
      }
      if (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted) {
        return rejectOnAbort();
      }
      try {
        buildPromise((x) => {
          removeListeners();
          resolve(x);
        }, (x) => {
          removeListeners();
          reject4(x);
        });
      } catch (err) {
        reject4(err);
      }
      abortSignal === null || abortSignal === undefined || abortSignal.addEventListener("abort", onAbort);
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createAbortablePromise = createAbortablePromise;
  var abort_controller_1 = require_commonjs2();
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay = __commonJS((exports) => {
  function delay(timeInMs, options3) {
    let token;
    const { abortSignal, abortErrorMsg } = options3 !== null && options3 !== undefined ? options3 : {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : StandardAbortMessage
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay;
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  var StandardAbortMessage = "The delay was aborted.";
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS((exports) => {
  async function cancelablePromiseRace(abortablePromiseBuilders, options3) {
    var _a, _b;
    const aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    (_a = options3 === null || options3 === undefined ? undefined : options3.abortSignal) === null || _a === undefined || _a.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort();
      (_b = options3 === null || options3 === undefined ? undefined : options3.abortSignal) === null || _b === undefined || _b.removeEventListener("abort", abortHandler);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cancelablePromiseRace = cancelablePromiseRace;
});

// node_modules/@azure/core-util/dist/commonjs/random.js
var require_random = __commonJS((exports) => {
  function getRandomIntegerInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
});

// node_modules/@azure/core-util/dist/commonjs/object.js
var require_object = __commonJS((exports) => {
  function isObject2(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObject = isObject2;
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error = __commonJS((exports) => {
  function isError(e) {
    if ((0, object_js_1.isObject)(e)) {
      const hasName = typeof e.name === "string";
      const hasMessage = typeof e.message === "string";
      return hasName && hasMessage;
    }
    return false;
  }
  function getErrorMessage(e) {
    if (isError(e)) {
      return e.message;
    } else {
      let stringified;
      try {
        if (typeof e === "object" && e) {
          stringified = JSON.stringify(e);
        } else {
          stringified = String(e);
        }
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isError = isError;
  exports.getErrorMessage = getErrorMessage;
  var object_js_1 = require_object();
});

// node_modules/@azure/core-util/dist/commonjs/sha256.js
var require_sha256 = __commonJS((exports) => {
  async function computeSha256Hmac(key, stringToSign, encoding) {
    const decodedKey = Buffer.from(key, "base64");
    return (0, crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  async function computeSha256Hash(content, encoding) {
    return (0, crypto_1.createHash)("sha256").update(content).digest(encoding);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.computeSha256Hash = computeSha256Hash;
  var crypto_1 = __require("crypto");
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards = __commonJS((exports) => {
  function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") {
      return false;
    }
    for (const property of properties) {
      if (!objectHasProperty(thing, property)) {
        return false;
      }
    }
    return true;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDefined = isDefined;
  exports.isObjectWithProperties = isObjectWithProperties;
  exports.objectHasProperty = objectHasProperty;
});

// node_modules/@azure/core-util/dist/commonjs/uuidUtils.js
var require_uuidUtils = __commonJS((exports) => {
  function randomUUID() {
    return uuidFunction();
  }
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomUUID = randomUUID;
  var crypto_1 = __require("crypto");
  var uuidFunction = typeof ((_a = globalThis === null || globalThis === undefined ? undefined : globalThis.crypto) === null || _a === undefined ? undefined : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : crypto_1.randomUUID;
});

// node_modules/@azure/core-util/dist/commonjs/checkEnvironment.js
var require_checkEnvironment = __commonJS((exports) => {
  var _a;
  var _b;
  var _c;
  var _d;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReactNative = exports.isNodeRuntime = exports.isNode = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = undefined;
  exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  exports.isWebWorker = typeof self === "object" && typeof (self === null || self === undefined ? undefined : self.importScripts) === "function" && (((_a = self.constructor) === null || _a === undefined ? undefined : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === undefined ? undefined : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === undefined ? undefined : _c.name) === "SharedWorkerGlobalScope");
  exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === undefined ? undefined : _d.node);
  exports.isNode = exports.isNodeLike;
  exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
  exports.isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === undefined ? undefined : navigator.product) === "ReactNative";
});

// node_modules/@azure/core-util/dist/commonjs/bytesEncoding.js
var require_bytesEncoding = __commonJS((exports) => {
  function uint8ArrayToString2(bytes, format2) {
    return Buffer.from(bytes).toString(format2);
  }
  function stringToUint8Array2(value, format2) {
    return Buffer.from(value, format2);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint8ArrayToString = uint8ArrayToString2;
  exports.stringToUint8Array = stringToUint8Array2;
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringToUint8Array = exports.uint8ArrayToString = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isBun = exports.isBrowser = exports.randomUUID = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.computeSha256Hmac = exports.computeSha256Hash = exports.getErrorMessage = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.createAbortablePromise = exports.cancelablePromiseRace = exports.delay = undefined;
  var delay_js_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_js_1.delay;
  } });
  var aborterUtils_js_1 = require_aborterUtils();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: true, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: true, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var random_js_1 = require_random();
  Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: true, get: function() {
    return random_js_1.getRandomIntegerInclusive;
  } });
  var object_js_1 = require_object();
  Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
    return object_js_1.isObject;
  } });
  var error_js_1 = require_error();
  Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
    return error_js_1.isError;
  } });
  Object.defineProperty(exports, "getErrorMessage", { enumerable: true, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var sha256_js_1 = require_sha256();
  Object.defineProperty(exports, "computeSha256Hash", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hash;
  } });
  Object.defineProperty(exports, "computeSha256Hmac", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hmac;
  } });
  var typeGuards_js_1 = require_typeGuards();
  Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: true, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: true, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  var uuidUtils_js_1 = require_uuidUtils();
  Object.defineProperty(exports, "randomUUID", { enumerable: true, get: function() {
    return uuidUtils_js_1.randomUUID;
  } });
  var checkEnvironment_js_1 = require_checkEnvironment();
  Object.defineProperty(exports, "isBrowser", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBrowser;
  } });
  Object.defineProperty(exports, "isBun", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBun;
  } });
  Object.defineProperty(exports, "isNode", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNode;
  } });
  Object.defineProperty(exports, "isNodeLike", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeLike;
  } });
  Object.defineProperty(exports, "isNodeRuntime", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeRuntime;
  } });
  Object.defineProperty(exports, "isDeno", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isDeno;
  } });
  Object.defineProperty(exports, "isReactNative", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isReactNative;
  } });
  Object.defineProperty(exports, "isWebWorker", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isWebWorker;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Sanitizer = undefined;
  var core_util_1 = require_commonjs3();
  var RedactedString = "REDACTED";
  var defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
  ];
  var defaultAllowedQueryParameters = ["api-version"];

  class Sanitizer {
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
      allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
      allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
      this.allowedHeaderNames = new Set(allowedHeaderNames.map((n2) => n2.toLowerCase()));
      this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    sanitize(obj) {
      const seen = new Set;
      return JSON.stringify(obj, (key, value) => {
        if (value instanceof Error) {
          return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
        }
        if (key === "headers") {
          return this.sanitizeHeaders(value);
        } else if (key === "url") {
          return this.sanitizeUrl(value);
        } else if (key === "query") {
          return this.sanitizeQuery(value);
        } else if (key === "body") {
          return;
        } else if (key === "response") {
          return;
        } else if (key === "operationSpec") {
          return;
        } else if (Array.isArray(value) || (0, core_util_1.isObject)(value)) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      }, 2);
    }
    sanitizeUrl(value) {
      if (typeof value !== "string" || value === null || value === "") {
        return value;
      }
      const url = new URL(value);
      if (!url.search) {
        return value;
      }
      for (const [key] of url.searchParams) {
        if (!this.allowedQueryParameters.has(key.toLowerCase())) {
          url.searchParams.set(key, RedactedString);
        }
      }
      return url.toString();
    }
    sanitizeHeaders(obj) {
      const sanitized = {};
      for (const key of Object.keys(obj)) {
        if (this.allowedHeaderNames.has(key.toLowerCase())) {
          sanitized[key] = obj[key];
        } else {
          sanitized[key] = RedactedString;
        }
      }
      return sanitized;
    }
    sanitizeQuery(value) {
      if (typeof value !== "object" || value === null) {
        return value;
      }
      const sanitized = {};
      for (const k of Object.keys(value)) {
        if (this.allowedQueryParameters.has(k.toLowerCase())) {
          sanitized[k] = value[k];
        } else {
          sanitized[k] = RedactedString;
        }
      }
      return sanitized;
    }
  }
  exports.Sanitizer = Sanitizer;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS((exports) => {
  function logPolicy(options3 = {}) {
    var _a;
    const logger = (_a = options3.logger) !== null && _a !== undefined ? _a : log_js_1.logger.info;
    const sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedHeaderNames: options3.additionalAllowedHeaderNames,
      additionalAllowedQueryParameters: options3.additionalAllowedQueryParameters
    });
    return {
      name: exports.logPolicyName,
      async sendRequest(request, next) {
        if (!logger.enabled) {
          return next(request);
        }
        logger(`Request: ${sanitizer.sanitize(request)}`);
        const response = await next(request);
        logger(`Response status code: ${response.status}`);
        logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
        return response;
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logPolicyName = undefined;
  exports.logPolicy = logPolicy;
  var log_js_1 = require_log2();
  var sanitizer_js_1 = require_sanitizer();
  exports.logPolicyName = "logPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS((exports) => {
  function redirectPolicy(options3 = {}) {
    const { maxRetries = 20 } = options3;
    return {
      name: exports.redirectPolicyName,
      async sendRequest(request, next) {
        const response = await next(request);
        return handleRedirect(next, response, maxRetries);
      }
    };
  }
  async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    const { request, status, headers } = response;
    const locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
      const url = new URL(locationHeader, request.url);
      request.url = url.toString();
      if (status === 303) {
        request.method = "GET";
        request.headers.delete("Content-Length");
        delete request.body;
      }
      request.headers.delete("Authorization");
      const res = await next(request);
      return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redirectPolicyName = undefined;
  exports.redirectPolicy = redirectPolicy;
  exports.redirectPolicyName = "redirectPolicy";
  var allowedRedirect = ["GET", "HEAD"];
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS((exports) => {
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (process10 && process10.versions) {
      const versions = process10.versions;
      if (versions.bun) {
        map.set("Bun", versions.bun);
      } else if (versions.deno) {
        map.set("Deno", versions.deno);
      } else if (versions.node) {
        map.set("Node", versions.node);
      }
    }
    map.set("OS", `(${os.arch()}-${os.type()}-${os.release()})`);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeaderName = getHeaderName;
  exports.setPlatformSpecificData = setPlatformSpecificData;
  var tslib_1 = require_tslib();
  var os = tslib_1.__importStar(__require("node:os"));
  var process10 = tslib_1.__importStar(__require("node:process"));
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "1.16.3";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS((exports) => {
  function getUserAgentString(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    const runtimeInfo = new Map;
    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentHeaderName = getUserAgentHeaderName;
  exports.getUserAgentValue = getUserAgentValue;
  var userAgentPlatform_js_1 = require_userAgentPlatform();
  var constants_js_1 = require_constants7();
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS((exports) => {
  function userAgentPolicy(options3 = {}) {
    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options3.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(UserAgentHeaderName)) {
          request.headers.set(UserAgentHeaderName, await userAgentValue);
        }
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = undefined;
  exports.userAgentPolicy = userAgentPolicy;
  var userAgent_js_1 = require_userAgent();
  var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/typeGuards.js
var require_typeGuards2 = __commonJS((exports) => {
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x["pipe"] === "function");
  }
  function isWebReadableStream(x) {
    return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
  }
  function isReadableStream3(x) {
    return isNodeReadableStream(x) || isWebReadableStream(x);
  }
  function isBlob(x) {
    return typeof x.stream === "function";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadableStream = isNodeReadableStream;
  exports.isWebReadableStream = isWebReadableStream;
  exports.isReadableStream = isReadableStream3;
  exports.isBlob = isBlob;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file2 = __commonJS((exports) => {
  function hasRawContent(x) {
    return typeof x[rawContent] === "function";
  }
  function getRawContent(blob) {
    if (hasRawContent(blob)) {
      return blob[rawContent]();
    } else {
      return blob.stream();
    }
  }
  function createFileFromStream(stream3, name, options3 = {}) {
    var _a, _b, _c, _d;
    return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options3.type) !== null && _a !== undefined ? _a : "", lastModified: (_b = options3.lastModified) !== null && _b !== undefined ? _b : new Date().getTime(), webkitRelativePath: (_c = options3.webkitRelativePath) !== null && _c !== undefined ? _c : "", size: (_d = options3.size) !== null && _d !== undefined ? _d : -1, name, stream: () => {
      const s = stream3();
      if ((0, typeGuards_js_1.isNodeReadableStream)(s)) {
        throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
      }
      return s;
    }, [rawContent]: stream3 });
  }
  function createFile(content, name, options3 = {}) {
    var _a, _b, _c;
    if (core_util_1.isNodeLike) {
      return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options3.type) !== null && _a !== undefined ? _a : "", lastModified: (_b = options3.lastModified) !== null && _b !== undefined ? _b : new Date().getTime(), webkitRelativePath: (_c = options3.webkitRelativePath) !== null && _c !== undefined ? _c : "", size: content.byteLength, name, arrayBuffer: async () => content.buffer, stream: () => new Blob([content]).stream(), [rawContent]: () => content });
    } else {
      return new File([content], name, options3);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRawContent = getRawContent;
  exports.createFileFromStream = createFileFromStream;
  exports.createFile = createFile;
  var core_util_1 = require_commonjs3();
  var typeGuards_js_1 = require_typeGuards2();
  var unimplementedMethods = {
    arrayBuffer: () => {
      throw new Error("Not implemented");
    },
    slice: () => {
      throw new Error("Not implemented");
    },
    text: () => {
      throw new Error("Not implemented");
    }
  };
  var rawContent = Symbol("rawContent");
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/concat.js
var require_concat = __commonJS((exports) => {
  function streamAsyncIterator() {
    return tslib_1.__asyncGenerator(this, arguments, function* streamAsyncIterator_1() {
      const reader = this.getReader();
      try {
        while (true) {
          const { done, value } = yield tslib_1.__await(reader.read());
          if (done) {
            return yield tslib_1.__await(undefined);
          }
          yield yield tslib_1.__await(value);
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
  function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
      webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
    }
    if (!webStream.values) {
      webStream.values = streamAsyncIterator.bind(webStream);
    }
  }
  function ensureNodeStream(stream3) {
    if (stream3 instanceof ReadableStream) {
      makeAsyncIterable(stream3);
      return node_stream_1.Readable.fromWeb(stream3);
    } else {
      return stream3;
    }
  }
  function toStream(source) {
    if (source instanceof Uint8Array) {
      return node_stream_1.Readable.from(Buffer.from(source));
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return toStream((0, file_js_1.getRawContent)(source));
    } else {
      return ensureNodeStream(source);
    }
  }
  async function concat(sources) {
    return function() {
      const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
      return node_stream_1.Readable.from(function() {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
          var _a, e_1, _b, _c;
          for (const stream3 of streams) {
            try {
              for (var _d = true, stream_1 = (e_1 = undefined, tslib_1.__asyncValues(stream3)), stream_1_1;stream_1_1 = yield tslib_1.__await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true) {
                _c = stream_1_1.value;
                _d = false;
                const chunk = _c;
                yield yield tslib_1.__await(chunk);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = stream_1.return))
                  yield tslib_1.__await(_b.call(stream_1));
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      }());
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = concat;
  var tslib_1 = require_tslib();
  var node_stream_1 = __require("node:stream");
  var typeGuards_js_1 = require_typeGuards2();
  var file_js_1 = require_file2();
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS((exports) => {
  function generateBoundary() {
    return `----AzSDKFormBoundary${(0, core_util_1.randomUUID)()}`;
  }
  function encodeHeaders(headers) {
    let result5 = "";
    for (const [key, value] of headers) {
      result5 += `${key}: ${value}\r\n`;
    }
    return result5;
  }
  function getLength(source) {
    if (source instanceof Uint8Array) {
      return source.byteLength;
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return source.size === -1 ? undefined : source.size;
    } else {
      return;
    }
  }
  function getTotalLength(sources) {
    let total = 0;
    for (const source of sources) {
      const partLength = getLength(source);
      if (partLength === undefined) {
        return;
      } else {
        total += partLength;
      }
    }
    return total;
  }
  async function buildRequestBody(request, parts, boundary) {
    const sources = [
      (0, core_util_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
      ...parts.flatMap((part) => [
        (0, core_util_1.stringToUint8Array)("\r\n", "utf-8"),
        (0, core_util_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
        (0, core_util_1.stringToUint8Array)("\r\n", "utf-8"),
        part.body,
        (0, core_util_1.stringToUint8Array)(`\r\n--${boundary}`, "utf-8")
      ]),
      (0, core_util_1.stringToUint8Array)("--\r\n\r\n", "utf-8")
    ];
    const contentLength = getTotalLength(sources);
    if (contentLength) {
      request.headers.set("Content-Length", contentLength);
    }
    request.body = await (0, concat_js_1.concat)(sources);
  }
  function assertValidBoundary(boundary) {
    if (boundary.length > maxBoundaryLength) {
      throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
    }
    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
      throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
    }
  }
  function multipartPolicy() {
    return {
      name: exports.multipartPolicyName,
      async sendRequest(request, next) {
        var _a;
        if (!request.multipartBody) {
          return next(request);
        }
        if (request.body) {
          throw new Error("multipartBody and regular body cannot be set at the same time");
        }
        let boundary = request.multipartBody.boundary;
        const contentTypeHeader = (_a = request.headers.get("Content-Type")) !== null && _a !== undefined ? _a : "multipart/mixed";
        const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
        if (!parsedHeader) {
          throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
        }
        const [, contentType, parsedBoundary] = parsedHeader;
        if (parsedBoundary && boundary && parsedBoundary !== boundary) {
          throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
        }
        boundary !== null && boundary !== undefined || (boundary = parsedBoundary);
        if (boundary) {
          assertValidBoundary(boundary);
        } else {
          boundary = generateBoundary();
        }
        request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
        await buildRequestBody(request, request.multipartBody.parts, boundary);
        request.multipartBody = undefined;
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multipartPolicyName = undefined;
  exports.multipartPolicy = multipartPolicy;
  var core_util_1 = require_commonjs3();
  var concat_js_1 = require_concat();
  var typeGuards_js_1 = require_typeGuards2();
  exports.multipartPolicyName = "multipartPolicy";
  var maxBoundaryLength = 70;
  var validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS((exports) => {
  function decompressResponsePolicy() {
    return {
      name: exports.decompressResponsePolicyName,
      async sendRequest(request, next) {
        if (request.method !== "HEAD") {
          request.headers.set("Accept-Encoding", "gzip,deflate");
        }
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponsePolicyName = undefined;
  exports.decompressResponsePolicy = decompressResponsePolicy;
  exports.decompressResponsePolicyName = "decompressResponsePolicy";
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError2();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/helpers.js
var require_helpers = __commonJS((exports) => {
  function delay(delayInMs, value, options3) {
    return new Promise((resolve, reject4) => {
      let timer = undefined;
      let onAborted = undefined;
      const rejectOnAbort = () => {
        return reject4(new abort_controller_1.AbortError((options3 === null || options3 === undefined ? undefined : options3.abortErrorMsg) ? options3 === null || options3 === undefined ? undefined : options3.abortErrorMsg : StandardAbortMessage));
      };
      const removeListeners = () => {
        if ((options3 === null || options3 === undefined ? undefined : options3.abortSignal) && onAborted) {
          options3.abortSignal.removeEventListener("abort", onAborted);
        }
      };
      onAborted = () => {
        if (timer) {
          clearTimeout(timer);
        }
        removeListeners();
        return rejectOnAbort();
      };
      if ((options3 === null || options3 === undefined ? undefined : options3.abortSignal) && options3.abortSignal.aborted) {
        return rejectOnAbort();
      }
      timer = setTimeout(() => {
        removeListeners();
        resolve(value);
      }, delayInMs);
      if (options3 === null || options3 === undefined ? undefined : options3.abortSignal) {
        options3.abortSignal.addEventListener("abort", onAborted);
      }
    });
  }
  function parseHeaderValueAsNumber(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value)
      return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
      return;
    return valueAsNum;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay;
  exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
  var abort_controller_1 = require_commonjs4();
  var StandardAbortMessage = "The operation was aborted.";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS((exports) => {
  function getRetryAfterInMs(response) {
    if (!(response && [429, 503].includes(response.status)))
      return;
    try {
      for (const header of AllRetryAfterHeaders) {
        const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
        if (retryAfterValue === 0 || retryAfterValue) {
          const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
          return retryAfterValue * multiplyingFactor;
        }
      }
      const retryAfterHeader = response.headers.get(RetryAfterHeader);
      if (!retryAfterHeader)
        return;
      const date = Date.parse(retryAfterHeader);
      const diff = date - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    } catch (e) {
      return;
    }
  }
  function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
  }
  function throttlingRetryStrategy() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response }) {
        const retryAfterInMs = getRetryAfterInMs(response);
        if (!Number.isFinite(retryAfterInMs)) {
          return { skipStrategy: true };
        }
        return {
          retryAfterInMs
        };
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
  exports.throttlingRetryStrategy = throttlingRetryStrategy;
  var helpers_js_1 = require_helpers();
  var RetryAfterHeader = "Retry-After";
  var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS((exports) => {
  function exponentialRetryStrategy(options3 = {}) {
    var _a, _b;
    const retryInterval = (_a = options3.retryDelayInMs) !== null && _a !== undefined ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
    const maxRetryInterval = (_b = options3.maxRetryDelayInMs) !== null && _b !== undefined ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    let retryAfterInMs = retryInterval;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount, response, responseError }) {
        const matchedSystemError = isSystemError(responseError);
        const ignoreSystemErrors = matchedSystemError && options3.ignoreSystemErrors;
        const isExponential = isExponentialRetryResponse(response);
        const ignoreExponentialResponse = isExponential && options3.ignoreHttpStatusCodes;
        const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
        if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
          return { skipStrategy: true };
        }
        if (responseError && !matchedSystemError && !isExponential) {
          return { errorToThrow: responseError };
        }
        const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
        const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
        retryAfterInMs = clampedExponentialDelay / 2 + (0, core_util_1.getRandomIntegerInclusive)(0, clampedExponentialDelay / 2);
        return { retryAfterInMs };
      }
    };
  }
  function isExponentialRetryResponse(response) {
    return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
  }
  function isSystemError(err) {
    if (!err) {
      return false;
    }
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryStrategy = exponentialRetryStrategy;
  exports.isExponentialRetryResponse = isExponentialRetryResponse;
  exports.isSystemError = isSystemError;
  var core_util_1 = require_commonjs3();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
  var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS((exports) => {
  function retryPolicy(strategies, options3 = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    const logger = options3.logger || retryPolicyLogger;
    return {
      name: retryPolicyName,
      async sendRequest(request, next) {
        var _a, _b;
        let response;
        let responseError;
        let retryCount = -1;
        retryRequest:
          while (true) {
            retryCount += 1;
            response = undefined;
            responseError = undefined;
            try {
              logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
              response = await next(request);
              logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
            } catch (e) {
              logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
              responseError = e;
              if (!e || responseError.name !== "RestError") {
                throw e;
              }
              response = responseError.response;
            }
            if ((_a = request.abortSignal) === null || _a === undefined ? undefined : _a.aborted) {
              logger.error(`Retry ${retryCount}: Request aborted.`);
              const abortError = new abort_controller_1.AbortError;
              throw abortError;
            }
            if (retryCount >= ((_b = options3.maxRetries) !== null && _b !== undefined ? _b : constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
              logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
              if (responseError) {
                throw responseError;
              } else if (response) {
                return response;
              } else {
                throw new Error("Maximum retries reached with no response or error to throw");
              }
            }
            logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
            strategiesLoop:
              for (const strategy of strategies) {
                const strategyLogger = strategy.logger || retryPolicyLogger;
                strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                const modifiers = strategy.retry({
                  retryCount,
                  response,
                  responseError
                });
                if (modifiers.skipStrategy) {
                  strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                  continue strategiesLoop;
                }
                const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                if (errorToThrow) {
                  strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                  throw errorToThrow;
                }
                if (retryAfterInMs || retryAfterInMs === 0) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                  await (0, helpers_js_1.delay)(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
                  continue retryRequest;
                }
                if (redirectTo) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                  request.url = redirectTo;
                  continue retryRequest;
                }
              }
            if (responseError) {
              logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
              throw responseError;
            }
            if (response) {
              logger.info(`None of the retry strategies could work with the received response. Returning it.`);
              return response;
            }
          }
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryPolicy = retryPolicy;
  var helpers_js_1 = require_helpers();
  var logger_1 = require_commonjs();
  var abort_controller_1 = require_commonjs4();
  var constants_js_1 = require_constants7();
  var retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
  var retryPolicyName = "retryPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS((exports) => {
  function defaultRetryPolicy(options3 = {}) {
    var _a;
    return {
      name: exports.defaultRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options3)], {
        maxRetries: (_a = options3.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryPolicyName = undefined;
  exports.defaultRetryPolicy = defaultRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.defaultRetryPolicyName = "defaultRetryPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS((exports) => {
  function normalizeName(name) {
    return name.toLowerCase();
  }
  function* headerIterator(map) {
    for (const entry of map.values()) {
      yield [entry.name, entry.value];
    }
  }
  function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpHeaders = createHttpHeaders;

  class HttpHeadersImpl {
    constructor(rawHeaders) {
      this._headersMap = new Map;
      if (rawHeaders) {
        for (const headerName of Object.keys(rawHeaders)) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(name, value) {
      this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
    }
    get(name) {
      var _a;
      return (_a = this._headersMap.get(normalizeName(name))) === null || _a === undefined ? undefined : _a.value;
    }
    has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    toJSON(options3 = {}) {
      const result5 = {};
      if (options3.preserveCase) {
        for (const entry of this._headersMap.values()) {
          result5[entry.name] = entry.value;
        }
      } else {
        for (const [normalizedName, entry] of this._headersMap) {
          result5[normalizedName] = entry.value;
        }
      }
      return result5;
    }
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    [Symbol.iterator]() {
      return headerIterator(this._headersMap);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS((exports) => {
  function formDataToFormDataMap(formData) {
    var _a;
    const formDataMap = {};
    for (const [key, value] of formData.entries()) {
      (_a = formDataMap[key]) !== null && _a !== undefined || (formDataMap[key] = []);
      formDataMap[key].push(value);
    }
    return formDataMap;
  }
  function formDataPolicy() {
    return {
      name: exports.formDataPolicyName,
      async sendRequest(request, next) {
        if (core_util_1.isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
          request.formData = formDataToFormDataMap(request.body);
          request.body = undefined;
        }
        if (request.formData) {
          const contentType = request.headers.get("Content-Type");
          if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
            request.body = wwwFormUrlEncode(request.formData);
          } else {
            await prepareFormData(request.formData, request);
          }
          request.formData = undefined;
        }
        return next(request);
      }
    };
  }
  function wwwFormUrlEncode(formData) {
    const urlSearchParams = new URLSearchParams;
    for (const [key, value] of Object.entries(formData)) {
      if (Array.isArray(value)) {
        for (const subValue of value) {
          urlSearchParams.append(key, subValue.toString());
        }
      } else {
        urlSearchParams.append(key, value.toString());
      }
    }
    return urlSearchParams.toString();
  }
  async function prepareFormData(formData, request) {
    const contentType = request.headers.get("Content-Type");
    if (contentType && !contentType.startsWith("multipart/form-data")) {
      return;
    }
    request.headers.set("Content-Type", contentType !== null && contentType !== undefined ? contentType : "multipart/form-data");
    const parts = [];
    for (const [fieldName, values8] of Object.entries(formData)) {
      for (const value of Array.isArray(values8) ? values8 : [values8]) {
        if (typeof value === "string") {
          parts.push({
            headers: (0, httpHeaders_js_1.createHttpHeaders)({
              "Content-Disposition": `form-data; name="${fieldName}"`
            }),
            body: (0, core_util_1.stringToUint8Array)(value, "utf-8")
          });
        } else if (value === undefined || value === null || typeof value !== "object") {
          throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
        } else {
          const fileName = value.name || "blob";
          const headers = (0, httpHeaders_js_1.createHttpHeaders)();
          headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
          headers.set("Content-Type", value.type || "application/octet-stream");
          parts.push({
            headers,
            body: value
          });
        }
      }
    }
    request.multipartBody = { parts };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formDataPolicyName = undefined;
  exports.formDataPolicy = formDataPolicy;
  var core_util_1 = require_commonjs3();
  var httpHeaders_js_1 = require_httpHeaders();
  exports.formDataPolicyName = "formDataPolicy";
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type15 = (match[2] || "ms").toLowerCase();
    switch (type15) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y;
      case "weeks":
      case "week":
      case "w":
        return n2 * w;
      case "days":
      case "day":
      case "d":
        return n2 * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
  }
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val2, options3) {
    options3 = options3 || {};
    var type15 = typeof val2;
    if (type15 === "string" && val2.length > 0) {
      return parse(val2);
    } else if (type15 === "number" && isFinite(val2)) {
      return options3.long ? fmtLong(val2) : fmtShort(val2);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val2));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup2(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val2 = args[index];
            match = formatter.call(self2, val2);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split4 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split4.length;
      for (i2 = 0;i2 < len; i2++) {
        if (!split4[i2]) {
          continue;
        }
        namespaces = split4[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length;i2 < len; i2++) {
        if (createDebug.skips[i2].test(name)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length;i2 < len; i2++) {
        if (createDebug.names[i2].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val2) {
      if (val2 instanceof Error) {
        return val2.stack || val2.message;
      }
      return val2;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup2;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c3 = "color: " + this.color;
    args.splice(1, 0, c3, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c3);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream3) {
    const level = supportsColor(stream3, stream3 && stream3.isTTY);
    return translateLevel(level);
  }
  var os = __require("os");
  var tty3 = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty3.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty3.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty3.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c3 = this.color;
      const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log6(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  var tty3 = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log6;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val2 = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val2)) {
      val2 = true;
    } else if (/^(no|off|false|disabled)$/i.test(val2)) {
      val2 = false;
    } else if (val2 === "null") {
      val2 = null;
    } else {
      val2 = Number(val2);
    }
    obj[prop] = val2;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS((exports) => {
  async function toBuffer(stream3) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream3) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  async function json(stream3) {
    const buf = await toBuffer(stream3);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
    const promise2 = new Promise((resolve, reject4) => {
      req2.once("response", resolve).once("error", reject4).end();
    });
    req2.then = promise2.then.bind(promise2);
    return req2;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  exports.toBuffer = toBuffer;
  exports.json = json;
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var net = __importStar(__require("net"));
  var http = __importStar(__require("http"));
  var https_1 = __require("https");
  __exportStar(require_helpers2(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options3) {
      if (options3) {
        if (typeof options3.secureEndpoint === "boolean") {
          return options3.secureEndpoint;
        }
        if (typeof options3.protocol === "string") {
          return options3.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    getName(options3) {
      const secureEndpoint = typeof options3.secureEndpoint === "boolean" ? options3.secureEndpoint : this.isSecureEndpoint(options3);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options3);
      }
      return super.getName(options3);
    }
    createSocket(req, options3, cb) {
      const connectOpts = {
        ...options3,
        secureEndpoint: this.isSecureEndpoint(options3)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http.Agent) {
          return socket.addRequest(req, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options3, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject4) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup2() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup2();
        debug("onend");
        reject4(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup2();
        debug("onerror %o", err);
        reject4(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject4(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject4(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug("got proxy server response: %o %o", firstLine, headers);
        cleanup2();
        resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS((exports) => {
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var assert_1 = __importDefault(__require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_dist2();
  var url_1 = __require("url");
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug = (0, debug_1.default)("https-proxy-agent");

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        const servername = this.connectOpts.servername || this.connectOpts.host;
        socket = tls.connect({
          ...this.connectOpts,
          servername
        });
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r\n`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r\n`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          const servername = opts.servername || opts.host;
          return tls.connect({
            ...omit(opts, "host", "path", "port"),
            socket,
            servername
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s) => {
        debug("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s.listenerCount("data") > 0);
        s.push(buffered);
        s.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist4 = __commonJS((exports) => {
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpProxyAgent = undefined;
  var net = __importStar(__require("net"));
  var tls = __importStar(__require("tls"));
  var debug_1 = __importDefault(require_src());
  var events_1 = __require("events");
  var agent_base_1 = require_dist2();
  var url_1 = __require("url");
  var debug = (0, debug_1.default)("http-proxy-agent");

  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null;
      this.setRequestProps(req, opts);
      super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      const { proxy } = this;
      const protocol = opts.secureEndpoint ? "https:" : "http:";
      const hostname = req.getHeader("host") || "localhost";
      const base = `${protocol}//${hostname}`;
      const url = new url_1.URL(req.path, base);
      if (opts.port !== 80) {
        url.port = String(opts.port);
      }
      req.path = String(url);
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        const value = headers[name];
        if (value) {
          req.setHeader(name, value);
        }
      }
    }
    async connect(req, opts) {
      req._header = null;
      if (!req.path.includes("://")) {
        this.setRequestProps(req, opts);
      }
      let first;
      let endOfHeaders;
      debug("Regenerating stored HTTP header string for request");
      req._implicitHeader();
      if (req.outputData && req.outputData.length > 0) {
        debug("Patching connection write() output buffer with updated header");
        first = req.outputData[0].data;
        endOfHeaders = first.indexOf("\r\n\r\n") + 4;
        req.outputData[0].data = req._header + first.substring(endOfHeaders);
        debug("Output buffer: %o", req.outputData[0].data);
      }
      let socket;
      if (this.proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(this.connectOpts);
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      await (0, events_1.once)(socket, "connect");
      return socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  exports.HttpProxyAgent = HttpProxyAgent;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS((exports) => {
  function getEnvironmentValue(name) {
    if (process.env[name]) {
      return process.env[name];
    } else if (process.env[name.toLowerCase()]) {
      return process.env[name.toLowerCase()];
    }
    return;
  }
  function loadEnvironmentProxyValue() {
    if (!process) {
      return;
    }
    const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
    const allProxy = getEnvironmentValue(ALL_PROXY);
    const httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
  }
  function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) {
      return false;
    }
    const host = new URL(uri).hostname;
    if (bypassedMap === null || bypassedMap === undefined ? undefined : bypassedMap.has(host)) {
      return bypassedMap.get(host);
    }
    let isBypassedFlag = false;
    for (const pattern of noProxyList) {
      if (pattern[0] === ".") {
        if (host.endsWith(pattern)) {
          isBypassedFlag = true;
        } else {
          if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
            isBypassedFlag = true;
          }
        }
      } else {
        if (host === pattern) {
          isBypassedFlag = true;
        }
      }
    }
    bypassedMap === null || bypassedMap === undefined || bypassedMap.set(host, isBypassedFlag);
    return isBypassedFlag;
  }
  function loadNoProxy() {
    const noProxy = getEnvironmentValue(NO_PROXY);
    noProxyListLoaded = true;
    if (noProxy) {
      return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
    }
    return [];
  }
  function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl) {
      proxyUrl = loadEnvironmentProxyValue();
      if (!proxyUrl) {
        return;
      }
    }
    const parsedUrl = new URL(proxyUrl);
    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
    return {
      host: schema + parsedUrl.hostname,
      port: Number.parseInt(parsedUrl.port || "80"),
      username: parsedUrl.username,
      password: parsedUrl.password
    };
  }
  function getDefaultProxySettingsInternal() {
    const envProxy = loadEnvironmentProxyValue();
    return envProxy ? new URL(envProxy) : undefined;
  }
  function getUrlFromProxySettings(settings) {
    let parsedProxyUrl;
    try {
      parsedProxyUrl = new URL(settings.host);
    } catch (_error) {
      throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
    }
    parsedProxyUrl.port = String(settings.port);
    if (settings.username) {
      parsedProxyUrl.username = settings.username;
    }
    if (settings.password) {
      parsedProxyUrl.password = settings.password;
    }
    return parsedProxyUrl;
  }
  function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
    if (request.agent) {
      return;
    }
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    if (request.tlsSettings) {
      log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    }
    const headers = request.headers.toJSON();
    if (isInsecure) {
      if (!cachedAgents.httpProxyAgent) {
        cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
      }
      request.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent) {
        cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
      }
      request.agent = cachedAgents.httpsProxyAgent;
    }
  }
  function proxyPolicy(proxySettings, options3) {
    if (!noProxyListLoaded) {
      exports.globalNoProxyList.push(...loadNoProxy());
    }
    const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
    const cachedAgents = {};
    return {
      name: exports.proxyPolicyName,
      async sendRequest(request, next) {
        var _a;
        if (!request.proxySettings && defaultProxy && !isBypassed(request.url, (_a = options3 === null || options3 === undefined ? undefined : options3.customNoProxyList) !== null && _a !== undefined ? _a : exports.globalNoProxyList, (options3 === null || options3 === undefined ? undefined : options3.customNoProxyList) ? undefined : globalBypassedMap)) {
          setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
        } else if (request.proxySettings) {
          setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
        }
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalNoProxyList = exports.proxyPolicyName = undefined;
  exports.loadNoProxy = loadNoProxy;
  exports.getDefaultProxySettings = getDefaultProxySettings;
  exports.proxyPolicy = proxyPolicy;
  var https_proxy_agent_1 = require_dist3();
  var http_proxy_agent_1 = require_dist4();
  var log_js_1 = require_log2();
  var HTTPS_PROXY = "HTTPS_PROXY";
  var HTTP_PROXY = "HTTP_PROXY";
  var ALL_PROXY = "ALL_PROXY";
  var NO_PROXY = "NO_PROXY";
  exports.proxyPolicyName = "proxyPolicy";
  exports.globalNoProxyList = [];
  var noProxyListLoaded = false;
  var globalBypassedMap = new Map;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS((exports) => {
  function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
      name: exports.setClientRequestIdPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(requestIdHeaderName)) {
          request.headers.set(requestIdHeaderName, request.requestId);
        }
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setClientRequestIdPolicyName = undefined;
  exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
  exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS((exports) => {
  function tlsPolicy(tlsSettings) {
    return {
      name: exports.tlsPolicyName,
      sendRequest: async (req, next) => {
        if (!req.tlsSettings) {
          req.tlsSettings = tlsSettings;
        }
        return next(req);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tlsPolicyName = undefined;
  exports.tlsPolicy = tlsPolicy;
  exports.tlsPolicyName = "tlsPolicy";
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS((exports) => {
  function createTracingContext(options3 = {}) {
    let context = new TracingContextImpl(options3.parentContext);
    if (options3.span) {
      context = context.setValue(exports.knownContextKeys.span, options3.span);
    }
    if (options3.namespace) {
      context = context.setValue(exports.knownContextKeys.namespace, options3.namespace);
    }
    return context;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TracingContextImpl = exports.createTracingContext = exports.knownContextKeys = undefined;
  exports.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  exports.createTracingContext = createTracingContext;

  class TracingContextImpl {
    constructor(initialContext) {
      this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : new Map;
    }
    setValue(key, value) {
      const newContext = new TracingContextImpl(this);
      newContext._contextMap.set(key, value);
      return newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      const newContext = new TracingContextImpl(this);
      newContext._contextMap.delete(key);
      return newContext;
    }
  }
  exports.TracingContextImpl = TracingContextImpl;
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    instrumenterImplementation: undefined
  };
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS((exports) => {
  function createDefaultTracingSpan() {
    return {
      end: () => {
      },
      isRecording: () => false,
      recordException: () => {
      },
      setAttribute: () => {
      },
      setStatus: () => {
      }
    };
  }
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter) {
    state_js_1.state.instrumenterImplementation = instrumenter;
  }
  function getInstrumenter() {
    if (!state_js_1.state.instrumenterImplementation) {
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
    }
    return state_js_1.state.instrumenterImplementation;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getInstrumenter = exports.useInstrumenter = exports.createDefaultInstrumenter = exports.createDefaultTracingSpan = undefined;
  var tracingContext_js_1 = require_tracingContext();
  var state_js_1 = require_state();
  exports.createDefaultTracingSpan = createDefaultTracingSpan;
  exports.createDefaultInstrumenter = createDefaultInstrumenter;
  exports.useInstrumenter = useInstrumenter;
  exports.getInstrumenter = getInstrumenter;
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS((exports) => {
  function createTracingClient(options3) {
    const { namespace, packageName, packageVersion } = options3;
    function startSpan(name, operationOptions, spanOptions) {
      var _a;
      const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions) === null || _a === undefined ? undefined : _a.tracingContext }));
      let tracingContext = startSpanResult.tracingContext;
      const span = startSpanResult.span;
      if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
        tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      }
      span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
      const updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions), { tracingContext })
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        const result5 = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        span.setStatus({ status: "success" });
        return result5;
      } catch (err) {
        span.setStatus({ status: "error", error: err });
        throw err;
      } finally {
        span.end();
      }
    }
    function withContext(context, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = undefined;
  var instrumenter_js_1 = require_instrumenter();
  var tracingContext_js_1 = require_tracingContext();
  exports.createTracingClient = createTracingClient;
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = exports.useInstrumenter = undefined;
  var instrumenter_js_1 = require_instrumenter();
  Object.defineProperty(exports, "useInstrumenter", { enumerable: true, get: function() {
    return instrumenter_js_1.useInstrumenter;
  } });
  var tracingClient_js_1 = require_tracingClient();
  Object.defineProperty(exports, "createTracingClient", { enumerable: true, get: function() {
    return tracingClient_js_1.createTracingClient;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/inspect.js
var require_inspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.custom = undefined;
  var node_util_1 = __require("node:util");
  exports.custom = node_util_1.inspect.custom;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError = __commonJS((exports) => {
  function isRestError(e) {
    if (e instanceof RestError) {
      return true;
    }
    return (0, core_util_1.isError)(e) && e.name === "RestError";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestError = undefined;
  exports.isRestError = isRestError;
  var core_util_1 = require_commonjs3();
  var inspect_js_1 = require_inspect();
  var sanitizer_js_1 = require_sanitizer();
  var errorSanitizer = new sanitizer_js_1.Sanitizer;

  class RestError extends Error {
    constructor(message2, options3 = {}) {
      super(message2);
      this.name = "RestError";
      this.code = options3.code;
      this.statusCode = options3.statusCode;
      Object.defineProperty(this, "request", { value: options3.request, enumerable: false });
      Object.defineProperty(this, "response", { value: options3.response, enumerable: false });
      Object.setPrototypeOf(this, RestError.prototype);
    }
    [inspect_js_1.custom]() {
      return `RestError: ${this.message} \n ${errorSanitizer.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;
    }
  }
  exports.RestError = RestError;
  RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  RestError.PARSE_ERROR = "PARSE_ERROR";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS((exports) => {
  function tracingPolicy(options3 = {}) {
    const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options3.userAgentPrefix);
    const sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedQueryParameters: options3.additionalAllowedQueryParameters
    });
    const tracingClient = tryCreateTracingClient();
    return {
      name: exports.tracingPolicyName,
      async sendRequest(request, next) {
        var _a, _b;
        if (!tracingClient || !((_a = request.tracingOptions) === null || _a === undefined ? undefined : _a.tracingContext)) {
          return next(request);
        }
        const userAgent = await userAgentPromise;
        const spanAttributes = {
          "http.url": sanitizer.sanitizeUrl(request.url),
          "http.method": request.method,
          "http.user_agent": userAgent,
          requestId: request.requestId
        };
        if (userAgent) {
          spanAttributes["http.user_agent"] = userAgent;
        }
        const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, spanAttributes)) !== null && _b !== undefined ? _b : {};
        if (!span || !tracingContext) {
          return next(request);
        }
        try {
          const response = await tracingClient.withContext(tracingContext, next, request);
          tryProcessResponse(span, response);
          return response;
        } catch (err) {
          tryProcessError(span, err);
          throw err;
        }
      }
    };
  }
  function tryCreateTracingClient() {
    try {
      return (0, core_tracing_1.createTracingClient)({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: constants_js_1.SDK_VERSION
      });
    } catch (e) {
      log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryCreateSpan(tracingClient, request, spanAttributes) {
    try {
      const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
        spanKind: "client",
        spanAttributes
      });
      if (!span.isRecording()) {
        span.end();
        return;
      }
      const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
      for (const [key, value] of Object.entries(headers)) {
        request.headers.set(key, value);
      }
      return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    } catch (e) {
      log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryProcessError(span, error2) {
    try {
      span.setStatus({
        status: "error",
        error: (0, core_util_1.isError)(error2) ? error2 : undefined
      });
      if ((0, restError_js_1.isRestError)(error2) && error2.statusCode) {
        span.setAttribute("http.status_code", error2.statusCode);
      }
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
  function tryProcessResponse(span, response) {
    try {
      span.setAttribute("http.status_code", response.status);
      const serviceRequestId = response.headers.get("x-ms-request-id");
      if (serviceRequestId) {
        span.setAttribute("serviceRequestId", serviceRequestId);
      }
      span.setStatus({
        status: "success"
      });
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tracingPolicyName = undefined;
  exports.tracingPolicy = tracingPolicy;
  var core_tracing_1 = require_commonjs5();
  var constants_js_1 = require_constants7();
  var userAgent_js_1 = require_userAgent();
  var log_js_1 = require_log2();
  var core_util_1 = require_commonjs3();
  var restError_js_1 = require_restError();
  var sanitizer_js_1 = require_sanitizer();
  exports.tracingPolicyName = "tracingPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS((exports) => {
  function createPipelineFromOptions(options3) {
    var _a;
    const pipeline4 = (0, pipeline_js_1.createEmptyPipeline)();
    if (core_util_1.isNodeLike) {
      if (options3.tlsOptions) {
        pipeline4.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options3.tlsOptions));
      }
      pipeline4.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options3.proxyOptions));
      pipeline4.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline4.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline4.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options3.userAgentOptions));
    pipeline4.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)((_a = options3.telemetryOptions) === null || _a === undefined ? undefined : _a.clientRequestIdHeaderName));
    pipeline4.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline4.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options3.retryOptions), { phase: "Retry" });
    pipeline4.addPolicy((0, tracingPolicy_js_1.tracingPolicy)(Object.assign(Object.assign({}, options3.userAgentOptions), options3.loggingOptions)), {
      afterPhase: "Retry"
    });
    if (core_util_1.isNodeLike) {
      pipeline4.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options3.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline4.addPolicy((0, logPolicy_js_1.logPolicy)(options3.loggingOptions), { afterPhase: "Sign" });
    return pipeline4;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineFromOptions = createPipelineFromOptions;
  var logPolicy_js_1 = require_logPolicy();
  var pipeline_js_1 = require_pipeline();
  var redirectPolicy_js_1 = require_redirectPolicy();
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  var multipartPolicy_js_1 = require_multipartPolicy();
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  var formDataPolicy_js_1 = require_formDataPolicy();
  var core_util_1 = require_commonjs3();
  var proxyPolicy_js_1 = require_proxyPolicy();
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  var tlsPolicy_js_1 = require_tlsPolicy();
  var tracingPolicy_js_1 = require_tracingPolicy();
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS((exports) => {
  function isReadableStream3(body) {
    return body && typeof body.pipe === "function";
  }
  function isStreamComplete(stream3) {
    return new Promise((resolve) => {
      stream3.on("close", resolve);
      stream3.on("end", resolve);
      stream3.on("error", resolve);
    });
  }
  function isArrayBuffer2(body) {
    return body && typeof body.byteLength === "number";
  }
  function getResponseHeaders(res) {
    const headers = (0, httpHeaders_js_1.createHttpHeaders)();
    for (const header of Object.keys(res.headers)) {
      const value = res.headers[header];
      if (Array.isArray(value)) {
        if (value.length > 0) {
          headers.set(header, value[0]);
        }
      } else if (value) {
        headers.set(header, value);
      }
    }
    return headers;
  }
  function getDecodedResponseStream(stream3, headers) {
    const contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      const unzip = zlib.createGunzip();
      stream3.pipe(unzip);
      return unzip;
    } else if (contentEncoding === "deflate") {
      const inflate = zlib.createInflate();
      stream3.pipe(inflate);
      return inflate;
    }
    return stream3;
  }
  function streamToText(stream3) {
    return new Promise((resolve, reject4) => {
      const buffer = [];
      stream3.on("data", (chunk) => {
        if (Buffer.isBuffer(chunk)) {
          buffer.push(chunk);
        } else {
          buffer.push(Buffer.from(chunk));
        }
      });
      stream3.on("end", () => {
        resolve(Buffer.concat(buffer).toString("utf8"));
      });
      stream3.on("error", (e) => {
        if (e && (e === null || e === undefined ? undefined : e.name) === "AbortError") {
          reject4(e);
        } else {
          reject4(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
            code: restError_js_1.RestError.PARSE_ERROR
          }));
        }
      });
    });
  }
  function getBodyLength(body) {
    if (!body) {
      return 0;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (isReadableStream3(body)) {
      return null;
    } else if (isArrayBuffer2(body)) {
      return body.byteLength;
    } else if (typeof body === "string") {
      return Buffer.from(body).length;
    } else {
      return null;
    }
  }
  function createNodeHttpClient() {
    return new NodeHttpClient;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBodyLength = getBodyLength;
  exports.createNodeHttpClient = createNodeHttpClient;
  var tslib_1 = require_tslib();
  var http = tslib_1.__importStar(__require("node:http"));
  var https = tslib_1.__importStar(__require("node:https"));
  var zlib = tslib_1.__importStar(__require("node:zlib"));
  var node_stream_1 = __require("node:stream");
  var abort_controller_1 = require_commonjs4();
  var httpHeaders_js_1 = require_httpHeaders();
  var restError_js_1 = require_restError();
  var log_js_1 = require_log2();
  var DEFAULT_TLS_SETTINGS = {};

  class ReportTransform extends node_stream_1.Transform {
    _transform(chunk, _encoding, callback) {
      this.push(chunk);
      this.loadedBytes += chunk.length;
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes });
        callback();
      } catch (e) {
        callback(e);
      }
    }
    constructor(progressCallback) {
      super();
      this.loadedBytes = 0;
      this.progressCallback = progressCallback;
    }
  }

  class NodeHttpClient {
    constructor() {
      this.cachedHttpsAgents = new WeakMap;
    }
    async sendRequest(request) {
      var _a, _b, _c;
      const abortController = new AbortController;
      let abortListener;
      if (request.abortSignal) {
        if (request.abortSignal.aborted) {
          throw new abort_controller_1.AbortError("The operation was aborted.");
        }
        abortListener = (event) => {
          if (event.type === "abort") {
            abortController.abort();
          }
        };
        request.abortSignal.addEventListener("abort", abortListener);
      }
      if (request.timeout > 0) {
        setTimeout(() => {
          abortController.abort();
        }, request.timeout);
      }
      const acceptEncoding = request.headers.get("Accept-Encoding");
      const shouldDecompress = (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("deflate"));
      let body = typeof request.body === "function" ? request.body() : request.body;
      if (body && !request.headers.has("Content-Length")) {
        const bodyLength = getBodyLength(body);
        if (bodyLength !== null) {
          request.headers.set("Content-Length", bodyLength);
        }
      }
      let responseStream;
      try {
        if (body && request.onUploadProgress) {
          const onUploadProgress = request.onUploadProgress;
          const uploadReportStream = new ReportTransform(onUploadProgress);
          uploadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in upload progress", e);
          });
          if (isReadableStream3(body)) {
            body.pipe(uploadReportStream);
          } else {
            uploadReportStream.end(body);
          }
          body = uploadReportStream;
        }
        const res = await this.makeRequest(request, abortController, body);
        const headers = getResponseHeaders(res);
        const status = (_a = res.statusCode) !== null && _a !== undefined ? _a : 0;
        const response = {
          status,
          headers,
          request
        };
        if (request.method === "HEAD") {
          res.resume();
          return response;
        }
        responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
        const onDownloadProgress = request.onDownloadProgress;
        if (onDownloadProgress) {
          const downloadReportStream = new ReportTransform(onDownloadProgress);
          downloadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in download progress", e);
          });
          responseStream.pipe(downloadReportStream);
          responseStream = downloadReportStream;
        }
        if (((_b = request.streamResponseStatusCodes) === null || _b === undefined ? undefined : _b.has(Number.POSITIVE_INFINITY)) || ((_c = request.streamResponseStatusCodes) === null || _c === undefined ? undefined : _c.has(response.status))) {
          response.readableStreamBody = responseStream;
        } else {
          response.bodyAsText = await streamToText(responseStream);
        }
        return response;
      } finally {
        if (request.abortSignal && abortListener) {
          let uploadStreamDone = Promise.resolve();
          if (isReadableStream3(body)) {
            uploadStreamDone = isStreamComplete(body);
          }
          let downloadStreamDone = Promise.resolve();
          if (isReadableStream3(responseStream)) {
            downloadStreamDone = isStreamComplete(responseStream);
          }
          Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
            var _a2;
            if (abortListener) {
              (_a2 = request.abortSignal) === null || _a2 === undefined || _a2.removeEventListener("abort", abortListener);
            }
          }).catch((e) => {
            log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
          });
        }
      }
    }
    makeRequest(request, abortController, body) {
      var _a;
      const url = new URL(request.url);
      const isInsecure = url.protocol !== "https:";
      if (isInsecure && !request.allowInsecureConnection) {
        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
      }
      const agent = (_a = request.agent) !== null && _a !== undefined ? _a : this.getOrCreateAgent(request, isInsecure);
      const options3 = {
        agent,
        hostname: url.hostname,
        path: `${url.pathname}${url.search}`,
        port: url.port,
        method: request.method,
        headers: request.headers.toJSON({ preserveCase: true })
      };
      return new Promise((resolve, reject4) => {
        const req = isInsecure ? http.request(options3, resolve) : https.request(options3, resolve);
        req.once("error", (err) => {
          var _a2;
          reject4(new restError_js_1.RestError(err.message, { code: (_a2 = err.code) !== null && _a2 !== undefined ? _a2 : restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
        });
        abortController.signal.addEventListener("abort", () => {
          const abortError = new abort_controller_1.AbortError("The operation was aborted.");
          req.destroy(abortError);
          reject4(abortError);
        });
        if (body && isReadableStream3(body)) {
          body.pipe(req);
        } else if (body) {
          if (typeof body === "string" || Buffer.isBuffer(body)) {
            req.end(body);
          } else if (isArrayBuffer2(body)) {
            req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
          } else {
            log_js_1.logger.error("Unrecognized body type", body);
            reject4(new restError_js_1.RestError("Unrecognized body type"));
          }
        } else {
          req.end();
        }
      });
    }
    getOrCreateAgent(request, isInsecure) {
      var _a;
      const disableKeepAlive = request.disableKeepAlive;
      if (isInsecure) {
        if (disableKeepAlive) {
          return http.globalAgent;
        }
        if (!this.cachedHttpAgent) {
          this.cachedHttpAgent = new http.Agent({ keepAlive: true });
        }
        return this.cachedHttpAgent;
      } else {
        if (disableKeepAlive && !request.tlsSettings) {
          return https.globalAgent;
        }
        const tlsSettings = (_a = request.tlsSettings) !== null && _a !== undefined ? _a : DEFAULT_TLS_SETTINGS;
        let agent = this.cachedHttpsAgents.get(tlsSettings);
        if (agent && agent.options.keepAlive === !disableKeepAlive) {
          return agent;
        }
        log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
        agent = new https.Agent(Object.assign({
          keepAlive: !disableKeepAlive
        }, tlsSettings));
        this.cachedHttpsAgents.set(tlsSettings, agent);
        return agent;
      }
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS((exports) => {
  function createDefaultHttpClient() {
    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultHttpClient = createDefaultHttpClient;
  var nodeHttpClient_js_1 = require_nodeHttpClient();
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS((exports) => {
  function createPipelineRequest(options3) {
    return new PipelineRequestImpl(options3);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineRequest = createPipelineRequest;
  var httpHeaders_js_1 = require_httpHeaders();
  var core_util_1 = require_commonjs3();

  class PipelineRequestImpl {
    constructor(options3) {
      var _a, _b, _c, _d, _e, _f, _g;
      this.url = options3.url;
      this.body = options3.body;
      this.headers = (_a = options3.headers) !== null && _a !== undefined ? _a : (0, httpHeaders_js_1.createHttpHeaders)();
      this.method = (_b = options3.method) !== null && _b !== undefined ? _b : "GET";
      this.timeout = (_c = options3.timeout) !== null && _c !== undefined ? _c : 0;
      this.multipartBody = options3.multipartBody;
      this.formData = options3.formData;
      this.disableKeepAlive = (_d = options3.disableKeepAlive) !== null && _d !== undefined ? _d : false;
      this.proxySettings = options3.proxySettings;
      this.streamResponseStatusCodes = options3.streamResponseStatusCodes;
      this.withCredentials = (_e = options3.withCredentials) !== null && _e !== undefined ? _e : false;
      this.abortSignal = options3.abortSignal;
      this.tracingOptions = options3.tracingOptions;
      this.onUploadProgress = options3.onUploadProgress;
      this.onDownloadProgress = options3.onDownloadProgress;
      this.requestId = options3.requestId || (0, core_util_1.randomUUID)();
      this.allowInsecureConnection = (_f = options3.allowInsecureConnection) !== null && _f !== undefined ? _f : false;
      this.enableBrowserStreams = (_g = options3.enableBrowserStreams) !== null && _g !== undefined ? _g : false;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS((exports) => {
  function exponentialRetryPolicy(options3 = {}) {
    var _a;
    return (0, retryPolicy_js_1.retryPolicy)([
      (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(Object.assign(Object.assign({}, options3), { ignoreSystemErrors: true }))
    ], {
      maxRetries: (_a = options3.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryPolicyName = undefined;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS((exports) => {
  function systemErrorRetryPolicy(options3 = {}) {
    var _a;
    return {
      name: exports.systemErrorRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(Object.assign(Object.assign({}, options3), { ignoreHttpStatusCodes: true }))
      ], {
        maxRetries: (_a = options3.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.systemErrorRetryPolicyName = undefined;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS((exports) => {
  function throttlingRetryPolicy(options3 = {}) {
    var _a;
    return {
      name: exports.throttlingRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
        maxRetries: (_a = options3.maxRetries) !== null && _a !== undefined ? _a : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttlingRetryPolicyName = undefined;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS((exports) => {
  async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    async function tryGetAccessToken() {
      if (Date.now() < refreshTimeout) {
        try {
          return await getAccessToken();
        } catch (_a) {
          return null;
        }
      } else {
        const finalToken = await getAccessToken();
        if (finalToken === null) {
          throw new Error("Failed to refresh access token.");
        }
        return finalToken;
      }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
      await (0, helpers_js_1.delay)(retryIntervalInMs);
      token = await tryGetAccessToken();
    }
    return token;
  }
  function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options3 = Object.assign(Object.assign({}, exports.DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    const cycler = {
      get isRefreshing() {
        return refreshWorker !== null;
      },
      get shouldRefresh() {
        var _a;
        return !cycler.isRefreshing && ((_a = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a !== undefined ? _a : 0) - options3.refreshWindowInMs < Date.now();
      },
      get mustRefresh() {
        return token === null || token.expiresOnTimestamp - options3.forcedRefreshWindowInMs < Date.now();
      }
    };
    function refresh(scopes, getTokenOptions) {
      var _a;
      if (!cycler.isRefreshing) {
        const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
        refreshWorker = beginRefresh(tryGetAccessToken, options3.retryIntervalInMs, (_a = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a !== undefined ? _a : Date.now()).then((_token) => {
          refreshWorker = null;
          token = _token;
          tenantId = getTokenOptions.tenantId;
          return token;
        }).catch((reason) => {
          refreshWorker = null;
          token = null;
          tenantId = undefined;
          throw reason;
        });
      }
      return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
      const hasClaimChallenge = Boolean(tokenOptions.claims);
      const tenantIdChanged = tenantId !== tokenOptions.tenantId;
      if (hasClaimChallenge) {
        token = null;
      }
      const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
      if (mustRefresh) {
        return refresh(scopes, tokenOptions);
      }
      if (cycler.shouldRefresh) {
        refresh(scopes, tokenOptions);
      }
      return token;
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CYCLER_OPTIONS = undefined;
  exports.createTokenCycler = createTokenCycler;
  var helpers_js_1 = require_helpers();
  exports.DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2
  };
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS((exports) => {
  async function defaultAuthorizeRequest(options3) {
    const { scopes, getAccessToken, request } = options3;
    const getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) {
      options3.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    }
  }
  function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
      return challenge;
    }
    return;
  }
  function bearerTokenAuthenticationPolicy(options3) {
    var _a;
    const { credential, scopes, challengeCallbacks } = options3;
    const logger = options3.logger || log_js_1.logger;
    const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequest) !== null && _a !== undefined ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
    const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(credential) : () => Promise.resolve(null);
    return {
      name: exports.bearerTokenAuthenticationPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
        }
        await callbacks.authorizeRequest({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          getAccessToken,
          logger
        });
        let response;
        let error2;
        try {
          response = await next(request);
        } catch (err) {
          error2 = err;
          response = err.response;
        }
        if (callbacks.authorizeRequestOnChallenge && (response === null || response === undefined ? undefined : response.status) === 401 && getChallenge(response)) {
          const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            response,
            getAccessToken,
            logger
          });
          if (shouldSendRequest) {
            return next(request);
          }
        }
        if (error2) {
          throw error2;
        } else {
          return response;
        }
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearerTokenAuthenticationPolicyName = undefined;
  exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log2();
  exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS((exports) => {
  function ndJsonPolicy() {
    return {
      name: exports.ndJsonPolicyName,
      async sendRequest(request, next) {
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          const body = JSON.parse(request.body);
          if (Array.isArray(body)) {
            request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
          }
        }
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ndJsonPolicyName = undefined;
  exports.ndJsonPolicy = ndJsonPolicy;
  exports.ndJsonPolicyName = "ndJsonPolicy";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS((exports) => {
  async function sendAuthorizeRequest(options3) {
    var _a, _b;
    const { scopes, getAccessToken, request } = options3;
    const getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions
    };
    return (_b = (_a = await getAccessToken(scopes, getTokenOptions)) === null || _a === undefined ? undefined : _a.token) !== null && _b !== undefined ? _b : "";
  }
  function auxiliaryAuthenticationHeaderPolicy(options3) {
    const { credentials, scopes } = options3;
    const logger = options3.logger || log_js_1.logger;
    const tokenCyclerMap = new WeakMap;
    return {
      name: exports.auxiliaryAuthenticationHeaderPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
        }
        if (!credentials || credentials.length === 0) {
          logger.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
          return next(request);
        }
        const tokenPromises = [];
        for (const credential of credentials) {
          let getAccessToken = tokenCyclerMap.get(credential);
          if (!getAccessToken) {
            getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
            tokenCyclerMap.set(credential, getAccessToken);
          }
          tokenPromises.push(sendAuthorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger
          }));
        }
        const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
        if (auxiliaryTokens.length === 0) {
          logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
          return next(request);
        }
        request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
        return next(request);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auxiliaryAuthenticationHeaderPolicyName = undefined;
  exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log2();
  exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
  var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileFromStream = exports.createFile = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = undefined;
  var pipeline_js_1 = require_pipeline();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
  Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: true, get: function() {
    return createPipelineFromOptions_js_1.createPipelineFromOptions;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var httpHeaders_js_1 = require_httpHeaders();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  var pipelineRequest_js_1 = require_pipelineRequest();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var restError_js_1 = require_restError();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
    return restError_js_1.isRestError;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
  } });
  Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy();
  Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy();
  Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var tracingPolicy_js_1 = require_tracingPolicy();
  Object.defineProperty(exports, "tracingPolicy", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicy;
  } });
  Object.defineProperty(exports, "tracingPolicyName", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
  } });
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
  } });
  var ndJsonPolicy_js_1 = require_ndJsonPolicy();
  Object.defineProperty(exports, "ndJsonPolicy", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicy;
  } });
  Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicyName;
  } });
  var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
  } });
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
  } });
  var file_js_1 = require_file2();
  Object.defineProperty(exports, "createFile", { enumerable: true, get: function() {
    return file_js_1.createFile;
  } });
  Object.defineProperty(exports, "createFileFromStream", { enumerable: true, get: function() {
    return file_js_1.createFileFromStream;
  } });
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureKeyCredential = undefined;

  class AzureKeyCredential {
    get key() {
      return this._key;
    }
    constructor(key) {
      if (!key) {
        throw new Error("key must be a non-empty string");
      }
      this._key = key;
    }
    update(newKey) {
      this._key = newKey;
    }
  }
  exports.AzureKeyCredential = AzureKeyCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS((exports) => {
  function isKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isKeyCredential = undefined;
  var core_util_1 = require_commonjs3();
  exports.isKeyCredential = isKeyCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS((exports) => {
  function isNamedKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = undefined;
  var core_util_1 = require_commonjs3();

  class AzureNamedKeyCredential {
    get key() {
      return this._key;
    }
    get name() {
      return this._name;
    }
    constructor(name, key) {
      if (!name || !key) {
        throw new TypeError("name and key must be non-empty strings");
      }
      this._name = name;
      this._key = key;
    }
    update(newName, newKey) {
      if (!newName || !newKey) {
        throw new TypeError("newName and newKey must be non-empty strings");
      }
      this._name = newName;
      this._key = newKey;
    }
  }
  exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
  exports.isNamedKeyCredential = isNamedKeyCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS((exports) => {
  function isSASCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSASCredential = exports.AzureSASCredential = undefined;
  var core_util_1 = require_commonjs3();

  class AzureSASCredential {
    get signature() {
      return this._signature;
    }
    constructor(signature) {
      if (!signature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = signature;
    }
    update(newSignature) {
      if (!newSignature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = newSignature;
    }
  }
  exports.AzureSASCredential = AzureSASCredential;
  exports.isSASCredential = isSASCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS((exports) => {
  function isTokenCredential(credential) {
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTokenCredential = undefined;
  exports.isTokenCredential = isTokenCredential;
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = undefined;
  var azureKeyCredential_js_1 = require_azureKeyCredential();
  Object.defineProperty(exports, "AzureKeyCredential", { enumerable: true, get: function() {
    return azureKeyCredential_js_1.AzureKeyCredential;
  } });
  var keyCredential_js_1 = require_keyCredential();
  Object.defineProperty(exports, "isKeyCredential", { enumerable: true, get: function() {
    return keyCredential_js_1.isKeyCredential;
  } });
  var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
  Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
  } });
  Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.isNamedKeyCredential;
  } });
  var azureSASCredential_js_1 = require_azureSASCredential();
  Object.defineProperty(exports, "AzureSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.AzureSASCredential;
  } });
  Object.defineProperty(exports, "isSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.isSASCredential;
  } });
  var tokenCredential_js_1 = require_tokenCredential();
  Object.defineProperty(exports, "isTokenCredential", { enumerable: true, get: function() {
    return tokenCredential_js_1.isTokenCredential;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js
var require_disableKeepAlivePolicy = __commonJS((exports) => {
  function createDisableKeepAlivePolicy() {
    return {
      name: exports.disableKeepAlivePolicyName,
      async sendRequest(request, next) {
        request.disableKeepAlive = true;
        return next(request);
      }
    };
  }
  function pipelineContainsDisableKeepAlivePolicy(pipeline4) {
    return pipeline4.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipelineContainsDisableKeepAlivePolicy = exports.createDisableKeepAlivePolicy = exports.disableKeepAlivePolicyName = undefined;
  exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
  exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
  exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base64 = __commonJS((exports) => {
  function encodeString(value) {
    return Buffer.from(value).toString("base64");
  }
  function encodeByteArray(value) {
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
  }
  function decodeString(value) {
    return Buffer.from(value, "base64");
  }
  function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeStringToString = exports.decodeString = exports.encodeByteArray = exports.encodeString = undefined;
  exports.encodeString = encodeString;
  exports.encodeByteArray = encodeByteArray;
  exports.decodeString = decodeString;
  exports.decodeStringToString = decodeStringToString;
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils3 = __commonJS((exports) => {
  function isPrimitiveBody(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === undefined ? undefined : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);
  }
  function isDuration(value) {
    return validateISODuration.test(value);
  }
  function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
  }
  function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
      return responseObject.shouldWrapBody ? { body: null } : null;
    } else {
      return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
    }
  }
  function flattenResponse(fullResponse, responseSpec) {
    var _a, _b;
    const parsedHeaders = fullResponse.parsedHeaders;
    if (fullResponse.request.method === "HEAD") {
      return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper === null || bodyMapper === undefined ? undefined : bodyMapper.nullable);
    const expectedBodyTypeName = bodyMapper === null || bodyMapper === undefined ? undefined : bodyMapper.type.name;
    if (expectedBodyTypeName === "Stream") {
      return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
    }
    const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
      const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== undefined ? _a : [];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === undefined ? undefined : _b[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
      body: fullResponse.parsedBody,
      headers: parsedHeaders,
      hasNullableType: isNullable,
      shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flattenResponse = exports.isValidUuid = exports.isDuration = exports.isPrimitiveBody = undefined;
  exports.isPrimitiveBody = isPrimitiveBody;
  var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  exports.isDuration = isDuration;
  var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  exports.isValidUuid = isValidUuid;
  exports.flattenResponse = flattenResponse;
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS((exports) => {
  function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
  }
  function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
      --len;
    }
    return str.substr(0, len);
  }
  function bufferToBase64Url(buffer) {
    if (!buffer) {
      return;
    }
    if (!(buffer instanceof Uint8Array)) {
      throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    const str = base64.encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64UrlToByteArray(str) {
    if (!str) {
      return;
    }
    if (str && typeof str.valueOf() !== "string") {
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return base64.decodeString(str);
  }
  function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
      const subwords = prop.split(".");
      for (const item of subwords) {
        if (item.charAt(item.length - 1) === "\\") {
          partialclass += item.substr(0, item.length - 1) + ".";
        } else {
          partialclass += item;
          classes.push(partialclass);
          partialclass = "";
        }
      }
    }
    return classes;
  }
  function dateToUnixTime(d) {
    if (!d) {
      return;
    }
    if (typeof d.valueOf() === "string") {
      d = new Date(d);
    }
    return Math.floor(d.getTime() / 1000);
  }
  function unixTimeToDate(n2) {
    if (!n2) {
      return;
    }
    return new Date(n2 * 1000);
  }
  function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
      if (typeName.match(/^Number$/i) !== null) {
        if (typeof value !== "number") {
          throw new Error(`${objectName} with value ${value} must be of type number.`);
        }
      } else if (typeName.match(/^String$/i) !== null) {
        if (typeof value.valueOf() !== "string") {
          throw new Error(`${objectName} with value "${value}" must be of type string.`);
        }
      } else if (typeName.match(/^Uuid$/i) !== null) {
        if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
          throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
        }
      } else if (typeName.match(/^Boolean$/i) !== null) {
        if (typeof value !== "boolean") {
          throw new Error(`${objectName} with value ${value} must be of type boolean.`);
        }
      } else if (typeName.match(/^Stream$/i) !== null) {
        const objectType = typeof value;
        if (objectType !== "string" && typeof value.pipe !== "function" && typeof value.tee !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
          throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
        }
      }
    }
    return value;
  }
  function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
      throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
      if (typeof item.valueOf() === "string") {
        return item.toLowerCase() === value.toLowerCase();
      }
      return item === value;
    });
    if (!isPresent) {
      throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
  }
  function serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = base64.encodeByteArray(value);
    }
    return value;
  }
  function serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = bufferToBase64Url(value);
    }
    return value;
  }
  function serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
      if (typeName.match(/^Date$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
      } else if (typeName.match(/^DateTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
      } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
        }
        value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
      } else if (typeName.match(/^UnixTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);
        }
        value = dateToUnixTime(value);
      } else if (typeName.match(/^TimeSpan$/i) !== null) {
        if (!(0, utils_js_1.isDuration)(value)) {
          throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
        }
      }
    }
    return value;
  }
  function serializeSequenceType(serializer, mapper, object, objectName, isXml, options3) {
    var _a;
    if (!Array.isArray(object)) {
      throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    if (elementType.type.name === "Composite" && elementType.type.className) {
      elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== undefined ? _a : elementType;
    }
    const tempArray = [];
    for (let i2 = 0;i2 < object.length; i2++) {
      const serializedValue = serializer.serialize(elementType, object[i2], objectName, options3);
      if (isXml && elementType.xmlNamespace) {
        const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
        if (elementType.type.name === "Composite") {
          tempArray[i2] = Object.assign({}, serializedValue);
          tempArray[i2][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        } else {
          tempArray[i2] = {};
          tempArray[i2][options3.xml.xmlCharKey] = serializedValue;
          tempArray[i2][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        }
      } else {
        tempArray[i2] = serializedValue;
      }
    }
    return tempArray;
  }
  function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options3) {
    if (typeof object !== "object") {
      throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object)) {
      const serializedValue = serializer.serialize(valueType, object[key], objectName, options3);
      tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options3);
    }
    if (isXml && mapper.xmlNamespace) {
      const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
      const result5 = tempDictionary;
      result5[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
      return result5;
    }
    return tempDictionary;
  }
  function resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      return modelMapper === null || modelMapper === undefined ? undefined : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
  }
  function resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
      throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    }
    return serializer.modelMappers[className];
  }
  function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      if (!modelMapper) {
        throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
      }
      modelProps = modelMapper === null || modelMapper === undefined ? undefined : modelMapper.type.modelProperties;
      if (!modelProps) {
        throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
      }
    }
    return modelProps;
  }
  function serializeCompositeType(serializer, mapper, object, objectName, isXml, options3) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    }
    if (object !== undefined && object !== null) {
      const payload = {};
      const modelProps = resolveModelProperties(serializer, mapper, objectName);
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        if (propertyMapper.readOnly) {
          continue;
        }
        let propName;
        let parentObject = payload;
        if (serializer.isXML) {
          if (propertyMapper.xmlIsWrapped) {
            propName = propertyMapper.xmlName;
          } else {
            propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
          }
        } else {
          const paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (const pathName of paths) {
            const childObject = parentObject[pathName];
            if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {
              parentObject[pathName] = {};
            }
            parentObject = parentObject[pathName];
          }
        }
        if (parentObject !== undefined && parentObject !== null) {
          if (isXml && mapper.xmlNamespace) {
            const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
            parentObject[interfaces_js_1.XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[interfaces_js_1.XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
          }
          const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
          let toSerialize = object[key];
          const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
          if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {
            toSerialize = mapper.serializedName;
          }
          const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options3);
          if (serializedValue !== undefined && propName !== undefined && propName !== null) {
            const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options3);
            if (isXml && propertyMapper.xmlIsAttribute) {
              parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
              parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
            } else if (isXml && propertyMapper.xmlIsWrapped) {
              parentObject[propName] = { [propertyMapper.xmlElementName]: value };
            } else {
              parentObject[propName] = value;
            }
          }
        }
      }
      const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
      if (additionalPropertiesMapper) {
        const propNames = Object.keys(modelProps);
        for (const clientPropName in object) {
          const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
          if (isAdditionalProperty) {
            payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options3);
          }
        }
      }
      return payload;
    }
    return object;
  }
  function getXmlObjectValue(propertyMapper, serializedValue, isXml, options3) {
    if (!isXml || !propertyMapper.xmlNamespace) {
      return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
      if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
        return serializedValue;
      } else {
        const result6 = Object.assign({}, serializedValue);
        result6[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
        return result6;
      }
    }
    const result5 = {};
    result5[options3.xml.xmlCharKey] = serializedValue;
    result5[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
    return result5;
  }
  function isSpecialXmlProperty(propertyName, options3) {
    return [interfaces_js_1.XML_ATTRKEY, options3.xml.xmlCharKey].includes(propertyName);
  }
  function deserializeCompositeType(serializer, mapper, responseBody, objectName, options3) {
    var _a, _b;
    const xmlCharKey = (_a = options3.xml.xmlCharKey) !== null && _a !== undefined ? _a : interfaces_js_1.XML_CHARKEY;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      const paths = splitSerializeName(modelProps[key].serializedName);
      handledPropertyNames.push(paths[0]);
      const { serializedName, xmlName, xmlElementName } = propertyMapper;
      let propertyObjectName = objectName;
      if (serializedName !== "" && serializedName !== undefined) {
        propertyObjectName = objectName + "." + serializedName;
      }
      const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
      if (headerCollectionPrefix) {
        const dictionary = {};
        for (const headerKey of Object.keys(responseBody)) {
          if (headerKey.startsWith(headerCollectionPrefix)) {
            dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options3);
          }
          handledPropertyNames.push(headerKey);
        }
        instance[key] = dictionary;
      } else if (serializer.isXML) {
        if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
          instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options3);
        } else if (propertyMapper.xmlIsMsText) {
          if (responseBody[xmlCharKey] !== undefined) {
            instance[key] = responseBody[xmlCharKey];
          } else if (typeof responseBody === "string") {
            instance[key] = responseBody;
          }
        } else {
          const propertyName = xmlElementName || xmlName || serializedName;
          if (propertyMapper.xmlIsWrapped) {
            const wrapped = responseBody[xmlName];
            const elementList = (_b = wrapped === null || wrapped === undefined ? undefined : wrapped[xmlElementName]) !== null && _b !== undefined ? _b : [];
            instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options3);
            handledPropertyNames.push(xmlName);
          } else {
            const property = responseBody[propertyName];
            instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options3);
            handledPropertyNames.push(propertyName);
          }
        }
      } else {
        let propertyInstance;
        let res = responseBody;
        let steps = 0;
        for (const item of paths) {
          if (!res)
            break;
          steps++;
          res = res[item];
        }
        if (res === null && steps < paths.length) {
          res = undefined;
        }
        propertyInstance = res;
        const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
        if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {
          propertyInstance = mapper.serializedName;
        }
        let serializedValue;
        if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
          propertyInstance = responseBody[key];
          const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options3);
          for (const [k, v] of Object.entries(instance)) {
            if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
              arrayInstance[k] = v;
            }
          }
          instance = arrayInstance;
        } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
          serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options3);
          instance[key] = serializedValue;
        }
      }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
      const isAdditionalProperty = (responsePropName) => {
        for (const clientPropName in modelProps) {
          const paths = splitSerializeName(modelProps[clientPropName].serializedName);
          if (paths[0] === responsePropName) {
            return false;
          }
        }
        return true;
      };
      for (const responsePropName in responseBody) {
        if (isAdditionalProperty(responsePropName)) {
          instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options3);
        }
      }
    } else if (responseBody && !options3.ignoreUnknownProperties) {
      for (const key of Object.keys(responseBody)) {
        if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options3)) {
          instance[key] = responseBody[key];
        }
      }
    }
    return instance;
  }
  function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options3) {
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      const tempDictionary = {};
      for (const key of Object.keys(responseBody)) {
        tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options3);
      }
      return tempDictionary;
    }
    return responseBody;
  }
  function deserializeSequenceType(serializer, mapper, responseBody, objectName, options3) {
    var _a;
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      if (!Array.isArray(responseBody)) {
        responseBody = [responseBody];
      }
      if (element.type.name === "Composite" && element.type.className) {
        element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== undefined ? _a : element;
      }
      const tempArray = [];
      for (let i2 = 0;i2 < responseBody.length; i2++) {
        tempArray[i2] = serializer.deserialize(element, responseBody[i2], `${objectName}[${i2}]`, options3);
      }
      return tempArray;
    }
    return responseBody;
  }
  function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
      const currentName = typeNamesToCheck.shift();
      const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
      if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
        return discriminators[indexDiscriminator];
      } else {
        for (const [name, mapper] of Object.entries(discriminators)) {
          if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
            typeNamesToCheck.push(mapper.type.className);
          }
        }
      }
    }
    return;
  }
  function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var _a;
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
      let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
      if (discriminatorName) {
        if (polymorphicPropertyName === "serializedName") {
          discriminatorName = discriminatorName.replace(/\\/gi, "");
        }
        const discriminatorValue = object[discriminatorName];
        const typeName = (_a = mapper.type.uberParent) !== null && _a !== undefined ? _a : mapper.type.className;
        if (typeof discriminatorValue === "string" && typeName) {
          const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
          if (polymorphicMapper) {
            mapper = polymorphicMapper;
          }
        }
      }
    }
    return mapper;
  }
  function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
  }
  function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MapperTypeNames = exports.createSerializer = undefined;
  var tslib_1 = require_tslib();
  var base64 = tslib_1.__importStar(require_base64());
  var interfaces_js_1 = require_interfaces();
  var utils_js_1 = require_utils3();

  class SerializerImpl {
    constructor(modelMappers = {}, isXML = false) {
      this.modelMappers = modelMappers;
      this.isXML = isXML;
    }
    validateConstraints(mapper, value, objectName) {
      const failValidation = (constraintName, constraintValue) => {
        throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
      };
      if (mapper.constraints && value !== undefined && value !== null) {
        const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
        if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        }
        if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        }
        if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
          failValidation("InclusiveMaximum", InclusiveMaximum);
        }
        if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
          failValidation("InclusiveMinimum", InclusiveMinimum);
        }
        if (MaxItems !== undefined && value.length > MaxItems) {
          failValidation("MaxItems", MaxItems);
        }
        if (MaxLength !== undefined && value.length > MaxLength) {
          failValidation("MaxLength", MaxLength);
        }
        if (MinItems !== undefined && value.length < MinItems) {
          failValidation("MinItems", MinItems);
        }
        if (MinLength !== undefined && value.length < MinLength) {
          failValidation("MinLength", MinLength);
        }
        if (MultipleOf !== undefined && value % MultipleOf !== 0) {
          failValidation("MultipleOf", MultipleOf);
        }
        if (Pattern) {
          const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null) {
            failValidation("Pattern", Pattern);
          }
        }
        if (UniqueItems && value.some((item, i2, ar) => ar.indexOf(item) !== i2)) {
          failValidation("UniqueItems", UniqueItems);
        }
      }
    }
    serialize(mapper, object, objectName, options3 = { xml: {} }) {
      var _a, _b, _c;
      const updatedOptions = {
        xml: {
          rootName: (_a = options3.xml.rootName) !== null && _a !== undefined ? _a : "",
          includeRoot: (_b = options3.xml.includeRoot) !== null && _b !== undefined ? _b : false,
          xmlCharKey: (_c = options3.xml.xmlCharKey) !== null && _c !== undefined ? _c : interfaces_js_1.XML_CHARKEY
        }
      };
      let payload = {};
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Sequence$/i) !== null) {
        payload = [];
      }
      if (mapper.isConstant) {
        object = mapper.defaultValue;
      }
      const { required, nullable } = mapper;
      if (required && nullable && object === undefined) {
        throw new Error(`${objectName} cannot be undefined.`);
      }
      if (required && !nullable && (object === undefined || object === null)) {
        throw new Error(`${objectName} cannot be null or undefined.`);
      }
      if (!required && nullable === false && object === null) {
        throw new Error(`${objectName} cannot be null.`);
      }
      if (object === undefined || object === null) {
        payload = object;
      } else {
        if (mapperType.match(/^any$/i) !== null) {
          payload = object;
        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
          payload = serializeBasicTypes(mapperType, objectName, object);
        } else if (mapperType.match(/^Enum$/i) !== null) {
          const enumMapper = mapper;
          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
          payload = serializeDateTypes(mapperType, object, objectName);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = serializeByteArrayType(objectName, object);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = serializeBase64UrlType(objectName, object);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Composite$/i) !== null) {
          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
      }
      return payload;
    }
    deserialize(mapper, responseBody, objectName, options3 = { xml: {} }) {
      var _a, _b, _c, _d;
      const updatedOptions = {
        xml: {
          rootName: (_a = options3.xml.rootName) !== null && _a !== undefined ? _a : "",
          includeRoot: (_b = options3.xml.includeRoot) !== null && _b !== undefined ? _b : false,
          xmlCharKey: (_c = options3.xml.xmlCharKey) !== null && _c !== undefined ? _c : interfaces_js_1.XML_CHARKEY
        },
        ignoreUnknownProperties: (_d = options3.ignoreUnknownProperties) !== null && _d !== undefined ? _d : false
      };
      if (responseBody === undefined || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
          responseBody = [];
        }
        if (mapper.defaultValue !== undefined) {
          responseBody = mapper.defaultValue;
        }
        return responseBody;
      }
      let payload;
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Composite$/i) !== null) {
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      } else {
        if (this.isXML) {
          const xmlCharKey = updatedOptions.xml.xmlCharKey;
          if (responseBody[interfaces_js_1.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
            responseBody = responseBody[xmlCharKey];
          }
        }
        if (mapperType.match(/^Number$/i) !== null) {
          payload = parseFloat(responseBody);
          if (isNaN(payload)) {
            payload = responseBody;
          }
        } else if (mapperType.match(/^Boolean$/i) !== null) {
          if (responseBody === "true") {
            payload = true;
          } else if (responseBody === "false") {
            payload = false;
          } else {
            payload = responseBody;
          }
        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
          payload = responseBody;
        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
          payload = new Date(responseBody);
        } else if (mapperType.match(/^UnixTime$/i) !== null) {
          payload = unixTimeToDate(responseBody);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = base64.decodeString(responseBody);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = base64UrlToByteArray(responseBody);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
      }
      if (mapper.isConstant) {
        payload = mapper.defaultValue;
      }
      return payload;
    }
  }
  exports.createSerializer = createSerializer;
  exports.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
  };
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    operationRequestMap: new WeakMap
  };
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS((exports) => {
  function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
      parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
      if (parameterPath.length > 0) {
        if (parameterMapper.isConstant) {
          value = parameterMapper.defaultValue;
        } else {
          let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
          if (!propertySearchResult.propertyFound && fallbackObject) {
            propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
          }
          let useDefaultValue = false;
          if (!propertySearchResult.propertyFound) {
            useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
          }
          value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
        }
      }
    } else {
      if (parameterMapper.required) {
        value = {};
      }
      for (const propertyName in parameterPath) {
        const propertyMapper = parameterMapper.type.modelProperties[propertyName];
        const propertyPath = parameterPath[propertyName];
        const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
          parameterPath: propertyPath,
          mapper: propertyMapper
        }, fallbackObject);
        if (propertyValue !== undefined) {
          if (!value) {
            value = {};
          }
          value[propertyName] = propertyValue;
        }
      }
    }
    return value;
  }
  function getPropertyFromParameterPath(parent, parameterPath) {
    const result5 = { propertyFound: false };
    let i2 = 0;
    for (;i2 < parameterPath.length; ++i2) {
      const parameterPathPart = parameterPath[i2];
      if (parent && parameterPathPart in parent) {
        parent = parent[parameterPathPart];
      } else {
        break;
      }
    }
    if (i2 === parameterPath.length) {
      result5.propertyValue = parent;
      result5.propertyFound = true;
    }
    return result5;
  }
  function hasOriginalRequest(request) {
    return originalRequestSymbol in request;
  }
  function getOperationRequestInfo(request) {
    if (hasOriginalRequest(request)) {
      return getOperationRequestInfo(request[originalRequestSymbol]);
    }
    let info2 = state_js_1.state.operationRequestMap.get(request);
    if (!info2) {
      info2 = {};
      state_js_1.state.operationRequestMap.set(request, info2);
    }
    return info2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOperationRequestInfo = exports.getOperationArgumentValueFromParameter = undefined;
  var state_js_1 = require_state2();
  exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
  var originalRequestSymbol = Symbol.for("@azure/core-client original request");
  exports.getOperationRequestInfo = getOperationRequestInfo;
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS((exports) => {
  function deserializationPolicy(options3 = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    const jsonContentTypes = (_b = (_a = options3.expectedContentTypes) === null || _a === undefined ? undefined : _a.json) !== null && _b !== undefined ? _b : defaultJsonContentTypes;
    const xmlContentTypes = (_d = (_c = options3.expectedContentTypes) === null || _c === undefined ? undefined : _c.xml) !== null && _d !== undefined ? _d : defaultXmlContentTypes;
    const parseXML = options3.parseXML;
    const serializerOptions = options3.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: (_e = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.rootName) !== null && _e !== undefined ? _e : "",
        includeRoot: (_f = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.includeRoot) !== null && _f !== undefined ? _f : false,
        xmlCharKey: (_g = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.xmlCharKey) !== null && _g !== undefined ? _g : interfaces_js_1.XML_CHARKEY
      }
    };
    return {
      name: exports.deserializationPolicyName,
      async sendRequest(request, next) {
        const response = await next(request);
        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
      }
    };
  }
  function getOperationResponseMap(parsedResponse) {
    let result5;
    const request = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
    const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
    if (operationSpec) {
      if (!(operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationResponseGetter)) {
        result5 = operationSpec.responses[parsedResponse.status];
      } else {
        result5 = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
      }
    }
    return result5;
  }
  function shouldDeserializeResponse(parsedResponse) {
    const request = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
    const shouldDeserialize = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.shouldDeserialize;
    let result5;
    if (shouldDeserialize === undefined) {
      result5 = true;
    } else if (typeof shouldDeserialize === "boolean") {
      result5 = shouldDeserialize;
    } else {
      result5 = shouldDeserialize(parsedResponse);
    }
    return result5;
  }
  async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options3, parseXML) {
    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options3, parseXML);
    if (!shouldDeserializeResponse(parsedResponse)) {
      return parsedResponse;
    }
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
    const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }
    const responseSpec = getOperationResponseMap(parsedResponse);
    const { error: error2, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options3);
    if (error2) {
      throw error2;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    }
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options3);
        } catch (deserializeError) {
          const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
            statusCode: parsedResponse.status,
            request: parsedResponse.request,
            response: parsedResponse
          });
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }
      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
      }
    }
    return parsedResponse;
  }
  function isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
  }
  function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options3) {
    var _a;
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
    if (isExpectedStatusCode) {
      if (responseSpec) {
        if (!responseSpec.isError) {
          return { error: null, shouldReturnResponse: false };
        }
      } else {
        return { error: null, shouldReturnResponse: false };
      }
    }
    const errorResponseSpec = responseSpec !== null && responseSpec !== undefined ? responseSpec : operationSpec.responses.default;
    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === undefined ? undefined : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
    const error2 = new core_rest_pipeline_1.RestError(initialErrorMessage, {
      statusCode: parsedResponse.status,
      request: parsedResponse.request,
      response: parsedResponse
    });
    if (!errorResponseSpec) {
      throw error2;
    }
    const defaultBodyMapper = errorResponseSpec.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec.headersMapper;
    try {
      if (parsedResponse.parsedBody) {
        const parsedBody = parsedResponse.parsedBody;
        let deserializedError;
        if (defaultBodyMapper) {
          let valueToDeserialize = parsedBody;
          if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = [];
            const elementName = defaultBodyMapper.xmlElementName;
            if (typeof parsedBody === "object" && elementName) {
              valueToDeserialize = parsedBody[elementName];
            }
          }
          deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options3);
        }
        const internalError = parsedBody.error || deserializedError || parsedBody;
        error2.code = internalError.code;
        if (internalError.message) {
          error2.message = internalError.message;
        }
        if (defaultBodyMapper) {
          error2.response.parsedBody = deserializedError;
        }
      }
      if (parsedResponse.headers && defaultHeadersMapper) {
        error2.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
      }
    } catch (defaultError) {
      error2.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error: error2, shouldReturnResponse: false };
  }
  async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a;
    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === undefined ? undefined : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {
      const text = operationResponse.bodyAsText;
      const contentType = operationResponse.headers.get("Content-Type") || "";
      const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
      try {
        if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
          operationResponse.parsedBody = JSON.parse(text);
          return operationResponse;
        } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
          if (!parseXML) {
            throw new Error("Parsing XML not supported.");
          }
          const body = await parseXML(text, opts.xml);
          operationResponse.parsedBody = body;
          return operationResponse;
        }
      } catch (err) {
        const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
        const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
        const e = new core_rest_pipeline_1.RestError(msg, {
          code: errCode,
          statusCode: operationResponse.status,
          request: operationResponse.request,
          response: operationResponse
        });
        throw e;
      }
    }
    return operationResponse;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializationPolicy = exports.deserializationPolicyName = undefined;
  var interfaces_js_1 = require_interfaces();
  var core_rest_pipeline_1 = require_commonjs6();
  var serializer_js_1 = require_serializer();
  var operationHelpers_js_1 = require_operationHelpers();
  var defaultJsonContentTypes = ["application/json", "text/json"];
  var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
  exports.deserializationPolicyName = "deserializationPolicy";
  exports.deserializationPolicy = deserializationPolicy;
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS((exports) => {
  function getStreamingResponseStatusCodes(operationSpec) {
    const result5 = new Set;
    for (const statusCode in operationSpec.responses) {
      const operationResponse = operationSpec.responses[statusCode];
      if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
        result5.add(Number(statusCode));
      }
    }
    return result5;
  }
  function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result5;
    if (typeof parameterPath === "string") {
      result5 = parameterPath;
    } else if (Array.isArray(parameterPath)) {
      result5 = parameterPath.join(".");
    } else {
      result5 = mapper.serializedName;
    }
    return result5;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getPathStringFromParameter = exports.getStreamingResponseStatusCodes = undefined;
  var serializer_js_1 = require_serializer();
  exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
  exports.getPathStringFromParameter = getPathStringFromParameter;
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS((exports) => {
  function serializationPolicy(options3 = {}) {
    const stringifyXML = options3.stringifyXML;
    return {
      name: exports.serializationPolicyName,
      async sendRequest(request, next) {
        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
        const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
        const operationArguments = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationArguments;
        if (operationSpec && operationArguments) {
          serializeHeaders(request, operationArguments, operationSpec);
          serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
        }
        return next(request);
      }
    };
  }
  function serializeHeaders(request, operationArguments, operationSpec) {
    var _a, _b;
    if (operationSpec.headerParameters) {
      for (const headerParameter of operationSpec.headerParameters) {
        let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {
          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
          const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
          if (headerCollectionPrefix) {
            for (const key of Object.keys(headerValue)) {
              request.headers.set(headerCollectionPrefix + key, headerValue[key]);
            }
          } else {
            request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
          }
        }
      }
    }
    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === undefined ? undefined : _a.requestOptions) === null || _b === undefined ? undefined : _b.customHeaders;
    if (customHeaders) {
      for (const customHeaderName of Object.keys(customHeaders)) {
        request.headers.set(customHeaderName, customHeaders[customHeaderName]);
      }
    }
  }
  function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
    throw new Error("XML serialization unsupported!");
  }) {
    var _a, _b, _c, _d, _e;
    const serializerOptions = (_a = operationArguments.options) === null || _a === undefined ? undefined : _a.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: (_b = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.rootName) !== null && _b !== undefined ? _b : "",
        includeRoot: (_c = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.includeRoot) !== null && _c !== undefined ? _c : false,
        xmlCharKey: (_d = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.xmlCharKey) !== null && _d !== undefined ? _d : interfaces_js_1.XML_CHARKEY
      }
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
      request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
      const bodyMapper = operationSpec.requestBody.mapper;
      const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
      const typeName = bodyMapper.type.name;
      try {
        if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {
          const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
          request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
          const isStream2 = typeName === serializer_js_1.MapperTypeNames.Stream;
          if (operationSpec.isXML) {
            const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
            const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
            if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
              request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
            } else if (!isStream2) {
              request.body = stringifyXML(value, {
                rootName: xmlName || serializedName,
                xmlCharKey
              });
            }
          } else if (typeName === serializer_js_1.MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === undefined ? undefined : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
            return;
          } else if (!isStream2) {
            request.body = JSON.stringify(request.body);
          }
        }
      } catch (error2) {
        throw new Error(`Error "${error2.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
      }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
      request.formData = {};
      for (const formDataParameter of operationSpec.formDataParameters) {
        const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
          const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
          request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
        }
      }
    }
  }
  function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options3) {
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
      const result5 = {};
      result5[options3.xml.xmlCharKey] = serializedValue;
      result5[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
      return result5;
    }
    return serializedValue;
  }
  function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) {
      obj = [obj];
    }
    if (!xmlNamespaceKey || !xmlNamespace) {
      return { [elementName]: obj };
    }
    const result5 = { [elementName]: obj };
    result5[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
    return result5;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializeRequestBody = exports.serializeHeaders = exports.serializationPolicy = exports.serializationPolicyName = undefined;
  var interfaces_js_1 = require_interfaces();
  var operationHelpers_js_1 = require_operationHelpers();
  var serializer_js_1 = require_serializer();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  exports.serializationPolicyName = "serializationPolicy";
  exports.serializationPolicy = serializationPolicy;
  exports.serializeHeaders = serializeHeaders;
  exports.serializeRequestBody = serializeRequestBody;
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS((exports) => {
  function createClientPipeline(options3 = {}) {
    const pipeline4 = (0, core_rest_pipeline_1.createPipelineFromOptions)(options3 !== null && options3 !== undefined ? options3 : {});
    if (options3.credentialOptions) {
      pipeline4.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
        credential: options3.credentialOptions.credential,
        scopes: options3.credentialOptions.credentialScopes
      }));
    }
    pipeline4.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options3.serializationOptions), { phase: "Serialize" });
    pipeline4.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options3.deserializationOptions), {
      phase: "Deserialize"
    });
    return pipeline4;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createClientPipeline = undefined;
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  var core_rest_pipeline_1 = require_commonjs6();
  var serializationPolicy_js_1 = require_serializationPolicy();
  exports.createClientPipeline = createClientPipeline;
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS((exports) => {
  function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) {
      cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return cachedHttpClient;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCachedDefaultHttpClient = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var cachedHttpClient;
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers = __commonJS((exports) => {
  function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
      let path5 = replaceAll(operationSpec.path, urlReplacements);
      if (operationSpec.path === "/{nextLink}" && path5.startsWith("/")) {
        path5 = path5.substring(1);
      }
      if (isAbsoluteUrl(path5)) {
        requestUrl = path5;
        isAbsolutePath = true;
      } else {
        requestUrl = appendPath(requestUrl, path5);
      }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
  }
  function replaceAll(input, replacements2) {
    let result5 = input;
    for (const [searchValue, replaceValue] of replacements2) {
      result5 = result5.split(searchValue).join(replaceValue);
    }
    return result5;
  }
  function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result5 = new Map;
    if ((_a = operationSpec.urlParameters) === null || _a === undefined ? undefined : _a.length) {
      for (const urlParameter of operationSpec.urlParameters) {
        let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
        const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) {
          urlParameterValue = encodeURIComponent(urlParameterValue);
        }
        result5.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
      }
    }
    return result5;
  }
  function isAbsoluteUrl(url) {
    return url.includes("://");
  }
  function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
      return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
      newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
      pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
      const path5 = pathToAppend.substring(0, searchStart);
      const search = pathToAppend.substring(searchStart + 1);
      newPath = newPath + path5;
      if (search) {
        parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
      }
    } else {
      newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
  }
  function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    var _a;
    const result5 = new Map;
    const sequenceParams = new Set;
    if ((_a = operationSpec.queryParameters) === null || _a === undefined ? undefined : _a.length) {
      for (const queryParameter of operationSpec.queryParameters) {
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
          sequenceParams.add(queryParameter.mapper.serializedName);
        }
        let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
          const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              if (item === null || item === undefined) {
                return "";
              }
              return item;
            });
          }
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
            continue;
          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          if (!queryParameter.skipEncoding) {
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                return encodeURIComponent(item);
              });
            } else {
              queryParameterValue = encodeURIComponent(queryParameterValue);
            }
          }
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          result5.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    }
    return {
      queryParams: result5,
      sequenceParams
    };
  }
  function simpleParseQueryParams(queryString) {
    const result5 = new Map;
    if (!queryString || queryString[0] !== "?") {
      return result5;
    }
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [name, value] = pair.split("=", 2);
      const existingValue = result5.get(name);
      if (existingValue) {
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          result5.set(name, [existingValue, value]);
        }
      } else {
        result5.set(name, value);
      }
    }
    return result5;
  }
  function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
      return url;
    }
    const parsedUrl = new URL(url);
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
      const existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue)) {
        if (Array.isArray(value)) {
          existingValue.push(...value);
          const valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else {
          existingValue.push(value);
        }
      } else if (existingValue) {
        if (Array.isArray(value)) {
          value.unshift(existingValue);
        } else if (sequenceParams.has(name)) {
          combinedParams.set(name, [existingValue, value]);
        }
        if (!noOverwrite) {
          combinedParams.set(name, value);
        }
      } else {
        combinedParams.set(name, value);
      }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
      if (typeof value === "string") {
        searchPieces.push(`${name}=${value}`);
      } else if (Array.isArray(value)) {
        for (const subValue of value) {
          searchPieces.push(`${name}=${subValue}`);
        }
      } else {
        searchPieces.push(`${name}=${value}`);
      }
    }
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.appendQueryParams = exports.getRequestUrl = undefined;
  var operationHelpers_js_1 = require_operationHelpers();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|"
  };
  exports.getRequestUrl = getRequestUrl;
  exports.appendQueryParams = appendQueryParams;
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs();
  exports.logger = (0, logger_1.createClientLogger)("core-client");
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS((exports) => {
  function createDefaultPipeline(options3) {
    const credentialScopes = getCredentialScopes(options3);
    const credentialOptions = options3.credential && credentialScopes ? { credentialScopes, credential: options3.credential } : undefined;
    return (0, pipeline_js_1.createClientPipeline)(Object.assign(Object.assign({}, options3), { credentialOptions }));
  }
  function getCredentialScopes(options3) {
    if (options3.credentialScopes) {
      return options3.credentialScopes;
    }
    if (options3.endpoint) {
      return `${options3.endpoint}/.default`;
    }
    if (options3.baseUri) {
      return `${options3.baseUri}/.default`;
    }
    if (options3.credential && !options3.credentialScopes) {
      throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceClient = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var pipeline_js_1 = require_pipeline2();
  var utils_js_1 = require_utils3();
  var httpClientCache_js_1 = require_httpClientCache();
  var operationHelpers_js_1 = require_operationHelpers();
  var urlHelpers_js_1 = require_urlHelpers();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var log_js_1 = require_log3();

  class ServiceClient {
    constructor(options3 = {}) {
      var _a, _b;
      this._requestContentType = options3.requestContentType;
      this._endpoint = (_a = options3.endpoint) !== null && _a !== undefined ? _a : options3.baseUri;
      if (options3.baseUri) {
        log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
      }
      this._allowInsecureConnection = options3.allowInsecureConnection;
      this._httpClient = options3.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
      this.pipeline = options3.pipeline || createDefaultPipeline(options3);
      if ((_b = options3.additionalPolicies) === null || _b === undefined ? undefined : _b.length) {
        for (const { policy, position } of options3.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : undefined;
          this.pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
    }
    async sendRequest(request) {
      return this.pipeline.sendRequest(this._httpClient, request);
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      const endpoint = operationSpec.baseUrl || this._endpoint;
      if (!endpoint) {
        throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
      }
      const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
      const request = (0, core_rest_pipeline_1.createPipelineRequest)({
        url
      });
      request.method = operationSpec.httpMethod;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      operationInfo.operationSpec = operationSpec;
      operationInfo.operationArguments = operationArguments;
      const contentType = operationSpec.contentType || this._requestContentType;
      if (contentType && operationSpec.requestBody) {
        request.headers.set("Content-Type", contentType);
      }
      const options3 = operationArguments.options;
      if (options3) {
        const requestOptions = options3.requestOptions;
        if (requestOptions) {
          if (requestOptions.timeout) {
            request.timeout = requestOptions.timeout;
          }
          if (requestOptions.onUploadProgress) {
            request.onUploadProgress = requestOptions.onUploadProgress;
          }
          if (requestOptions.onDownloadProgress) {
            request.onDownloadProgress = requestOptions.onDownloadProgress;
          }
          if (requestOptions.shouldDeserialize !== undefined) {
            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
          }
          if (requestOptions.allowInsecureConnection) {
            request.allowInsecureConnection = true;
          }
        }
        if (options3.abortSignal) {
          request.abortSignal = options3.abortSignal;
        }
        if (options3.tracingOptions) {
          request.tracingOptions = options3.tracingOptions;
        }
      }
      if (this._allowInsecureConnection) {
        request.allowInsecureConnection = true;
      }
      if (request.streamResponseStatusCodes === undefined) {
        request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
      }
      try {
        const rawResponse = await this.sendRequest(request);
        const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
        if (options3 === null || options3 === undefined ? undefined : options3.onResponse) {
          options3.onResponse(rawResponse, flatResponse);
        }
        return flatResponse;
      } catch (error2) {
        if (typeof error2 === "object" && (error2 === null || error2 === undefined ? undefined : error2.response)) {
          const rawResponse = error2.response;
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error2.statusCode] || operationSpec.responses["default"]);
          error2.details = flatResponse;
          if (options3 === null || options3 === undefined ? undefined : options3.onResponse) {
            options3.onResponse(rawResponse, flatResponse, error2);
          }
        }
        throw error2;
      }
    }
  }
  exports.ServiceClient = ServiceClient;
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS((exports) => {
  function parseCAEChallenge(challenges) {
    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
    return bearerChallenges.map((challenge) => {
      const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
      return keyValuePairs.reduce((a2, b) => Object.assign(Object.assign({}, a2), b), {});
    });
  }
  async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
    const { scopes, response } = onChallengeOptions;
    const logger = onChallengeOptions.logger || log_js_1.logger;
    const challenge = response.headers.get("WWW-Authenticate");
    if (!challenge) {
      logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const challenges = parseCAEChallenge(challenge) || [];
    const parsedChallenge = challenges.find((x) => x.claims);
    if (!parsedChallenge) {
      logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
      claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    return true;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnClaimChallenge = exports.parseCAEChallenge = undefined;
  var log_js_1 = require_log3();
  var base64_js_1 = require_base64();
  exports.parseCAEChallenge = parseCAEChallenge;
  exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS((exports) => {
  function isUuid(text) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
  }
  function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    if (tenantId && isUuid(tenantId)) {
      return tenantId;
    }
    return;
  }
  function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_id) {
      return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_id);
    challengeScopes.pathname = Constants.DefaultScope;
    let scope = challengeScopes.toString();
    if (scope === "https://disk.azure.com/.default") {
      scope = "https://disk.azure.com//.default";
    }
    return [scope];
  }
  function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
      return challenge;
    }
    return;
  }
  function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    return keyValuePairs.reduce((a2, b) => Object.assign(Object.assign({}, a2), b), {});
  }
  function requestToOptions(request) {
    return {
      abortSignal: request.abortSignal,
      requestOptions: {
        timeout: request.timeout
      },
      tracingOptions: request.tracingOptions
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = undefined;
  var Constants = {
    DefaultScope: "/.default",
    HeaderConstants: {
      AUTHORIZATION: "authorization"
    }
  };
  var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
      const challengeInfo = parseChallenge(challenge);
      const challengeScopes = buildScopes(challengeOptions, challengeInfo);
      const tenantId = extractTenantId(challengeInfo);
      if (!tenantId) {
        return false;
      }
      const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));
      if (!accessToken) {
        return false;
      }
      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
      return true;
    }
    return false;
  };
  exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = undefined;
  var serializer_js_1 = require_serializer();
  Object.defineProperty(exports, "createSerializer", { enumerable: true, get: function() {
    return serializer_js_1.createSerializer;
  } });
  Object.defineProperty(exports, "MapperTypeNames", { enumerable: true, get: function() {
    return serializer_js_1.MapperTypeNames;
  } });
  var serviceClient_js_1 = require_serviceClient();
  Object.defineProperty(exports, "ServiceClient", { enumerable: true, get: function() {
    return serviceClient_js_1.ServiceClient;
  } });
  var pipeline_js_1 = require_pipeline2();
  Object.defineProperty(exports, "createClientPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createClientPipeline;
  } });
  var interfaces_js_1 = require_interfaces();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_CHARKEY;
  } });
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  Object.defineProperty(exports, "deserializationPolicy", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicy;
  } });
  Object.defineProperty(exports, "deserializationPolicyName", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicyName;
  } });
  var serializationPolicy_js_1 = require_serializationPolicy();
  Object.defineProperty(exports, "serializationPolicy", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicy;
  } });
  Object.defineProperty(exports, "serializationPolicyName", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicyName;
  } });
  var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
  Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
  } });
  var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
  Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/util.js
var require_util8 = __commonJS((exports) => {
  function toPipelineRequest(webResource, options3 = {}) {
    const compatWebResource = webResource;
    const request = compatWebResource[originalRequestSymbol];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
    if (request) {
      request.headers = headers;
      return request;
    } else {
      const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
        url: webResource.url,
        method: webResource.method,
        headers,
        withCredentials: webResource.withCredentials,
        timeout: webResource.timeout,
        requestId: webResource.requestId,
        abortSignal: webResource.abortSignal,
        body: webResource.body,
        formData: webResource.formData,
        disableKeepAlive: !!webResource.keepAlive,
        onDownloadProgress: webResource.onDownloadProgress,
        onUploadProgress: webResource.onUploadProgress,
        proxySettings: webResource.proxySettings,
        streamResponseStatusCodes: webResource.streamResponseStatusCodes
      });
      if (options3.originalRequest) {
        newRequest[originalClientRequestSymbol] = options3.originalRequest;
      }
      return newRequest;
    }
  }
  function toWebResourceLike(request, options3) {
    var _a;
    const originalRequest = (_a = options3 === null || options3 === undefined ? undefined : options3.originalRequest) !== null && _a !== undefined ? _a : request;
    const webResource = {
      url: request.url,
      method: request.method,
      headers: toHttpHeadersLike(request.headers),
      withCredentials: request.withCredentials,
      timeout: request.timeout,
      requestId: request.headers.get("x-ms-client-request-id") || request.requestId,
      abortSignal: request.abortSignal,
      body: request.body,
      formData: request.formData,
      keepAlive: !!request.disableKeepAlive,
      onDownloadProgress: request.onDownloadProgress,
      onUploadProgress: request.onUploadProgress,
      proxySettings: request.proxySettings,
      streamResponseStatusCodes: request.streamResponseStatusCodes,
      clone() {
        throw new Error("Cannot clone a non-proxied WebResourceLike");
      },
      prepare() {
        throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
      },
      validateRequestProperties() {
      }
    };
    if (options3 === null || options3 === undefined ? undefined : options3.createProxy) {
      return new Proxy(webResource, {
        get(target, prop, receiver) {
          if (prop === originalRequestSymbol) {
            return request;
          } else if (prop === "clone") {
            return () => {
              return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                createProxy: true,
                originalRequest
              });
            };
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "keepAlive") {
            request.disableKeepAlive = !value;
          }
          const passThroughProps = [
            "url",
            "method",
            "withCredentials",
            "timeout",
            "requestId",
            "abortSignal",
            "body",
            "formData",
            "onDownloadProgress",
            "onUploadProgress",
            "proxySettings",
            "streamResponseStatusCodes"
          ];
          if (typeof prop === "string" && passThroughProps.includes(prop)) {
            request[prop] = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return webResource;
    }
  }
  function toHttpHeadersLike(headers) {
    return new HttpHeaders(headers.toJSON({ preserveCase: true }));
  }
  function getHeaderKey(headerName) {
    return headerName.toLowerCase();
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpHeaders = exports.toHttpHeadersLike = exports.toWebResourceLike = exports.toPipelineRequest = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var originalRequestSymbol = Symbol("Original PipelineRequest");
  var originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
  exports.toPipelineRequest = toPipelineRequest;
  exports.toWebResourceLike = toWebResourceLike;
  exports.toHttpHeadersLike = toHttpHeadersLike;

  class HttpHeaders {
    constructor(rawHeaders) {
      this._headersMap = {};
      if (rawHeaders) {
        for (const headerName in rawHeaders) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(headerName, headerValue) {
      this._headersMap[getHeaderKey(headerName)] = {
        name: headerName,
        value: headerValue.toString()
      };
    }
    get(headerName) {
      const header = this._headersMap[getHeaderKey(headerName)];
      return !header ? undefined : header.value;
    }
    contains(headerName) {
      return !!this._headersMap[getHeaderKey(headerName)];
    }
    remove(headerName) {
      const result5 = this.contains(headerName);
      delete this._headersMap[getHeaderKey(headerName)];
      return result5;
    }
    rawHeaders() {
      return this.toJson({ preserveCase: true });
    }
    headersArray() {
      const headers = [];
      for (const headerKey in this._headersMap) {
        headers.push(this._headersMap[headerKey]);
      }
      return headers;
    }
    headerNames() {
      const headerNames = [];
      const headers = this.headersArray();
      for (let i2 = 0;i2 < headers.length; ++i2) {
        headerNames.push(headers[i2].name);
      }
      return headerNames;
    }
    headerValues() {
      const headerValues = [];
      const headers = this.headersArray();
      for (let i2 = 0;i2 < headers.length; ++i2) {
        headerValues.push(headers[i2].value);
      }
      return headerValues;
    }
    toJson(options3 = {}) {
      const result5 = {};
      if (options3.preserveCase) {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result5[header.name] = header.value;
        }
      } else {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result5[getHeaderKey(header.name)] = header.value;
        }
      }
      return result5;
    }
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: true }));
    }
    clone() {
      const resultPreservingCasing = {};
      for (const headerKey in this._headersMap) {
        const header = this._headersMap[headerKey];
        resultPreservingCasing[header.name] = header.value;
      }
      return new HttpHeaders(resultPreservingCasing);
    }
  }
  exports.HttpHeaders = HttpHeaders;
});

// node_modules/@azure/core-http-compat/dist/commonjs/response.js
var require_response2 = __commonJS((exports) => {
  function toCompatResponse(response, options3) {
    let request = (0, util_js_1.toWebResourceLike)(response.request);
    let headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
    if (options3 === null || options3 === undefined ? undefined : options3.createProxy) {
      return new Proxy(response, {
        get(target, prop, receiver) {
          if (prop === "headers") {
            return headers;
          } else if (prop === "request") {
            return request;
          } else if (prop === originalResponse) {
            return response;
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "headers") {
            headers = value;
          } else if (prop === "request") {
            request = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return Object.assign(Object.assign({}, response), {
        request,
        headers
      });
    }
  }
  function toPipelineResponse(compatResponse) {
    const extendedCompatResponse = compatResponse;
    const response = extendedCompatResponse[originalResponse];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
    if (response) {
      response.headers = headers;
      return response;
    } else {
      return Object.assign(Object.assign({}, compatResponse), { headers, request: (0, util_js_1.toPipelineRequest)(compatResponse.request) });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPipelineResponse = exports.toCompatResponse = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var util_js_1 = require_util8();
  var originalResponse = Symbol("Original FullOperationResponse");
  exports.toCompatResponse = toCompatResponse;
  exports.toPipelineResponse = toPipelineResponse;
});

// node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js
var require_extendedClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendedServiceClient = undefined;
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  var core_rest_pipeline_1 = require_commonjs6();
  var core_client_1 = require_commonjs8();
  var response_js_1 = require_response2();

  class ExtendedServiceClient extends core_client_1.ServiceClient {
    constructor(options3) {
      var _a, _b;
      super(options3);
      if (((_a = options3.keepAliveOptions) === null || _a === undefined ? undefined : _a.enable) === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) {
        this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
      }
      if (((_b = options3.redirectOptions) === null || _b === undefined ? undefined : _b.handleRedirects) === false) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_1.redirectPolicyName
        });
      }
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      var _a;
      const userProvidedCallBack = (_a = operationArguments === null || operationArguments === undefined ? undefined : operationArguments.options) === null || _a === undefined ? undefined : _a.onResponse;
      let lastResponse;
      function onResponse(rawResponse, flatResponse, error2) {
        lastResponse = rawResponse;
        if (userProvidedCallBack) {
          userProvidedCallBack(rawResponse, flatResponse, error2);
        }
      }
      operationArguments.options = Object.assign(Object.assign({}, operationArguments.options), { onResponse });
      const result5 = await super.sendOperationRequest(operationArguments, operationSpec);
      if (lastResponse) {
        Object.defineProperty(result5, "_response", {
          value: (0, response_js_1.toCompatResponse)(lastResponse)
        });
      }
      return result5;
    }
  }
  exports.ExtendedServiceClient = ExtendedServiceClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js
var require_requestPolicyFactoryPolicy = __commonJS((exports) => {
  function createRequestPolicyFactoryPolicy(factories) {
    const orderedFactories = factories.slice().reverse();
    return {
      name: exports.requestPolicyFactoryPolicyName,
      async sendRequest(request, next) {
        let httpPipeline = {
          async sendRequest(httpRequest) {
            const response2 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
            return (0, response_js_1.toCompatResponse)(response2, { createProxy: true });
          }
        };
        for (const factory of orderedFactories) {
          httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
        }
        const webResourceLike = (0, util_js_1.toWebResourceLike)(request, { createProxy: true });
        const response = await httpPipeline.sendRequest(webResourceLike);
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = undefined;
  var util_js_1 = require_util8();
  var response_js_1 = require_response2();
  var HttpPipelineLogLevel;
  (function(HttpPipelineLogLevel2) {
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
  })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
  var mockRequestPolicyOptions = {
    log(_logLevel, _message) {
    },
    shouldLog(_logLevel) {
      return false;
    }
  };
  exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
  exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
});

// node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js
var require_httpClientAdapter = __commonJS((exports) => {
  function convertHttpClient(requestPolicyClient) {
    return {
      sendRequest: async (request) => {
        const response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request, { createProxy: true }));
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertHttpClient = undefined;
  var response_js_1 = require_response2();
  var util_js_1 = require_util8();
  exports.convertHttpClient = convertHttpClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/index.js
var require_commonjs9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = undefined;
  var extendedClient_js_1 = require_extendedClient();
  Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: true, get: function() {
    return extendedClient_js_1.ExtendedServiceClient;
  } });
  var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
  Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
  } });
  Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
  } });
  Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
  } });
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: true, get: function() {
    return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
  } });
  var httpClientAdapter_js_1 = require_httpClientAdapter();
  Object.defineProperty(exports, "convertHttpClient", { enumerable: true, get: function() {
    return httpClientAdapter_js_1.convertHttpClient;
  } });
  var util_js_1 = require_util8();
  Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: true, get: function() {
    return util_js_1.toHttpHeadersLike;
  } });
});

// node_modules/fast-xml-parser/src/util.js
var require_util9 = __commonJS((exports) => {
  var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  var regexName = new RegExp("^" + nameRegexp + "$");
  var getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0;index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string);
    }
    return matches;
  };
  var isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v) {
    return typeof v !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a2, arrayMode) {
    if (a2) {
      const keys = Object.keys(a2);
      const len = keys.length;
      for (let i2 = 0;i2 < len; i2++) {
        if (arrayMode === "strict") {
          target[keys[i2]] = [a2[keys[i2]]];
        } else {
          target[keys[i2]] = a2[keys[i2]];
        }
      }
    }
  };
  exports.getValue = function(v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS((exports) => {
  function isWhiteSpace(char) {
    return char === " " || char === "\t" || char === "\n" || char === "\r";
  }
  function readPI(xmlData, i2) {
    const start2 = i2;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] == "?" || xmlData[i2] == " ") {
        const tagname = xmlData.substr(start2, i2 - start2);
        if (i2 > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
        } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
          i2++;
          break;
        } else {
          continue;
        }
      }
    }
    return i2;
  }
  function readCommentAndCDATA(xmlData, i2) {
    if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
      for (i2 += 3;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
          i2 += 2;
          break;
        }
      }
    } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
      let angleBracketsCount = 1;
      for (i2 += 8;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i2] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
      for (i2 += 8;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
          i2 += 2;
          break;
        }
      }
    }
    return i2;
  }
  function readAttributeStr(xmlData, i2) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i2];
        } else if (startChar !== xmlData[i2]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i2] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i2];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i2,
      tagClosed
    };
  }
  function validateAttributeString(attrStr, options3) {
    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i2 = 0;i2 < matches.length; i2++) {
      if (matches[i2][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
      } else if (matches[i2][3] !== undefined && matches[i2][4] === undefined) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
      } else if (matches[i2][3] === undefined && !options3.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
      }
      const attrName = matches[i2][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
      }
    }
    return true;
  }
  function validateNumberAmpersand(xmlData, i2) {
    let re = /\d/;
    if (xmlData[i2] === "x") {
      i2++;
      re = /[\da-fA-F]/;
    }
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === ";")
        return i2;
      if (!xmlData[i2].match(re))
        break;
    }
    return -1;
  }
  function validateAmpersand(xmlData, i2) {
    i2++;
    if (xmlData[i2] === ";")
      return -1;
    if (xmlData[i2] === "#") {
      i2++;
      return validateNumberAmpersand(xmlData, i2);
    }
    let count2 = 0;
    for (;i2 < xmlData.length; i2++, count2++) {
      if (xmlData[i2].match(/\w/) && count2 < 20)
        continue;
      if (xmlData[i2] === ";")
        break;
      return -1;
    }
    return i2;
  }
  function getErrorObject(code, message2, lineNumber) {
    return {
      err: {
        code,
        msg: message2,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  function validateAttrName(attrName) {
    return util.isName(attrName);
  }
  function validateTagName(tagname) {
    return util.isName(tagname);
  }
  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      col: lines[lines.length - 1].length + 1
    };
  }
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
  var util = require_util9();
  var defaultOptions = {
    allowBooleanAttributes: false,
    unpairedTags: []
  };
  exports.validate = function(xmlData, options3) {
    options3 = Object.assign({}, defaultOptions, options3);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i2 = 0;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
        i2 += 2;
        i2 = readPI(xmlData, i2);
        if (i2.err)
          return i2;
      } else if (xmlData[i2] === "<") {
        let tagStartPos = i2;
        i2++;
        if (xmlData[i2] === "!") {
          i2 = readCommentAndCDATA(xmlData, i2);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i2] === "/") {
            closingTag = true;
            i2++;
          }
          let tagName = "";
          for (;i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "\t" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
            tagName += xmlData[i2];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i2--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
          }
          const result5 = readAttributeStr(xmlData, i2);
          if (result5 === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
          }
          let attrStr = result5.value;
          i2 = result5.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i2 - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options3);
            if (isValid === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result5.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else if (tags.length === 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options3);
            if (isValid !== true) {
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
            } else if (options3.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i2++;i2 < xmlData.length; i2++) {
            if (xmlData[i2] === "<") {
              if (xmlData[i2 + 1] === "!") {
                i2++;
                i2 = readCommentAndCDATA(xmlData, i2);
                continue;
              } else if (xmlData[i2 + 1] === "?") {
                i2 = readPI(xmlData, ++i2);
                if (i2.err)
                  return i2;
              } else {
                break;
              }
            } else if (xmlData[i2] === "&") {
              const afterAmp = validateAmpersand(xmlData, i2);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
              i2 = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
              }
            }
          }
          if (xmlData[i2] === "<") {
            i2--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i2])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  var doubleQuote = '"';
  var singleQuote = "'";
  var validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', "g");
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS((exports) => {
  var defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val2) {
      return val2;
    },
    attributeValueProcessor: function(attrName, val2) {
      return val2;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
  };
  var buildOptions = function(options3) {
    return Object.assign({}, defaultOptions, options3);
  };
  exports.buildOptions = buildOptions;
  exports.defaultOptions = defaultOptions;
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS((exports, module) => {
  class XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val2) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val2 });
    }
    addChild(node3) {
      if (node3.tagname === "__proto__")
        node3.tagname = "#__proto__";
      if (node3[":@"] && Object.keys(node3[":@"]).length > 0) {
        this.child.push({ [node3.tagname]: node3.child, [":@"]: node3[":@"] });
      } else {
        this.child.push({ [node3.tagname]: node3.child });
      }
    }
  }
  module.exports = XmlNode;
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS((exports, module) => {
  function readDocType(xmlData, i2) {
    const entities = {};
    if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
      i2 = i2 + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (;i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i2)) {
            i2 += 7;
            [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement(xmlData, i2))
            i2 += 8;
          else if (hasBody && isAttlist(xmlData, i2))
            i2 += 8;
          else if (hasBody && isNotation(xmlData, i2))
            i2 += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i2] === ">") {
          if (comment) {
            if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i2] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i2];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i: i2 };
  }
  function readEntityExp(xmlData, i2) {
    let entityName2 = "";
    for (;i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
      entityName2 += xmlData[i2];
    }
    entityName2 = entityName2.trim();
    if (entityName2.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i2++];
    let val2 = "";
    for (;i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
      val2 += xmlData[i2];
    }
    return [entityName2, val2, i2];
  }
  function isComment(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
      return true;
    return false;
  }
  function isEntity(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
      return true;
    return false;
  }
  function isElement(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
      return true;
    return false;
  }
  function isAttlist(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
      return true;
    return false;
  }
  function isNotation(xmlData, i2) {
    if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
      return true;
    return false;
  }
  function validateEntityName(name) {
    if (util.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  var util = require_util9();
  module.exports = readDocType;
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS((exports, module) => {
  function toNumber(str, options3 = {}) {
    options3 = Object.assign({}, consider, options3);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options3.skipLike !== undefined && options3.skipLike.test(trimmedStr))
      return str;
    else if (options3.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options3.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options3.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options3.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options3.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  }
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  var consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
  };
  module.exports = toNumber;
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS((exports, module) => {
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i2 = 0;i2 < entKeys.length; i2++) {
      const ent = entKeys[i2];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val2 !== undefined) {
      if (this.options.trimValues && !dontTrim) {
        val2 = val2.trim();
      }
      if (val2.length > 0) {
        if (!escapeEntities)
          val2 = this.replaceEntitiesValue(val2);
        const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === undefined) {
          return val2;
        } else if (typeof newval !== typeof val2 || newval !== val2) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val2.trim();
          if (trimmedVal === val2) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val2;
          }
        }
      }
    }
  }
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (!this.options.ignoreAttributes && typeof attrStr === "string") {
      const matches = util.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i2 = 0;i2 < len; i2++) {
        const attrName = this.resolveNameSpace(matches[i2][1]);
        let oldVal = matches[i2][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== undefined) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === undefined) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  function addChild(currentNode, childNode, jPath) {
    const result5 = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result5 === false) {
    } else if (typeof result5 === "string") {
      childNode.tagname = result5;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  }
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === undefined)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
      if (textData !== undefined && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  }
  function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i2;index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "\t") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  function findClosingIndex(xmlData, str, i2, errMsg) {
    const closingIndex = xmlData.indexOf(str, i2);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
    const result5 = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
    if (!result5)
      return;
    let tagExp = result5.data;
    const closeIndex = result5.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substring(0, separatorIndex);
      tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result5.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent,
      rawTagName
    };
  }
  function readStopNodeData(xmlData, tagName, i2) {
    const startIndex = i2;
    let openTagCount = 1;
    for (;i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<") {
        if (xmlData[i2 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i2),
                i: closeIndex
              };
            }
          }
          i2 = closeIndex;
        } else if (xmlData[i2 + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
          i2 = closeIndex;
        } else if (xmlData.substr(i2 + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
          i2 = closeIndex;
        } else if (xmlData.substr(i2 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
          i2 = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i2, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i2 = tagData.closeIndex;
          }
        }
      }
    }
  }
  function parseValue(val2, shouldParse, options3) {
    if (shouldParse && typeof val2 === "string") {
      const newval = val2.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val2, options3);
    } else {
      if (util.isExist(val2)) {
        return val2;
      } else {
        return "";
      }
    }
  }
  var util = require_util9();
  var xmlNode = require_xmlNode();
  var readDocType = require_DocTypeReader();
  var toNumber = require_strnum();

  class OrderedObjParser {
    constructor(options3) {
      this.options = options3;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: "\"" }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        cent: { regex: /&(cent|#162);/g, val: "\xA2" },
        pound: { regex: /&(pound|#163);/g, val: "\xA3" },
        yen: { regex: /&(yen|#165);/g, val: "\xA5" },
        euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
        copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
        reg: { regex: /&(reg|#174);/g, val: "\xAE" },
        inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
    }
  }
  var attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', "gm");
  var parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i2 = 0;i2 < xmlData.length; i2++) {
      const ch = xmlData[i2];
      if (ch === "<") {
        if (xmlData[i2 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i2 = closeIndex;
        } else if (xmlData[i2 + 1] === "?") {
          let tagData = readTagExp(xmlData, i2, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
          } else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i2 = tagData.closeIndex + 1;
        } else if (xmlData.substr(i2 + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i2 + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i2 = endIndex;
        } else if (xmlData.substr(i2 + 1, 2) === "!D") {
          const result5 = readDocType(xmlData, i2);
          this.docTypeEntities = result5.entities;
          i2 = result5.i;
        } else if (xmlData.substr(i2 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i2 + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
          if (val2 == undefined)
            val2 = "";
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            currentNode.add(this.options.textNodeName, val2);
          }
          i2 = closeIndex + 2;
        } else {
          let result5 = readTagExp(xmlData, i2, this.options.removeNSPrefix);
          let tagName = result5.tagName;
          const rawTagName = result5.rawTagName;
          let tagExp = result5.tagExp;
          let attrExpPresent = result5.attrExpPresent;
          let closeIndex = result5.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              i2 = result5.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i2 = result5.closeIndex;
            } else {
              const result6 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
              if (!result6)
                throw new Error(`Unexpected end of ${rawTagName}`);
              i2 = result6.i;
              tagContent = result6.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i2 = closeIndex;
          }
        }
      } else {
        textData += xmlData[i2];
      }
    }
    return xmlObj.child;
  };
  var replaceEntitiesValue = function(val2) {
    if (this.options.processEntities) {
      for (let entityName2 in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName2];
        val2 = val2.replace(entity.regx, entity.val);
      }
      for (let entityName2 in this.lastEntities) {
        const entity = this.lastEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName2 in this.htmlEntities) {
          const entity = this.htmlEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
      }
      val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val2;
  };
  module.exports = OrderedObjParser;
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS((exports) => {
  function prettify(node3, options3) {
    return compress(node3, options3);
  }
  function compress(arr, options3, jPath) {
    let text;
    const compressedObj = {};
    for (let i2 = 0;i2 < arr.length; i2++) {
      const tagObj = arr[i2];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === undefined)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options3.textNodeName) {
        if (text === undefined)
          text = tagObj[property];
        else
          text += "" + tagObj[property];
      } else if (property === undefined) {
        continue;
      } else if (tagObj[property]) {
        let val2 = compress(tagObj[property], options3, newJpath);
        const isLeaf = isLeafTag(val2, options3);
        if (tagObj[":@"]) {
          assignAttributes(val2, tagObj[":@"], newJpath, options3);
        } else if (Object.keys(val2).length === 1 && val2[options3.textNodeName] !== undefined && !options3.alwaysCreateTextNode) {
          val2 = val2[options3.textNodeName];
        } else if (Object.keys(val2).length === 0) {
          if (options3.alwaysCreateTextNode)
            val2[options3.textNodeName] = "";
          else
            val2 = "";
        }
        if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val2);
        } else {
          if (options3.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val2];
          } else {
            compressedObj[property] = val2;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0)
        compressedObj[options3.textNodeName] = text;
    } else if (text !== undefined)
      compressedObj[options3.textNodeName] = text;
    return compressedObj;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (key !== ":@")
        return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath, options3) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i2 = 0;i2 < len; i2++) {
        const atrrName = keys[i2];
        if (options3.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  function isLeafTag(obj, options3) {
    const { textNodeName } = options3;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  exports.prettify = prettify;
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS((exports, module) => {
  var { buildOptions } = require_OptionsBuilder();
  var OrderedObjParser = require_OrderedObjParser();
  var { prettify } = require_node2json();
  var validator = require_validator();

  class XMLParser {
    constructor(options3) {
      this.externalEntities = {};
      this.options = buildOptions(options3);
    }
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {
      } else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result5 = validator.validate(xmlData, validationOption);
        if (result5 !== true) {
          throw Error(`${result5.err.msg}:${result5.err.line}:${result5.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    addEntity(key, value) {
      if (value.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value;
      }
    }
  }
  module.exports = XMLParser;
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS((exports, module) => {
  function toXml(jArray, options3) {
    let indentation = "";
    if (options3.format && options3.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options3, "", indentation);
  }
  function arrToStr(arr, options3, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i2 = 0;i2 < arr.length; i2++) {
      const tagObj = arr[i2];
      const tagName = propName(tagObj);
      if (tagName === undefined)
        continue;
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options3.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options3)) {
          tagText = options3.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options3);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options3.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options3.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options3.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options3.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options3);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options3.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options3.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options3);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options3, newJPath, newIdentation);
      if (options3.unpairedTags.indexOf(tagName) !== -1) {
        if (options3.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options3.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options3.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i2 = 0;i2 < keys.length; i2++) {
      const key = keys[i2];
      if (!obj.hasOwnProperty(key))
        continue;
      if (key !== ":@")
        return key;
    }
  }
  function attr_to_str(attrMap, options3) {
    let attrStr = "";
    if (attrMap && !options3.ignoreAttributes) {
      for (let attr in attrMap) {
        if (!attrMap.hasOwnProperty(attr))
          continue;
        let attrVal = options3.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options3);
        if (attrVal === true && options3.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options3.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options3.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  }
  function isStopNode(jPath, options3) {
    jPath = jPath.substr(0, jPath.length - options3.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options3.stopNodes) {
      if (options3.stopNodes[index] === jPath || options3.stopNodes[index] === "*." + tagName)
        return true;
    }
    return false;
  }
  function replaceEntitiesValue(textValue, options3) {
    if (textValue && textValue.length > 0 && options3.processEntities) {
      for (let i2 = 0;i2 < options3.entities.length; i2++) {
        const entity = options3.entities[i2];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
  var EOL = "\n";
  module.exports = toXml;
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS((exports, module) => {
  function Builder(options3) {
    this.options = Object.assign({}, defaultOptions, options3);
    if (this.options.ignoreAttributes || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = ">\n";
      this.newLine = "\n";
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  }
  function processTextOrObjNode(object, key, level) {
    const result5 = this.j2x(object, level + 1);
    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
      return this.buildTextValNode(object[this.options.textNodeName], key, result5.attrStr, level);
    } else {
      return this.buildObjectNode(result5.val, key, result5.attrStr, level);
    }
  }
  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }
  function isAttribute(name) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }
  var buildFromOrderedJs = require_orderedJs2Xml();
  var defaultOptions = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a2) {
      return a2;
    },
    attributeValueProcessor: function(attrName, a2) {
      return a2;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("\'", "g"), val: "&apos;" },
      { regex: new RegExp("\"", "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    oneListGroup: false
  };
  Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0).val;
    }
  };
  Builder.prototype.j2x = function(jObj, level) {
    let attrStr = "";
    let val2 = "";
    for (let key in jObj) {
      if (!Object.prototype.hasOwnProperty.call(jObj, key))
        continue;
      if (typeof jObj[key] === "undefined") {
        if (this.isAttribute(key)) {
          val2 += "";
        }
      } else if (jObj[key] === null) {
        if (this.isAttribute(key)) {
          val2 += "";
        } else if (key[0] === "?") {
          val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        } else {
          val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (jObj[key] instanceof Date) {
        val2 += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val2 += this.replaceEntitiesValue(newval);
          } else {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        let listTagAttr = "";
        for (let j = 0;j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === "undefined") {
          } else if (item === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              const result5 = this.j2x(item, level + 1);
              listTagVal += result5.val;
              if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                listTagAttr += result5.attrStr;
              }
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level);
            }
          } else {
            if (this.options.oneListGroup) {
              let textValue = this.options.tagValueProcessor(key, item);
              textValue = this.replaceEntitiesValue(textValue);
              listTagVal += textValue;
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
        }
        val2 += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L = Ks.length;
          for (let j = 0;j < L; j++) {
            attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
          }
        } else {
          val2 += this.processTextOrObjNode(jObj[key], key, level);
        }
      }
    }
    return { attrStr, val: val2 };
  };
  Builder.prototype.buildAttrPairStr = function(attrName, val2) {
    val2 = this.options.attributeValueProcessor(attrName, "" + val2);
    val2 = this.replaceEntitiesValue(val2);
    if (this.options.suppressBooleanAttributes && val2 === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val2 + '"';
  };
  Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
    if (val2 === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val2);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i2 = 0;i2 < this.options.entities.length; i2++) {
        const entity = this.options.entities[i2];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  module.exports = Builder;
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS((exports, module) => {
  var validator = require_validator();
  var XMLParser = require_XMLParser();
  var XMLBuilder = require_json2xml();
  module.exports = {
    XMLParser,
    XMLValidator: validator,
    XMLBuilder
  };
});

// node_modules/@azure/core-xml/dist/commonjs/xml.common.js
var require_xml_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-xml/dist/commonjs/xml.js
var require_xml = __commonJS((exports) => {
  function getCommonOptions(options3) {
    var _a;
    return {
      attributesGroupName: xml_common_js_1.XML_ATTRKEY,
      textNodeName: (_a = options3.xmlCharKey) !== null && _a !== undefined ? _a : xml_common_js_1.XML_CHARKEY,
      ignoreAttributes: false,
      suppressBooleanAttributes: false
    };
  }
  function getSerializerOptions(options3 = {}) {
    var _a, _b;
    return Object.assign(Object.assign({}, getCommonOptions(options3)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a = options3.rootName) !== null && _a !== undefined ? _a : "root", cdataPropName: (_b = options3.cdataPropName) !== null && _b !== undefined ? _b : "__cdata" });
  }
  function getParserOptions(options3 = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options3)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options3.stopNodes, processEntities: true });
  }
  function stringifyXML(obj, opts = {}) {
    const parserOptions = getSerializerOptions(opts);
    const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
    const node3 = { [parserOptions.rootNodeName]: obj };
    const xmlData = j2x.build(node3);
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
  }
  async function parseXML(str, opts = {}) {
    if (!str) {
      throw new Error("Document is empty");
    }
    const validation6 = fast_xml_parser_1.XMLValidator.validate(str);
    if (validation6 !== true) {
      throw validation6;
    }
    const parser = new fast_xml_parser_1.XMLParser(getParserOptions(opts));
    const parsedXml = parser.parse(str);
    if (parsedXml["?xml"]) {
      delete parsedXml["?xml"];
    }
    if (!opts.includeRoot) {
      for (const key of Object.keys(parsedXml)) {
        const value = parsedXml[key];
        return typeof value === "object" ? Object.assign({}, value) : value;
      }
    }
    return parsedXml;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringifyXML = stringifyXML;
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp();
  var xml_common_js_1 = require_xml_common();
});

// node_modules/@azure/core-xml/dist/commonjs/index.js
var require_commonjs10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = undefined;
  var xml_js_1 = require_xml();
  Object.defineProperty(exports, "stringifyXML", { enumerable: true, get: function() {
    return xml_js_1.stringifyXML;
  } });
  Object.defineProperty(exports, "parseXML", { enumerable: true, get: function() {
    return xml_js_1.parseXML;
  } });
  var xml_common_js_1 = require_xml_common();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_CHARKEY;
  } });
});

// node_modules/@azure/abort-controller/dist/index.js
var require_dist5 = __commonJS((exports) => {
  function abortSignal(signal5) {
    if (signal5.aborted) {
      return;
    }
    if (signal5.onabort) {
      signal5.onabort.call(signal5);
    }
    const listeners = listenersMap.get(signal5);
    if (listeners) {
      listeners.slice().forEach((listener) => {
        listener.call(signal5, { type: "abort" });
      });
    }
    abortedMap.set(signal5, true);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var listenersMap = new WeakMap;
  var abortedMap = new WeakMap;

  class AbortSignal2 {
    constructor() {
      this.onabort = null;
      listenersMap.set(this, []);
      abortedMap.set(this, false);
    }
    get aborted() {
      if (!abortedMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      return abortedMap.get(this);
    }
    static get none() {
      return new AbortSignal2;
    }
    addEventListener(_type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      const listeners = listenersMap.get(this);
      listeners.push(listener);
    }
    removeEventListener(_type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      const listeners = listenersMap.get(this);
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    dispatchEvent(_event) {
      throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
  }

  class AbortError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "AbortError";
    }
  }

  class AbortController2 {
    constructor(parentSignals) {
      this._signal = new AbortSignal2;
      if (!parentSignals) {
        return;
      }
      if (!Array.isArray(parentSignals)) {
        parentSignals = arguments;
      }
      for (const parentSignal of parentSignals) {
        if (parentSignal.aborted) {
          this.abort();
        } else {
          parentSignal.addEventListener("abort", () => {
            this.abort();
          });
        }
      }
    }
    get signal() {
      return this._signal;
    }
    abort() {
      abortSignal(this._signal);
    }
    static timeout(ms) {
      const signal5 = new AbortSignal2;
      const timer = setTimeout(abortSignal, ms, signal5);
      if (typeof timer.unref === "function") {
        timer.unref();
      }
      return signal5;
    }
  }
  exports.AbortController = AbortController2;
  exports.AbortError = AbortError;
  exports.AbortSignal = AbortSignal2;
});

// node_modules/@azure/core-lro/dist/commonjs/logger.js
var require_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs();
  exports.logger = (0, logger_1.createClientLogger)("core-lro");
});

// node_modules/@azure/core-lro/dist/commonjs/poller/constants.js
var require_constants8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.terminalStates = exports.POLL_INTERVAL_IN_MS = undefined;
  exports.POLL_INTERVAL_IN_MS = 2000;
  exports.terminalStates = ["succeeded", "canceled", "failed"];
});

// node_modules/@azure/core-lro/dist/commonjs/poller/operation.js
var require_operation = __commonJS((exports) => {
  function deserializeState(serializedState) {
    try {
      return JSON.parse(serializedState).state;
    } catch (e) {
      throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
  }
  function setStateError(inputs) {
    const { state, stateProxy, isOperationError } = inputs;
    return (error2) => {
      if (isOperationError(error2)) {
        stateProxy.setError(state, error2);
        stateProxy.setFailed(state);
      }
      throw error2;
    };
  }
  function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message2 = currentMessage;
    if (message2.slice(-1) !== ".") {
      message2 = message2 + ".";
    }
    return message2 + " " + innerMessage;
  }
  function simplifyError(err) {
    let message2 = err.message;
    let code = err.code;
    let curErr = err;
    while (curErr.innererror) {
      curErr = curErr.innererror;
      code = curErr.code;
      message2 = appendReadableErrorMessage(message2, curErr.message);
    }
    return {
      code,
      message: message2
    };
  }
  function processOperationStatus(result5) {
    const { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result5;
    switch (status) {
      case "succeeded": {
        stateProxy.setSucceeded(state);
        break;
      }
      case "failed": {
        const err = getError === null || getError === undefined ? undefined : getError(response);
        let postfix = "";
        if (err) {
          const { code, message: message2 } = simplifyError(err);
          postfix = `. ${code}. ${message2}`;
        }
        const errStr = `The long-running operation has failed${postfix}`;
        stateProxy.setError(state, new Error(errStr));
        stateProxy.setFailed(state);
        logger_js_1.logger.warning(errStr);
        break;
      }
      case "canceled": {
        stateProxy.setCanceled(state);
        break;
      }
    }
    if ((isDone === null || isDone === undefined ? undefined : isDone(response, state)) || isDone === undefined && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
      stateProxy.setResult(state, buildResult({
        response,
        state,
        processResult
      }));
    }
  }
  function buildResult(inputs) {
    const { processResult, response, state } = inputs;
    return processResult ? processResult(response, state) : response;
  }
  async function initOperation(inputs) {
    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
    const { operationLocation, resourceLocation, metadata, response } = await init();
    if (operationLocation)
      withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
    const config = {
      metadata,
      operationLocation,
      resourceLocation
    };
    logger_js_1.logger.verbose(`LRO: Operation description:`, config);
    const state = stateProxy.initState(config);
    const status = getOperationStatus({ response, state, operationLocation });
    processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });
    return state;
  }
  async function pollOperationHelper(inputs) {
    const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options: options3 } = inputs;
    const response = await poll(operationLocation, options3).catch(setStateError({
      state,
      stateProxy,
      isOperationError
    }));
    const status = getOperationStatus(response, state);
    logger_js_1.logger.verbose(`LRO: Status:\n\tPolling from: ${state.config.operationLocation}\n\tOperation status: ${status}\n\tPolling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
    if (status === "succeeded") {
      const resourceLocation = getResourceLocation(response, state);
      if (resourceLocation !== undefined) {
        return {
          response: await poll(resourceLocation).catch(setStateError({ state, stateProxy, isOperationError })),
          status
        };
      }
    }
    return { response, status };
  }
  async function pollOperation(inputs) {
    const { poll, state, stateProxy, options: options3, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
    const { operationLocation } = state.config;
    if (operationLocation !== undefined) {
      const { response, status } = await pollOperationHelper({
        poll,
        getOperationStatus,
        state,
        stateProxy,
        operationLocation,
        getResourceLocation,
        isOperationError,
        options: options3
      });
      processOperationStatus({
        status,
        response,
        state,
        stateProxy,
        isDone,
        processResult,
        getError,
        setErrorAsResult
      });
      if (!constants_js_1.terminalStates.includes(status)) {
        const intervalInMs = getPollingInterval === null || getPollingInterval === undefined ? undefined : getPollingInterval(response);
        if (intervalInMs)
          setDelay(intervalInMs);
        const location = getOperationLocation === null || getOperationLocation === undefined ? undefined : getOperationLocation(response, state);
        if (location !== undefined) {
          const isUpdated = operationLocation !== location;
          state.config.operationLocation = location;
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(location, isUpdated);
        } else
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
      }
      updateState === null || updateState === undefined || updateState(state, response);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollOperation = exports.initOperation = exports.deserializeState = undefined;
  var logger_js_1 = require_logger();
  var constants_js_1 = require_constants8();
  exports.deserializeState = deserializeState;
  exports.initOperation = initOperation;
  exports.pollOperation = pollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/http/operation.js
var require_operation2 = __commonJS((exports) => {
  function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== undefined ? operationLocation : azureAsyncOperation;
  }
  function getLocationHeader(rawResponse) {
    return rawResponse.headers["location"];
  }
  function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
  }
  function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
  }
  function findResourceLocation(inputs) {
    var _a;
    const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
      case "PUT": {
        return requestPath;
      }
      case "DELETE": {
        return;
      }
      case "PATCH": {
        return (_a = getDefault()) !== null && _a !== undefined ? _a : requestPath;
      }
      default: {
        return getDefault();
      }
    }
    function getDefault() {
      switch (resourceLocationConfig) {
        case "azure-async-operation": {
          return;
        }
        case "original-uri": {
          return requestPath;
        }
        case "location":
        default: {
          return location;
        }
      }
    }
  }
  function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
    const operationLocation = getOperationLocationHeader(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
    const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
    const location = getLocationHeader(rawResponse);
    const normalizedRequestMethod = requestMethod === null || requestMethod === undefined ? undefined : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== undefined) {
      return {
        mode: "OperationLocation",
        operationLocation: pollingUrl,
        resourceLocation: findResourceLocation({
          requestMethod: normalizedRequestMethod,
          location,
          requestPath,
          resourceLocationConfig
        })
      };
    } else if (location !== undefined) {
      return {
        mode: "ResourceLocation",
        operationLocation: location
      };
    } else if (normalizedRequestMethod === "PUT" && requestPath) {
      return {
        mode: "Body",
        operationLocation: requestPath
      };
    } else {
      return;
    }
  }
  function transformStatus(inputs) {
    const { status, statusCode } = inputs;
    if (typeof status !== "string" && status !== undefined) {
      throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
    }
    switch (status === null || status === undefined ? undefined : status.toLocaleLowerCase()) {
      case undefined:
        return toOperationStatus(statusCode);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default: {
        logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
        return status;
      }
    }
  }
  function getStatus(rawResponse) {
    var _a;
    const { status } = (_a = rawResponse.body) !== null && _a !== undefined ? _a : {};
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function getProvisioningState(rawResponse) {
    var _a, _b;
    const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== undefined ? _a : {};
    const status = (_b = properties === null || properties === undefined ? undefined : properties.provisioningState) !== null && _b !== undefined ? _b : provisioningState;
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function toOperationStatus(statusCode) {
    if (statusCode === 202) {
      return "running";
    } else if (statusCode < 300) {
      return "succeeded";
    } else {
      return "failed";
    }
  }
  function parseRetryAfter({ rawResponse }) {
    const retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== undefined) {
      const retryAfterInSeconds = parseInt(retryAfter);
      return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;
    }
    return;
  }
  function getErrorFromResponse(response) {
    const error2 = accessBodyProperty(response, "error");
    if (!error2) {
      logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
      return;
    }
    if (!error2.code || !error2.message) {
      logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
      return;
    }
    return error2;
  }
  function calculatePollingIntervalFromDate(retryAfterDate) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
      return retryAfterTime - timeNow;
    }
    return;
  }
  function getStatusFromInitialResponse(inputs) {
    const { response, state, operationLocation } = inputs;
    function helper() {
      var _a;
      const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
      switch (mode) {
        case undefined:
          return toOperationStatus(response.rawResponse.statusCode);
        case "Body":
          return getOperationStatus(response, state);
        default:
          return "running";
      }
    }
    const status = helper();
    return status === "running" && operationLocation === undefined ? "succeeded" : status;
  }
  async function initHttpOperation(inputs) {
    const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
    return (0, operation_js_1.initOperation)({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = inferLroMode({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      stateProxy,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse,
      getOperationStatus: getStatusFromInitialResponse,
      setErrorAsResult
    });
  }
  function getOperationLocation({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      }
      case "ResourceLocation": {
        return getLocationHeader(rawResponse);
      }
      case "Body":
      default: {
        return;
      }
    }
  }
  function getOperationStatus({ rawResponse }, state) {
    var _a;
    const mode = (_a = state.config.metadata) === null || _a === undefined ? undefined : _a["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getStatus(rawResponse);
      }
      case "ResourceLocation": {
        return toOperationStatus(rawResponse.statusCode);
      }
      case "Body": {
        return getProvisioningState(rawResponse);
      }
      default:
        throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
    }
  }
  function accessBodyProperty({ flatResponse, rawResponse }, prop) {
    var _a, _b;
    return (_a = flatResponse === null || flatResponse === undefined ? undefined : flatResponse[prop]) !== null && _a !== undefined ? _a : (_b = rawResponse.body) === null || _b === undefined ? undefined : _b[prop];
  }
  function getResourceLocation(res, state) {
    const loc = accessBodyProperty(res, "resourceLocation");
    if (loc && typeof loc === "string") {
      state.config.resourceLocation = loc;
    }
    return state.config.resourceLocation;
  }
  function isOperationError(e) {
    return e.name === "RestError";
  }
  async function pollHttpOperation(inputs) {
    const { lro, stateProxy, options: options3, processResult, updateState, setDelay, state, setErrorAsResult } = inputs;
    return (0, operation_js_1.pollOperation)({
      state,
      stateProxy,
      setDelay,
      processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
      getError: getErrorFromResponse,
      updateState,
      getPollingInterval: parseRetryAfter,
      getOperationLocation,
      getOperationStatus,
      isOperationError,
      getResourceLocation,
      options: options3,
      poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
      setErrorAsResult
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = undefined;
  var operation_js_1 = require_operation();
  var logger_js_1 = require_logger();
  exports.inferLroMode = inferLroMode;
  exports.parseRetryAfter = parseRetryAfter;
  exports.getErrorFromResponse = getErrorFromResponse;
  exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
  exports.initHttpOperation = initHttpOperation;
  exports.getOperationLocation = getOperationLocation;
  exports.getOperationStatus = getOperationStatus;
  exports.getResourceLocation = getResourceLocation;
  exports.isOperationError = isOperationError;
  exports.pollHttpOperation = pollHttpOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/poller/poller.js
var require_poller = __commonJS((exports) => {
  function buildCreatePoller(inputs) {
    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
    return async ({ init, poll }, options3) => {
      const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options3 || {};
      const stateProxy = createStateProxy();
      const withOperationLocation = withOperationLocationCallback ? (() => {
        let called = false;
        return (operationLocation, isUpdated) => {
          if (isUpdated)
            withOperationLocationCallback(operationLocation);
          else if (!called)
            withOperationLocationCallback(operationLocation);
          called = true;
        };
      })() : undefined;
      const state = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
        init,
        stateProxy,
        processResult,
        getOperationStatus: getStatusFromInitialResponse,
        withOperationLocation,
        setErrorAsResult: !resolveOnUnsuccessful
      });
      let resultPromise;
      const abortController = new AbortController;
      const handlers = new Map;
      const handleProgressEvents = async () => handlers.forEach((h2) => h2(state));
      const cancelErrMsg = "Operation was canceled";
      let currentPollIntervalInMs = intervalInMs;
      const poller = {
        getOperationState: () => state,
        getResult: () => state.result,
        isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
        isStopped: () => resultPromise === undefined,
        stopPolling: () => {
          abortController.abort();
        },
        toString: () => JSON.stringify({
          state
        }),
        onProgress: (callback) => {
          const s = Symbol();
          handlers.set(s, callback);
          return () => handlers.delete(s);
        },
        pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== undefined ? resultPromise : resultPromise = (async () => {
          const { abortSignal: inputAbortSignal } = pollOptions || {};
          function abortListener() {
            abortController.abort();
          }
          const abortSignal = abortController.signal;
          if (inputAbortSignal === null || inputAbortSignal === undefined ? undefined : inputAbortSignal.aborted) {
            abortController.abort();
          } else if (!abortSignal.aborted) {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.addEventListener("abort", abortListener, { once: true });
          }
          try {
            if (!poller.isDone()) {
              await poller.poll({ abortSignal });
              while (!poller.isDone()) {
                await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal });
                await poller.poll({ abortSignal });
              }
            }
          } finally {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.removeEventListener("abort", abortListener);
          }
          if (resolveOnUnsuccessful) {
            return poller.getResult();
          } else {
            switch (state.status) {
              case "succeeded":
                return poller.getResult();
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
              case "notStarted":
              case "running":
                throw new Error(`Polling completed without succeeding or failing`);
            }
          }
        })().finally(() => {
          resultPromise = undefined;
        }),
        async poll(pollOptions) {
          if (resolveOnUnsuccessful) {
            if (poller.isDone())
              return;
          } else {
            switch (state.status) {
              case "succeeded":
                return;
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
            }
          }
          await (0, operation_js_1.pollOperation)({
            poll,
            state,
            stateProxy,
            getOperationLocation,
            isOperationError,
            withOperationLocation,
            getPollingInterval,
            getOperationStatus: getStatusFromPollResponse,
            getResourceLocation,
            processResult,
            getError,
            updateState,
            options: pollOptions,
            setDelay: (pollIntervalInMs) => {
              currentPollIntervalInMs = pollIntervalInMs;
            },
            setErrorAsResult: !resolveOnUnsuccessful
          });
          await handleProgressEvents();
          if (!resolveOnUnsuccessful) {
            switch (state.status) {
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state.error;
            }
          }
        }
      };
      return poller;
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildCreatePoller = undefined;
  var operation_js_1 = require_operation();
  var constants_js_1 = require_constants8();
  var core_util_1 = require_commonjs3();
  var createStateProxy = () => ({
    initState: (config) => ({ status: "running", config }),
    setCanceled: (state) => state.status = "canceled",
    setError: (state, error2) => state.error = error2,
    setResult: (state, result5) => state.result = result5,
    setRunning: (state) => state.status = "running",
    setSucceeded: (state) => state.status = "succeeded",
    setFailed: (state) => state.status = "failed",
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => state.status === "canceled",
    isFailed: (state) => state.status === "failed",
    isRunning: (state) => state.status === "running",
    isSucceeded: (state) => state.status === "succeeded"
  });
  exports.buildCreatePoller = buildCreatePoller;
});

// node_modules/@azure/core-lro/dist/commonjs/http/poller.js
var require_poller2 = __commonJS((exports) => {
  async function createHttpPoller(lro, options3) {
    const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options3 || {};
    return (0, poller_js_1.buildCreatePoller)({
      getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
      getStatusFromPollResponse: operation_js_1.getOperationStatus,
      isOperationError: operation_js_1.isOperationError,
      getOperationLocation: operation_js_1.getOperationLocation,
      getResourceLocation: operation_js_1.getResourceLocation,
      getPollingInterval: operation_js_1.parseRetryAfter,
      getError: operation_js_1.getErrorFromResponse,
      resolveOnUnsuccessful
    })({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = (0, operation_js_1.inferLroMode)({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      poll: lro.sendPollRequest
    }, {
      intervalInMs,
      withOperationLocation,
      restoreFrom,
      updateState,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var operation_js_1 = require_operation2();
  var poller_js_1 = require_poller();
  exports.createHttpPoller = createHttpPoller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js
var require_operation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPollOperation = undefined;
  var operation_js_1 = require_operation2();
  var logger_js_1 = require_logger();
  var createStateProxy = () => ({
    initState: (config) => ({ config, isStarted: true }),
    setCanceled: (state) => state.isCancelled = true,
    setError: (state, error2) => state.error = error2,
    setResult: (state, result5) => state.result = result5,
    setRunning: (state) => state.isStarted = true,
    setSucceeded: (state) => state.isCompleted = true,
    setFailed: () => {
    },
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => !!state.isCancelled,
    isFailed: (state) => !!state.error,
    isRunning: (state) => !!state.isStarted,
    isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error)
  });

  class GenericPollOperation {
    constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
      this.state = state;
      this.lro = lro;
      this.setErrorAsResult = setErrorAsResult;
      this.lroResourceLocationConfig = lroResourceLocationConfig;
      this.processResult = processResult;
      this.updateState = updateState;
      this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
    async update(options3) {
      var _a;
      const stateProxy = createStateProxy();
      if (!this.state.isStarted) {
        this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
          lro: this.lro,
          stateProxy,
          resourceLocationConfig: this.lroResourceLocationConfig,
          processResult: this.processResult,
          setErrorAsResult: this.setErrorAsResult
        }));
      }
      const updateState = this.updateState;
      const isDone = this.isDone;
      if (!this.state.isCompleted && this.state.error === undefined) {
        await (0, operation_js_1.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy,
          processResult: this.processResult,
          updateState: updateState ? (state, { rawResponse }) => updateState(state, rawResponse) : undefined,
          isDone: isDone ? ({ flatResponse }, state) => isDone(flatResponse, state) : undefined,
          options: options3,
          setDelay: (intervalInMs) => {
            this.pollerConfig.intervalInMs = intervalInMs;
          },
          setErrorAsResult: this.setErrorAsResult
        });
      }
      (_a = options3 === null || options3 === undefined ? undefined : options3.fireProgress) === null || _a === undefined || _a.call(options3, this.state);
      return this;
    }
    async cancel() {
      logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
      return this;
    }
    toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }
  exports.GenericPollOperation = GenericPollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js
var require_poller3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = undefined;

  class PollerStoppedError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "PollerStoppedError";
      Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
  }
  exports.PollerStoppedError = PollerStoppedError;

  class PollerCancelledError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "PollerCancelledError";
      Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
  }
  exports.PollerCancelledError = PollerCancelledError;

  class Poller {
    constructor(operation) {
      this.resolveOnUnsuccessful = false;
      this.stopped = true;
      this.pollProgressCallbacks = [];
      this.operation = operation;
      this.promise = new Promise((resolve, reject4) => {
        this.resolve = resolve;
        this.reject = reject4;
      });
      this.promise.catch(() => {
      });
    }
    async startPolling(pollOptions = {}) {
      if (this.stopped) {
        this.stopped = false;
      }
      while (!this.isStopped() && !this.isDone()) {
        await this.poll(pollOptions);
        await this.delay();
      }
    }
    async pollOnce(options3 = {}) {
      if (!this.isDone()) {
        this.operation = await this.operation.update({
          abortSignal: options3.abortSignal,
          fireProgress: this.fireProgress.bind(this)
        });
      }
      this.processUpdatedState();
    }
    fireProgress(state) {
      for (const callback of this.pollProgressCallbacks) {
        callback(state);
      }
    }
    async cancelOnce(options3 = {}) {
      this.operation = await this.operation.cancel(options3);
    }
    poll(options3 = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options3);
        const clearPollOncePromise = () => {
          this.pollOncePromise = undefined;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          this.reject(this.operation.state.error);
          throw this.operation.state.error;
        }
      }
      if (this.operation.state.isCancelled) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          const error2 = new PollerCancelledError("Operation was canceled");
          this.reject(error2);
          throw error2;
        }
      }
      if (this.isDone() && this.resolve) {
        this.resolve(this.getResult());
      }
    }
    async pollUntilDone(pollOptions = {}) {
      if (this.stopped) {
        this.startPolling(pollOptions).catch(this.reject);
      }
      this.processUpdatedState();
      return this.promise;
    }
    onProgress(callback) {
      this.pollProgressCallbacks.push(callback);
      return () => {
        this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c3) => c3 !== callback);
      };
    }
    isDone() {
      const state = this.operation.state;
      return Boolean(state.isCompleted || state.isCancelled || state.error);
    }
    stopPolling() {
      if (!this.stopped) {
        this.stopped = true;
        if (this.reject) {
          this.reject(new PollerStoppedError("This poller is already stopped"));
        }
      }
    }
    isStopped() {
      return this.stopped;
    }
    cancelOperation(options3 = {}) {
      if (!this.cancelPromise) {
        this.cancelPromise = this.cancelOnce(options3);
      } else if (options3.abortSignal) {
        throw new Error("A cancel request is currently pending");
      }
      return this.cancelPromise;
    }
    getOperationState() {
      return this.operation.state;
    }
    getResult() {
      const state = this.operation.state;
      return state.result;
    }
    toString() {
      return this.operation.toString();
    }
  }
  exports.Poller = Poller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js
var require_lroEngine = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var operation_js_1 = require_operation3();
  var constants_js_1 = require_constants8();
  var poller_js_1 = require_poller3();
  var operation_js_2 = require_operation();

  class LroEngine extends poller_js_1.Poller {
    constructor(lro, options3) {
      const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options3 || {};
      const state = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
      const operation = new operation_js_1.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
      super(operation);
      this.resolveOnUnsuccessful = resolveOnUnsuccessful;
      this.config = { intervalInMs };
      operation.setPollerConfig(this.config);
    }
    delay() {
      return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
    }
  }
  exports.LroEngine = LroEngine;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js
var require_lroEngine2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var lroEngine_js_1 = require_lroEngine();
  Object.defineProperty(exports, "LroEngine", { enumerable: true, get: function() {
    return lroEngine_js_1.LroEngine;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js
var require_pollOperation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/core-lro/dist/commonjs/index.js
var require_commonjs11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var tslib_1 = require_tslib();
  var poller_js_1 = require_poller2();
  Object.defineProperty(exports, "createHttpPoller", { enumerable: true, get: function() {
    return poller_js_1.createHttpPoller;
  } });
  tslib_1.__exportStar(require_lroEngine2(), exports);
  tslib_1.__exportStar(require_poller3(), exports);
  tslib_1.__exportStar(require_pollOperation(), exports);
});

// node_modules/@azure/storage-blob/dist/index.js
var require_dist6 = __commonJS((exports) => {
  function _interopNamespaceDefault(e) {
    var n2 = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n2, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n2.default = e;
    return Object.freeze(n2);
  }
  function escapeURLPath(url2) {
    const urlParsed = new URL(url2);
    let path5 = urlParsed.pathname;
    path5 = path5 || "/";
    path5 = escape4(path5);
    urlParsed.pathname = path5;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape4(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url2, name) {
    const urlParsed = new URL(url2);
    let path5 = urlParsed.pathname;
    path5 = path5 ? path5.endsWith("/") ? `${path5}${name}` : `${path5}/${name}` : name;
    urlParsed.pathname = path5;
    return urlParsed.toString();
  }
  function setURLParameter(url2, name, value) {
    const urlParsed = new URL(url2);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : undefined;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url2, name) {
    var _a;
    const urlParsed = new URL(url2);
    return (_a = urlParsed.searchParams.get(name)) !== null && _a !== undefined ? _a : undefined;
  }
  function setURLHost(url2, host) {
    const urlParsed = new URL(url2);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url2) {
    try {
      const urlParsed = new URL(url2);
      return urlParsed.pathname;
    } catch (e) {
      return;
    }
  }
  function getURLScheme(url2) {
    try {
      const urlParsed = new URL(url2);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return;
    }
  }
  function getURLPathAndQuery(url2) {
    const urlParsed = new URL(url2);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url2) {
    let queryString = new URL(url2).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url2, queryParts) {
    const urlParsed = new URL(url2);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000" + "Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode(content) {
    return !coreUtil.isNode ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode(res);
  }
  async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject4) => {
      let timeout3;
      const abortHandler = () => {
        if (timeout3 !== undefined) {
          clearTimeout(timeout3);
        }
        reject4(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== undefined) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve();
      };
      timeout3 = setTimeout(resolveHandler, timeInMs);
      if (aborter !== undefined) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url2) {
    const parsedUrl = new URL(url2);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error2) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && PathStylePorts.includes(parsedUrl.port);
  }
  function toBlobTagsString(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const tagPairs = [];
    for (const key in tags2) {
      if (Object.prototype.hasOwnProperty.call(tags2, key)) {
        const value = tags2[key];
        tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    }
    return tagPairs.join("&");
  }
  function toBlobTags(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const res = {
      blobTagSet: []
    };
    for (const key in tags2) {
      if (Object.prototype.hasOwnProperty.call(tags2, key)) {
        const value = tags2[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    }
    return res;
  }
  function toTags(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const res = {};
    for (const blobTag of tags2.blobTagSet) {
      res[blobTag.key] = blobTag.value;
    }
    return res;
  }
  function toQuerySerialization(textConfiguration) {
    if (textConfiguration === undefined) {
      return;
    }
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || false
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord) {
      return;
    }
    if ("policy-id" in objectReplicationRecord) {
      return;
    }
    const orProperties = [];
    for (const key in objectReplicationRecord) {
      const ids = key.split("_");
      const policyPrefix = "or-";
      if (ids[0].startsWith(policyPrefix)) {
        ids[0] = ids[0].substring(policyPrefix.length);
      }
      const rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key]
      };
      const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
      if (policyIndex > -1) {
        orProperties[policyIndex].rules.push(rule);
      } else {
        orProperties.push({
          policyId: ids[0],
          rules: [rule]
        });
      }
    }
    return orProperties;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
  }
  function BlobNameToString(name) {
    if (name.encoded) {
      return decodeURIComponent(name.content);
    } else {
      return name.content;
    }
  }
  function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return Object.assign(Object.assign({}, internalResponse), { segment: {
      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });
        return blobItem;
      })
    } });
  }
  function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    var _a;
    return Object.assign(Object.assign({}, internalResponse), { segment: {
      blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === undefined ? undefined : _a.map((blobPrefixInternal) => {
        const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), { name: BlobNameToString(blobPrefixInternal.name) });
        return blobPrefix;
      }),
      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });
        return blobItem;
      })
    } });
  }
  function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [];
    let clearRange = [];
    if (getPageRangesSegment.pageRange)
      pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange)
      clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0;
    let clearRangeIndex = 0;
    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {
      if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: false
        };
        ++pageRangeIndex;
      } else {
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: true
        };
        ++clearRangeIndex;
      }
    }
    for (;pageRangeIndex < pageRange.length; ++pageRangeIndex) {
      yield {
        start: pageRange[pageRangeIndex].start,
        end: pageRange[pageRangeIndex].end,
        isClear: false
      };
    }
    for (;clearRangeIndex < clearRange.length; ++clearRangeIndex) {
      yield {
        start: clearRange[clearRangeIndex].start,
        end: clearRange[clearRangeIndex].end,
        isClear: true
      };
    }
  }
  function EscapePath(blobName) {
    const split4 = blobName.split("/");
    for (let i2 = 0;i2 < split4.length; i2++) {
      split4[i2] = encodeURIComponent(split4[i2]);
    }
    return split4.join("/");
  }
  function assertResponse(response) {
    if (`_response` in response) {
      return response;
    }
    throw new TypeError(`Unexpected response object ${response}`);
  }
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    const tables = [table_lv0, table_lv2, table_lv4];
    let curr_level = 0;
    let i2 = 0;
    let j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i2 !== j) {
        return i2 > j;
      }
      const weight1 = i2 < lhs.length ? tables[curr_level][lhs[i2].charCodeAt(0)] : 1;
      const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1) {
        i2 = 0;
        j = 0;
        ++curr_level;
      } else if (weight1 === weight2) {
        ++i2;
        ++j;
      } else if (weight1 === 0) {
        ++i2;
      } else if (weight2 === 0) {
        ++j;
      } else {
        return weight1 < weight2;
      }
    }
    return false;
  }
  function getCachedDefaultHttpClient() {
    if (!_defaultHttpClient) {
      _defaultHttpClient = coreRestPipeline.createDefaultHttpClient();
    }
    return _defaultHttpClient;
  }
  function storageBrowserPolicy() {
    return {
      name: storageBrowserPolicyName,
      async sendRequest(request, next) {
        if (coreUtil.isNode) {
          return next(request);
        }
        if (request.method === "GET" || request.method === "HEAD") {
          request.url = setURLParameter(request.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
        }
        request.headers.delete(HeaderConstants.COOKIE);
        request.headers.delete(HeaderConstants.CONTENT_LENGTH);
        return next(request);
      }
    };
  }
  function storageRetryPolicy(options3 = {}) {
    var _a, _b, _c, _d, _e, _f;
    const retryPolicyType = (_a = options3.retryPolicyType) !== null && _a !== undefined ? _a : DEFAULT_RETRY_OPTIONS.retryPolicyType;
    const maxTries = (_b = options3.maxTries) !== null && _b !== undefined ? _b : DEFAULT_RETRY_OPTIONS.maxTries;
    const retryDelayInMs = (_c = options3.retryDelayInMs) !== null && _c !== undefined ? _c : DEFAULT_RETRY_OPTIONS.retryDelayInMs;
    const maxRetryDelayInMs = (_d = options3.maxRetryDelayInMs) !== null && _d !== undefined ? _d : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
    const secondaryHost = (_e = options3.secondaryHost) !== null && _e !== undefined ? _e : DEFAULT_RETRY_OPTIONS.secondaryHost;
    const tryTimeoutInMs = (_f = options3.tryTimeoutInMs) !== null && _f !== undefined ? _f : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error: error2 }) {
      var _a2, _b2;
      if (attempt >= maxTries) {
        logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
        return false;
      }
      if (error2) {
        for (const retriableError of retriableErrors) {
          if (error2.name.toUpperCase().includes(retriableError) || error2.message.toUpperCase().includes(retriableError) || error2.code && error2.code.toString().toUpperCase() === retriableError) {
            logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
        if ((error2 === null || error2 === undefined ? undefined : error2.code) === "PARSE_ERROR" && (error2 === null || error2 === undefined ? undefined : error2.message.startsWith(`Error "Error: Unclosed root tag`))) {
          logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
          return true;
        }
      }
      if (response || error2) {
        const statusCode = (_b2 = (_a2 = response === null || response === undefined ? undefined : response.status) !== null && _a2 !== undefined ? _a2 : error2 === null || error2 === undefined ? undefined : error2.statusCode) !== null && _b2 !== undefined ? _b2 : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      return false;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (retryPolicyType) {
          case StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType.FIXED:
            delayTimeInMs = retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delayTimeInMs;
    }
    return {
      name: storageRetryPolicyName,
      async sendRequest(request, next) {
        if (tryTimeoutInMs) {
          request.url = setURLParameter(request.url, URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
        }
        const primaryUrl = request.url;
        const secondaryUrl = secondaryHost ? setURLHost(request.url, secondaryHost) : undefined;
        let secondaryHas404 = false;
        let attempt = 1;
        let retryAgain = true;
        let response;
        let error2;
        while (retryAgain) {
          const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
          request.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
          response = undefined;
          error2 = undefined;
          try {
            logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
            response = await next(request);
            secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
          } catch (e) {
            if (coreRestPipeline.isRestError(e)) {
              logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`);
              error2 = e;
            } else {
              logger.error(`RetryPolicy: Caught error, message: ${coreUtil.getErrorMessage(e)}`);
              throw e;
            }
          }
          retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error: error2 });
          if (retryAgain) {
            await delay(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
          }
          attempt++;
        }
        if (response) {
          return response;
        }
        throw error2 !== null && error2 !== undefined ? error2 : new coreRestPipeline.RestError("RetryPolicy failed without known error.");
      }
    };
  }
  function storageSharedKeyCredentialPolicy(options3) {
    function signRequest(request) {
      request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
        request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
      const stringToSign = [
        request.method.toUpperCase(),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
        getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
        getHeaderValueToSign(request, HeaderConstants.DATE),
        getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
        getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
        getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
        getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
        getHeaderValueToSign(request, HeaderConstants.RANGE)
      ].join("\n") + "\n" + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request);
      const signature = crypto.createHmac("sha256", options3.accountKey).update(stringToSign, "utf8").digest("base64");
      request.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${options3.accountName}:${signature}`);
    }
    function getHeaderValueToSign(request, headerName) {
      const value = request.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    function getCanonicalizedHeadersString(request) {
      let headersArray = [];
      for (const [name, value] of request.headers) {
        if (name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE)) {
          headersArray.push({ name, value });
        }
      }
      headersArray.sort((a2, b) => {
        return compareHeader(a2.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array2) => {
        if (index > 0 && value.name.toLowerCase() === array2[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
      });
      return canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request) {
      const path5 = getURLPath(request.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${options3.accountName}${path5}`;
      const queries = getURLQueries(request.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
    return {
      name: storageSharedKeyCredentialPolicyName,
      async sendRequest(request, next) {
        signRequest(request);
        return next(request);
      }
    };
  }
  function storageCorrectContentLengthPolicy() {
    function correctContentLength(request) {
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0) {
        request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
    }
    return {
      name: storageCorrectContentLengthPolicyName,
      async sendRequest(request, next) {
        correctContentLength(request);
        return next(request);
      }
    };
  }
  function isPipelineLike(pipeline4) {
    if (!pipeline4 || typeof pipeline4 !== "object") {
      return false;
    }
    const castPipeline = pipeline4;
    return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
  }
  function newPipeline(credential, pipelineOptions = {}) {
    if (!credential) {
      credential = new AnonymousCredential;
    }
    const pipeline4 = new Pipeline([], pipelineOptions);
    pipeline4._credential = credential;
    return pipeline4;
  }
  function processDownlevelPipeline(pipeline4) {
    const knownFactoryFunctions = [
      isAnonymousCredential,
      isStorageSharedKeyCredential,
      isCoreHttpBearerTokenFactory,
      isStorageBrowserPolicyFactory,
      isStorageRetryPolicyFactory,
      isStorageTelemetryPolicyFactory,
      isCoreHttpPolicyFactory
    ];
    if (pipeline4.factories.length) {
      const novelFactories = pipeline4.factories.filter((factory) => {
        return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
      });
      if (novelFactories.length) {
        const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
        return {
          wrappedPolicies: coreHttpCompat.createRequestPolicyFactoryPolicy(novelFactories),
          afterRetry: hasInjector
        };
      }
    }
    return;
  }
  function getCoreClientOptions(pipeline4) {
    var _a;
    const _b = pipeline4.options, { httpClient: v1Client } = _b, restOptions = tslib.__rest(_b, ["httpClient"]);
    let httpClient = pipeline4._coreHttpClient;
    if (!httpClient) {
      httpClient = v1Client ? coreHttpCompat.convertHttpClient(v1Client) : getCachedDefaultHttpClient();
      pipeline4._coreHttpClient = httpClient;
    }
    let corePipeline = pipeline4._corePipeline;
    if (!corePipeline) {
      const packageDetails = `azsdk-js-azure-storage-blob/${SDK_VERSION}`;
      const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      corePipeline = coreClient.createClientPipeline(Object.assign(Object.assign({}, restOptions), { loggingOptions: {
        additionalAllowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,
        additionalAllowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,
        logger: logger.info
      }, userAgentOptions: {
        userAgentPrefix
      }, serializationOptions: {
        stringifyXML: coreXml.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }, deserializationOptions: {
        parseXML: coreXml.parseXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      } }));
      corePipeline.removePolicy({ phase: "Retry" });
      corePipeline.removePolicy({ name: coreRestPipeline.decompressResponsePolicyName });
      corePipeline.addPolicy(storageCorrectContentLengthPolicy());
      corePipeline.addPolicy(storageRetryPolicy(restOptions.retryOptions), { phase: "Retry" });
      corePipeline.addPolicy(storageBrowserPolicy());
      const downlevelResults = processDownlevelPipeline(pipeline4);
      if (downlevelResults) {
        corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : undefined);
      }
      const credential = getCredentialFromPipeline(pipeline4);
      if (coreAuth.isTokenCredential(credential)) {
        corePipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential,
          scopes: (_a = restOptions.audience) !== null && _a !== undefined ? _a : StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: coreClient.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential) {
        corePipeline.addPolicy(storageSharedKeyCredentialPolicy({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      pipeline4._corePipeline = corePipeline;
    }
    return Object.assign(Object.assign({}, restOptions), { allowInsecureConnection: true, httpClient, pipeline: corePipeline });
  }
  function getCredentialFromPipeline(pipeline4) {
    if (pipeline4._credential) {
      return pipeline4._credential;
    }
    let credential = new AnonymousCredential;
    for (const factory of pipeline4.factories) {
      if (coreAuth.isTokenCredential(factory.credential)) {
        credential = factory.credential;
      } else if (isStorageSharedKeyCredential(factory)) {
        return factory;
      }
    }
    return credential;
  }
  function isStorageSharedKeyCredential(factory) {
    if (factory instanceof StorageSharedKeyCredential) {
      return true;
    }
    return factory.constructor.name === "StorageSharedKeyCredential";
  }
  function isAnonymousCredential(factory) {
    if (factory instanceof AnonymousCredential) {
      return true;
    }
    return factory.constructor.name === "AnonymousCredential";
  }
  function isCoreHttpBearerTokenFactory(factory) {
    return coreAuth.isTokenCredential(factory.credential);
  }
  function isStorageBrowserPolicyFactory(factory) {
    if (factory instanceof StorageBrowserPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageBrowserPolicyFactory";
  }
  function isStorageRetryPolicyFactory(factory) {
    if (factory instanceof StorageRetryPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageRetryPolicyFactory";
  }
  function isStorageTelemetryPolicyFactory(factory) {
    return factory.constructor.name === "TelemetryPolicyFactory";
  }
  function isInjectorPolicyFactory(factory) {
    return factory.constructor.name === "InjectorPolicyFactory";
  }
  function isCoreHttpPolicyFactory(factory) {
    const knownPolicies = [
      "GenerateClientRequestIdPolicy",
      "TracingPolicy",
      "LogPolicy",
      "ProxyPolicy",
      "DisableResponseDecompressionPolicy",
      "KeepAlivePolicy",
      "DeserializationPolicy"
    ];
    const mockHttpClient = {
      sendRequest: async (request) => {
        return {
          request,
          headers: request.headers.clone(),
          status: 500
        };
      }
    };
    const mockRequestPolicyOptions = {
      log(_logLevel, _message) {
      },
      shouldLog(_logLevel) {
        return false;
      }
    };
    const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
    const policyName = policyInstance.constructor.name;
    return knownPolicies.some((knownPolicyName) => {
      return policyName.startsWith(knownPolicyName);
    });
  }
  function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
  }
  function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
    const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : undefined;
    let userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
      userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
      throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    if (version2 >= "2020-12-06") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
      } else {
        return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
      }
    }
    if (version2 >= "2018-11-09") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version2 >= "2020-02-10") {
          return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version2 >= "2015-04-05") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
      } else {
        throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
      }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
  }
  function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    if (blobSASSignatureValues.blobName) {
      resource = "b";
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);
  }
  function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);
  }
  function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope);
  }
  function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey);
  }
  function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId);
  }
  function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join("\n");
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope);
  }
  function getCanonicalName(accountName, containerName, blobName) {
    const elements = [`/blob/${accountName}/${containerName}`];
    if (blobName) {
      elements.push(`/${blobName}`);
    }
    return elements.join("");
  }
  function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
    if (blobSASSignatureValues.snapshotTime && version2 < "2018-11-09") {
      throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {
      throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.versionId && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    }
    if (version2 < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    }
    if (version2 < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
      throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    }
    if (version2 < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    }
    if (blobSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    blobSASSignatureValues.version = version2;
    return blobSASSignatureValues;
  }
  function arraysEqual(a2, b) {
    if (a2 === b)
      return true;
    if (a2 == null || b == null)
      return false;
    if (a2.length !== b.length)
      return false;
    for (let i2 = 0;i2 < a2.length; ++i2) {
      if (a2[i2] !== b[i2])
        return false;
    }
    return true;
  }
  function toAccessTier(tier2) {
    if (tier2 === undefined) {
      return;
    }
    return tier2;
  }
  function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps) {
      throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
    }
    if (cpk && !cpk.encryptionAlgorithm) {
      cpk.encryptionAlgorithm = EncryptionAlgorithmAES25;
    }
  }
  function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
  }
  function rangeResponseFromModel(response) {
    const pageRange = (response._response.parsedBody.pageRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    const clearRange = (response._response.parsedBody.clearRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    return Object.assign(Object.assign({}, response), {
      pageRange,
      clearRange,
      _response: Object.assign(Object.assign({}, response._response), { parsedBody: {
        pageRange,
        clearRange
      } })
    });
  }
  function makeBlobBeginCopyFromURLPollOperation(state) {
    return {
      state: Object.assign({}, state),
      cancel: cancel3,
      toString: toString2,
      update
    };
  }
  function rangeToString(iRange) {
    if (iRange.offset < 0) {
      throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (iRange.count && iRange.count <= 0) {
      throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
  }
  async function streamToBuffer(stream4, buffer2, offset, end, encoding) {
    let pos = 0;
    const count2 = end - offset;
    return new Promise((resolve, reject4) => {
      const timeout3 = setTimeout(() => reject4(new Error(`The operation cannot be completed in timeout.`)), REQUEST_TIMEOUT);
      stream4.on("readable", () => {
        if (pos >= count2) {
          clearTimeout(timeout3);
          resolve();
          return;
        }
        let chunk = stream4.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        const chunkLength = pos + chunk.length > count2 ? count2 - pos : chunk.length;
        buffer2.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
        pos += chunkLength;
      });
      stream4.on("end", () => {
        clearTimeout(timeout3);
        if (pos < count2) {
          reject4(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count2}`));
        }
        resolve();
      });
      stream4.on("error", (msg) => {
        clearTimeout(timeout3);
        reject4(msg);
      });
    });
  }
  async function streamToBuffer2(stream4, buffer2, encoding) {
    let pos = 0;
    const bufferSize = buffer2.length;
    return new Promise((resolve, reject4) => {
      stream4.on("readable", () => {
        let chunk = stream4.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (pos + chunk.length > bufferSize) {
          reject4(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
          return;
        }
        buffer2.fill(chunk, pos, pos + chunk.length);
        pos += chunk.length;
      });
      stream4.on("end", () => {
        resolve(pos);
      });
      stream4.on("error", reject4);
    });
  }
  async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve, reject4) => {
      const ws = fs__namespace.createWriteStream(file);
      rs.on("error", (err) => {
        reject4(err);
      });
      ws.on("error", (err) => {
        reject4(err);
      });
      ws.on("close", resolve);
      rs.pipe(ws);
    });
  }
  async function getBodyAsText(batchResponse) {
    let buffer2 = Buffer.alloc(BATCH_MAX_PAYLOAD_IN_BYTES);
    const responseLength = await streamToBuffer2(batchResponse.readableStreamBody, buffer2);
    buffer2 = buffer2.slice(0, responseLength);
    return buffer2.toString();
  }
  function utf8ByteLength(str) {
    return Buffer.byteLength(str);
  }
  function batchRequestAssemblePolicy(batchRequest) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(request) {
        batchRequest.appendSubRequestToBody(request);
        return {
          request,
          status: 200,
          headers: coreRestPipeline.createHttpHeaders()
        };
      }
    };
  }
  function batchHeaderFilterPolicy() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(request, next) {
        let xMsHeaderName = "";
        for (const [name] of request.headers) {
          if (iEqual(name, HeaderConstants.X_MS_VERSION)) {
            xMsHeaderName = name;
          }
        }
        if (xMsHeaderName !== "") {
          request.headers.delete(xMsHeaderName);
        }
        return next(request);
      }
    };
  }
  function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    const version2 = accountSASSignatureValues.version ? accountSASSignatureValues.version : SERVICE_VERSION;
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    }
    if (accountSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    const parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
    const parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    let stringToSign;
    if (version2 >= "2020-12-06") {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
        ""
      ].join("\n");
    } else {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        ""
      ].join("\n");
    }
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version2, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, accountSASSignatureValues.encryptionScope);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  var coreRestPipeline = require_commonjs6();
  var tslib = require_tslib();
  var coreAuth = require_commonjs7();
  var coreUtil = require_commonjs3();
  var coreHttpCompat = require_commonjs9();
  var coreClient = require_commonjs8();
  var coreXml = require_commonjs10();
  var logger$1 = require_commonjs();
  var abortController = require_dist5();
  var crypto = __require("crypto");
  var coreTracing = require_commonjs5();
  var stream3 = __require("stream");
  var coreLro = require_commonjs11();
  var events = __require("events");
  var fs = __require("fs");
  var util = __require("util");
  var buffer = __require("buffer");
  var coreHttpCompat__namespace = /* @__PURE__ */ _interopNamespaceDefault(coreHttpCompat);
  var coreClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(coreClient);
  var fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
  var util__namespace = /* @__PURE__ */ _interopNamespaceDefault(util);
  var logger = logger$1.createClientLogger("storage-blob");

  class BaseRequestPolicy {
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy;
      this._options = _options;
    }
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    log(logLevel, message2) {
      this._options.log(logLevel, message2);
    }
  }
  var SDK_VERSION = "12.24.0";
  var SERVICE_VERSION = "2024-08-04";
  var BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
  var BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4000 * 1024 * 1024;
  var BLOCK_BLOB_MAX_BLOCKS = 50000;
  var DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
  var DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
  var DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
  var REQUEST_TIMEOUT = 100 * 1000;
  var StorageOAuthScopes = "https://storage.azure.com/.default";
  var URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  var HTTPURLConnection = {
    HTTP_ACCEPTED: 202,
    HTTP_CONFLICT: 409,
    HTTP_NOT_FOUND: 404,
    HTTP_PRECON_FAILED: 412,
    HTTP_RANGE_NOT_SATISFIABLE: 416
  };
  var HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  var ETagNone = "";
  var ETagAny = "*";
  var SIZE_1_MB = 1 * 1024 * 1024;
  var BATCH_MAX_REQUEST = 256;
  var BATCH_MAX_PAYLOAD_IN_BYTES = 4 * SIZE_1_MB;
  var HTTP_LINE_ENDING = "\r\n";
  var HTTP_VERSION_1_1 = "HTTP/1.1";
  var EncryptionAlgorithmAES25 = "AES256";
  var DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
  var StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags"
  ];
  var StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
  ];
  var BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
  var BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
  var PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
  exports.StorageRetryPolicyType = undefined;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
  var DEFAULT_RETRY_OPTIONS$1 = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var RETRY_ABORT_ERROR$1 = new abortController.AbortError("The operation was aborted.");

  class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options3, retryOptions = DEFAULT_RETRY_OPTIONS$1) {
      super(nextPolicy, options3);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS$1.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS$1.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS$1.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS$1.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS$1.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS$1.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS$1.secondaryHost
      };
    }
    async sendRequest(request) {
      return this.attemptSendRequest(request, false, 1);
    }
    async attemptSendRequest(request, secondaryHas404, attempt) {
      const newRequest = request.clone();
      const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry) {
        newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost);
      }
      if (this.retryOptions.tryTimeoutInMs) {
        newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
      }
      let response;
      try {
        logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
        response = await this._nextPolicy.sendRequest(newRequest);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
          return response;
        }
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
      } catch (err) {
        logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
          throw err;
        }
      }
      await this.delay(isPrimaryRetry, attempt, request.abortSignal);
      return this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    shouldRetry(isPrimaryRetry, attempt, response, err) {
      if (attempt >= this.retryOptions.maxTries) {
        logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
        return false;
      }
      const retriableErrors2 = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
      ];
      if (err) {
        for (const retriableError of retriableErrors2) {
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
            logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
      }
      if (response || err) {
        const statusCode = response ? response.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if ((err === null || err === undefined ? undefined : err.code) === "PARSE_ERROR" && (err === null || err === undefined ? undefined : err.message.startsWith(`Error "Error: Unclosed root tag`))) {
        logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
        return true;
      }
      return false;
    }
    async delay(isPrimaryRetry, attempt, abortSignal) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (this.retryOptions.retryPolicyType) {
          case exports.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case exports.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR$1);
    }
  }

  class StorageRetryPolicyFactory {
    constructor(retryOptions) {
      this.retryOptions = retryOptions;
    }
    create(nextPolicy, options3) {
      return new StorageRetryPolicy(nextPolicy, options3, this.retryOptions);
    }
  }

  class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request) {
      return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    signRequest(request) {
      return request;
    }
  }
  var table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]);
  var table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  var table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);

  class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy, options3, factory) {
      super(nextPolicy, options3);
      this.factory = factory;
    }
    signRequest(request) {
      request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request.body && (typeof request.body === "string" || request.body !== undefined) && request.body.length > 0) {
        request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      }
      const stringToSign = [
        request.method.toUpperCase(),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request, HeaderConstants.DATE),
        this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request, HeaderConstants.RANGE)
      ].join("\n") + "\n" + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request);
      const signature = this.factory.computeHMACSHA256(stringToSign);
      request.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
      return request;
    }
    getHeaderValueToSign(request, headerName) {
      const value = request.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    getCanonicalizedHeadersString(request) {
      let headersArray = request.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a2, b) => {
        return compareHeader(a2.name.toLowerCase(), b.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array2) => {
        if (index > 0 && value.name.toLowerCase() === array2[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
      });
      return canonicalizedHeadersStringToSign;
    }
    getCanonicalizedResourceString(request) {
      const path5 = getURLPath(request.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path5}`;
      const queries = getURLQueries(request.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
  }

  class Credential {
    create(_nextPolicy, _options) {
      throw new Error("Method should be implemented in children classes.");
    }
  }

  class StorageSharedKeyCredential extends Credential {
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName;
      this.accountKey = Buffer.from(accountKey, "base64");
    }
    create(nextPolicy, options3) {
      return new StorageSharedKeyCredentialPolicy(nextPolicy, options3, this);
    }
    computeHMACSHA256(stringToSign) {
      return crypto.createHmac("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }

  class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy, options3) {
      super(nextPolicy, options3);
    }
  }

  class AnonymousCredential extends Credential {
    create(nextPolicy, options3) {
      return new AnonymousCredentialPolicy(nextPolicy, options3);
    }
  }
  var _defaultHttpClient;
  var storageBrowserPolicyName = "storageBrowserPolicy";
  var storageRetryPolicyName = "storageRetryPolicy";
  var StorageRetryPolicyType;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(StorageRetryPolicyType || (StorageRetryPolicyType = {}));
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
  ];
  var RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
  var storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";

  class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options3) {
      super(nextPolicy, options3);
    }
    async sendRequest(request) {
      if (coreUtil.isNode) {
        return this._nextPolicy.sendRequest(request);
      }
      if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD") {
        request.url = setURLParameter(request.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
      }
      request.headers.remove(HeaderConstants.COOKIE);
      request.headers.remove(HeaderConstants.CONTENT_LENGTH);
      return this._nextPolicy.sendRequest(request);
    }
  }

  class StorageBrowserPolicyFactory {
    create(nextPolicy, options3) {
      return new StorageBrowserPolicy(nextPolicy, options3);
    }
  }
  var storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";

  class Pipeline {
    constructor(factories, options3 = {}) {
      this.factories = factories;
      this.options = options3;
    }
    toServiceClientOptions() {
      return {
        httpClient: this.options.httpClient,
        requestPolicyFactories: this.factories
      };
    }
  }
  var BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: {
            name: "Composite",
            className: "Logging"
          }
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: true,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "CorsRule"
              }
            }
          }
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: {
            name: "String"
          }
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: {
            name: "Composite",
            className: "StaticWebsite"
          }
        }
      }
    }
  };
  var Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: true,
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        deleteProperty: {
          serializedName: "Delete",
          required: true,
          xmlName: "Delete",
          type: {
            name: "Boolean"
          }
        },
        read: {
          serializedName: "Read",
          required: true,
          xmlName: "Read",
          type: {
            name: "Boolean"
          }
        },
        write: {
          serializedName: "Write",
          required: true,
          xmlName: "Write",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  var RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        days: {
          constraints: {
            InclusiveMinimum: 1
          },
          serializedName: "Days",
          xmlName: "Days",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  var CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: true,
          xmlName: "AllowedOrigins",
          type: {
            name: "String"
          }
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: true,
          xmlName: "AllowedMethods",
          type: {
            name: "String"
          }
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: true,
          xmlName: "AllowedHeaders",
          type: {
            name: "String"
          }
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: true,
          xmlName: "ExposedHeaders",
          type: {
            name: "String"
          }
        },
        maxAgeInSeconds: {
          constraints: {
            InclusiveMinimum: 0
          },
          serializedName: "MaxAgeInSeconds",
          required: true,
          xmlName: "MaxAgeInSeconds",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: {
            name: "String"
          }
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: {
            name: "String"
          }
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: {
            name: "String"
          }
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: {
            name: "String"
          }
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: {
            name: "Composite",
            className: "GeoReplication"
          }
        }
      }
    }
  };
  var GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: true,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"]
          }
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: true,
          xmlName: "LastSyncTime",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: true,
          xmlName: "Containers",
          xmlIsWrapped: true,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ContainerItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "ContainerProperties"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        }
      }
    }
  };
  var ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: {
            name: "String"
          }
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: {
            name: "Boolean"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          required: true,
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: true,
          xmlName: "SignedOid",
          type: {
            name: "String"
          }
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: true,
          xmlName: "SignedTid",
          type: {
            name: "String"
          }
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: true,
          xmlName: "SignedStart",
          type: {
            name: "String"
          }
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: true,
          xmlName: "SignedExpiry",
          type: {
            name: "String"
          }
        },
        signedService: {
          serializedName: "SignedService",
          required: true,
          xmlName: "SignedService",
          type: {
            name: "String"
          }
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: true,
          xmlName: "SignedVersion",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        where: {
          serializedName: "Where",
          required: true,
          xmlName: "Where",
          type: {
            name: "String"
          }
        },
        blobs: {
          serializedName: "Blobs",
          required: true,
          xmlName: "Blobs",
          xmlIsWrapped: true,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "FilterBlobItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          type: {
            name: "String"
          }
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        }
      }
    }
  };
  var BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: true,
          xmlName: "TagSet",
          xmlIsWrapped: true,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobTag"
              }
            }
          }
        }
      }
    }
  };
  var BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: true,
          xmlName: "Key",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: true,
          xmlName: "Id",
          type: {
            name: "String"
          }
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: {
            name: "Composite",
            className: "AccessPolicy"
          }
        }
      }
    }
  };
  var AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobFlatListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  var BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        },
        deleted: {
          serializedName: "Deleted",
          required: true,
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        snapshot: {
          serializedName: "Snapshot",
          required: true,
          xmlName: "Snapshot",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: {
            name: "Boolean"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "BlobPropertiesInternal"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: true,
          type: {
            name: "Boolean"
          }
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: true,
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: {
            name: "String"
          }
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: {
            name: "ByteArray"
          }
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: {
            name: "String"
          }
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: {
            name: "String"
          }
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: {
            name: "Boolean"
          }
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: {
            name: "String"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold"
            ]
          }
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold"
            ]
          }
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: {
            name: "String"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobHierarchyListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobPrefix"
              }
            }
          }
        },
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  var BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        }
      }
    }
  };
  var BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        }
      }
    }
  };
  var BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        }
      }
    }
  };
  var Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        size: {
          serializedName: "Size",
          required: true,
          xmlName: "Size",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "PageRange"
              }
            }
          }
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ClearRange"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: true,
          xmlName: "QueryType",
          type: {
            name: "String"
          }
        },
        expression: {
          serializedName: "Expression",
          required: true,
          xmlName: "Expression",
          type: {
            name: "String"
          }
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        }
      }
    }
  };
  var QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: {
            name: "Composite",
            className: "QueryFormat"
          }
        }
      }
    }
  };
  var QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"]
          }
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: {
            name: "Composite",
            className: "DelimitedTextConfiguration"
          }
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: {
            name: "Composite",
            className: "JsonTextConfiguration"
          }
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: {
            name: "Composite",
            className: "ArrowConfiguration"
          }
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
          }
        }
      }
    }
  };
  var DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: {
            name: "String"
          }
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: {
            name: "String"
          }
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: {
            name: "String"
          }
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: true,
          xmlName: "Schema",
          xmlIsWrapped: true,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ArrowField"
              }
            }
          }
        }
      }
    }
  };
  var ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "String"
          }
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: {
            name: "Number"
          }
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: {
            name: "String"
          }
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: {
            name: "Boolean"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  var BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: {
            name: "String"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: {
            name: "String"
          }
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        }
      }
    }
  };
  var BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: true,
          serializedName: "x-ms-copy-status",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  var BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var Mappers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AccessPolicy,
    AppendBlobAppendBlockExceptionHeaders,
    AppendBlobAppendBlockFromUrlExceptionHeaders,
    AppendBlobAppendBlockFromUrlHeaders,
    AppendBlobAppendBlockHeaders,
    AppendBlobCreateExceptionHeaders,
    AppendBlobCreateHeaders,
    AppendBlobSealExceptionHeaders,
    AppendBlobSealHeaders,
    ArrowConfiguration,
    ArrowField,
    BlobAbortCopyFromURLExceptionHeaders,
    BlobAbortCopyFromURLHeaders,
    BlobAcquireLeaseExceptionHeaders,
    BlobAcquireLeaseHeaders,
    BlobBreakLeaseExceptionHeaders,
    BlobBreakLeaseHeaders,
    BlobChangeLeaseExceptionHeaders,
    BlobChangeLeaseHeaders,
    BlobCopyFromURLExceptionHeaders,
    BlobCopyFromURLHeaders,
    BlobCreateSnapshotExceptionHeaders,
    BlobCreateSnapshotHeaders,
    BlobDeleteExceptionHeaders,
    BlobDeleteHeaders,
    BlobDeleteImmutabilityPolicyExceptionHeaders,
    BlobDeleteImmutabilityPolicyHeaders,
    BlobDownloadExceptionHeaders,
    BlobDownloadHeaders,
    BlobFlatListSegment,
    BlobGetAccountInfoExceptionHeaders,
    BlobGetAccountInfoHeaders,
    BlobGetPropertiesExceptionHeaders,
    BlobGetPropertiesHeaders,
    BlobGetTagsExceptionHeaders,
    BlobGetTagsHeaders,
    BlobHierarchyListSegment,
    BlobItemInternal,
    BlobName,
    BlobPrefix,
    BlobPropertiesInternal,
    BlobQueryExceptionHeaders,
    BlobQueryHeaders,
    BlobReleaseLeaseExceptionHeaders,
    BlobReleaseLeaseHeaders,
    BlobRenewLeaseExceptionHeaders,
    BlobRenewLeaseHeaders,
    BlobServiceProperties,
    BlobServiceStatistics,
    BlobSetExpiryExceptionHeaders,
    BlobSetExpiryHeaders,
    BlobSetHttpHeadersExceptionHeaders,
    BlobSetHttpHeadersHeaders,
    BlobSetImmutabilityPolicyExceptionHeaders,
    BlobSetImmutabilityPolicyHeaders,
    BlobSetLegalHoldExceptionHeaders,
    BlobSetLegalHoldHeaders,
    BlobSetMetadataExceptionHeaders,
    BlobSetMetadataHeaders,
    BlobSetTagsExceptionHeaders,
    BlobSetTagsHeaders,
    BlobSetTierExceptionHeaders,
    BlobSetTierHeaders,
    BlobStartCopyFromURLExceptionHeaders,
    BlobStartCopyFromURLHeaders,
    BlobTag,
    BlobTags,
    BlobUndeleteExceptionHeaders,
    BlobUndeleteHeaders,
    Block,
    BlockBlobCommitBlockListExceptionHeaders,
    BlockBlobCommitBlockListHeaders,
    BlockBlobGetBlockListExceptionHeaders,
    BlockBlobGetBlockListHeaders,
    BlockBlobPutBlobFromUrlExceptionHeaders,
    BlockBlobPutBlobFromUrlHeaders,
    BlockBlobStageBlockExceptionHeaders,
    BlockBlobStageBlockFromURLExceptionHeaders,
    BlockBlobStageBlockFromURLHeaders,
    BlockBlobStageBlockHeaders,
    BlockBlobUploadExceptionHeaders,
    BlockBlobUploadHeaders,
    BlockList,
    BlockLookupList,
    ClearRange,
    ContainerAcquireLeaseExceptionHeaders,
    ContainerAcquireLeaseHeaders,
    ContainerBreakLeaseExceptionHeaders,
    ContainerBreakLeaseHeaders,
    ContainerChangeLeaseExceptionHeaders,
    ContainerChangeLeaseHeaders,
    ContainerCreateExceptionHeaders,
    ContainerCreateHeaders,
    ContainerDeleteExceptionHeaders,
    ContainerDeleteHeaders,
    ContainerFilterBlobsExceptionHeaders,
    ContainerFilterBlobsHeaders,
    ContainerGetAccessPolicyExceptionHeaders,
    ContainerGetAccessPolicyHeaders,
    ContainerGetAccountInfoExceptionHeaders,
    ContainerGetAccountInfoHeaders,
    ContainerGetPropertiesExceptionHeaders,
    ContainerGetPropertiesHeaders,
    ContainerItem,
    ContainerListBlobFlatSegmentExceptionHeaders,
    ContainerListBlobFlatSegmentHeaders,
    ContainerListBlobHierarchySegmentExceptionHeaders,
    ContainerListBlobHierarchySegmentHeaders,
    ContainerProperties,
    ContainerReleaseLeaseExceptionHeaders,
    ContainerReleaseLeaseHeaders,
    ContainerRenameExceptionHeaders,
    ContainerRenameHeaders,
    ContainerRenewLeaseExceptionHeaders,
    ContainerRenewLeaseHeaders,
    ContainerRestoreExceptionHeaders,
    ContainerRestoreHeaders,
    ContainerSetAccessPolicyExceptionHeaders,
    ContainerSetAccessPolicyHeaders,
    ContainerSetMetadataExceptionHeaders,
    ContainerSetMetadataHeaders,
    ContainerSubmitBatchExceptionHeaders,
    ContainerSubmitBatchHeaders,
    CorsRule,
    DelimitedTextConfiguration,
    FilterBlobItem,
    FilterBlobSegment,
    GeoReplication,
    JsonTextConfiguration,
    KeyInfo,
    ListBlobsFlatSegmentResponse,
    ListBlobsHierarchySegmentResponse,
    ListContainersSegmentResponse,
    Logging,
    Metrics,
    PageBlobClearPagesExceptionHeaders,
    PageBlobClearPagesHeaders,
    PageBlobCopyIncrementalExceptionHeaders,
    PageBlobCopyIncrementalHeaders,
    PageBlobCreateExceptionHeaders,
    PageBlobCreateHeaders,
    PageBlobGetPageRangesDiffExceptionHeaders,
    PageBlobGetPageRangesDiffHeaders,
    PageBlobGetPageRangesExceptionHeaders,
    PageBlobGetPageRangesHeaders,
    PageBlobResizeExceptionHeaders,
    PageBlobResizeHeaders,
    PageBlobUpdateSequenceNumberExceptionHeaders,
    PageBlobUpdateSequenceNumberHeaders,
    PageBlobUploadPagesExceptionHeaders,
    PageBlobUploadPagesFromURLExceptionHeaders,
    PageBlobUploadPagesFromURLHeaders,
    PageBlobUploadPagesHeaders,
    PageList,
    PageRange,
    QueryFormat,
    QueryRequest,
    QuerySerialization,
    RetentionPolicy,
    ServiceFilterBlobsExceptionHeaders,
    ServiceFilterBlobsHeaders,
    ServiceGetAccountInfoExceptionHeaders,
    ServiceGetAccountInfoHeaders,
    ServiceGetPropertiesExceptionHeaders,
    ServiceGetPropertiesHeaders,
    ServiceGetStatisticsExceptionHeaders,
    ServiceGetStatisticsHeaders,
    ServiceGetUserDelegationKeyExceptionHeaders,
    ServiceGetUserDelegationKeyHeaders,
    ServiceListContainersSegmentExceptionHeaders,
    ServiceListContainersSegmentHeaders,
    ServiceSetPropertiesExceptionHeaders,
    ServiceSetPropertiesHeaders,
    ServiceSubmitBatchExceptionHeaders,
    ServiceSubmitBatchHeaders,
    SignedIdentifier,
    StaticWebsite,
    StorageError,
    UserDelegationKey
  });
  var contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: BlobServiceProperties
  };
  var accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: true,
      xmlName: "url",
      type: {
        name: "String"
      }
    },
    skipEncoding: true
  };
  var restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: {
        InclusiveMinimum: 0
      },
      serializedName: "timeout",
      xmlName: "timeout",
      type: {
        name: "Number"
      }
    }
  };
  var version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2024-08-04",
      isConstant: true,
      serializedName: "x-ms-version",
      type: {
        name: "String"
      }
    }
  };
  var requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: {
        name: "String"
      }
    }
  };
  var accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: {
        name: "String"
      }
    }
  };
  var marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: {
        name: "String"
      }
    }
  };
  var maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: {
        InclusiveMinimum: 1
      },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: {
        name: "Number"
      }
    }
  };
  var include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  var keyInfo = {
    parameterPath: "keyInfo",
    mapper: KeyInfo
  };
  var comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  var comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: true,
      xmlName: "Content-Length",
      type: {
        name: "Number"
      }
    }
  };
  var multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: true,
      xmlName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: {
        name: "String"
      }
    }
  };
  var restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: {
        name: "Dictionary",
        value: { type: { name: "String" } }
      }
    }
  };
  var access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: {
        name: "Enum",
        allowedValues: ["container", "blob"]
      }
    }
  };
  var defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope"
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  var preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride"
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: {
        name: "Boolean"
      }
    }
  };
  var leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: true,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  };
  var comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: {
        name: "String"
      }
    }
  };
  var deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: {
        name: "String"
      }
    }
  };
  var comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: true,
      xmlName: "x-ms-source-container-name",
      type: {
        name: "String"
      }
    }
  };
  var sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var duration4 = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: {
        name: "Number"
      }
    }
  };
  var proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: true,
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: {
        name: "Number"
      }
    }
  };
  var action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: true,
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions"
            ]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  var delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: true,
      xmlName: "delimiter",
      type: {
        name: "String"
      }
    }
  };
  var snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: {
        name: "String"
      }
    }
  };
  var versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: {
        name: "String"
      }
    }
  };
  var range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  var rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: {
        name: "Boolean"
      }
    }
  };
  var rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: {
        name: "Boolean"
      }
    }
  };
  var encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: {
        name: "String"
      }
    }
  };
  var encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: {
        name: "String"
      }
    }
  };
  var encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: {
        name: "String"
      }
    }
  };
  var ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: {
        name: "String"
      }
    }
  };
  var ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: {
        name: "String"
      }
    }
  };
  var ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: {
        name: "String"
      }
    }
  };
  var deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: {
        name: "Enum",
        allowedValues: ["include", "only"]
      }
    }
  };
  var blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: {
        name: "String"
      }
    }
  };
  var comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: true,
      xmlName: "x-ms-expiry-option",
      type: {
        name: "String"
      }
    }
  };
  var expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: {
        name: "String"
      }
    }
  };
  var blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: {
        name: "String"
      }
    }
  };
  var blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: {
        name: "String"
      }
    }
  };
  var blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: {
        name: "String"
      }
    }
  };
  var blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: {
        name: "String"
      }
    }
  };
  var blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: {
        name: "String"
      }
    }
  };
  var comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: {
        name: "Enum",
        allowedValues: ["Mutable", "Unlocked", "Locked"]
      }
    }
  };
  var comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: true,
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  var encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  var comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  var rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: {
        name: "Enum",
        allowedValues: ["High", "Standard"]
      }
    }
  };
  var sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var sourceIfMatch = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: {
        name: "String"
      }
    }
  };
  var sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch"
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  var sourceIfTags = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: {
        name: "String"
      }
    }
  };
  var copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  var blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: {
        name: "String"
      }
    }
  };
  var sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: {
        name: "Boolean"
      }
    }
  };
  var legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  var xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: true,
      serializedName: "x-ms-requires-sync",
      type: {
        name: "String"
      }
    }
  };
  var sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: {
        name: "String"
      }
    }
  };
  var copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: {
        name: "Enum",
        allowedValues: ["REPLACE", "COPY"]
      }
    }
  };
  var comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: true,
      serializedName: "x-ms-copy-action",
      type: {
        name: "String"
      }
    }
  };
  var copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: true,
      xmlName: "copyid",
      type: {
        name: "String"
      }
    }
  };
  var comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: true,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  var queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: QueryRequest
  };
  var comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tags = {
    parameterPath: ["options", "tags"],
    mapper: BlobTags
  };
  var transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  var blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: true,
      xmlName: "x-ms-blob-content-length",
      type: {
        name: "Number"
      }
    }
  };
  var blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: {
        name: "Number"
      }
    }
  };
  var contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  var accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  var ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: {
        name: "Number"
      }
    }
  };
  var ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: {
        name: "Number"
      }
    }
  };
  var ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: {
        name: "Number"
      }
    }
  };
  var pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  var sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  var sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: true,
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  var sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  var range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: true,
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  var comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: {
        name: "String"
      }
    }
  };
  var prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: {
        name: "String"
      }
    }
  };
  var sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: true,
      xmlName: "x-ms-sequence-number-action",
      type: {
        name: "Enum",
        allowedValues: ["max", "update", "increment"]
      }
    }
  };
  var comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: {
        name: "Number"
      }
    }
  };
  var appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition"
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: {
        name: "Number"
      }
    }
  };
  var sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  var comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: {
        name: "Boolean"
      }
    }
  };
  var comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: true,
      xmlName: "blockid",
      type: {
        name: "String"
      }
    }
  };
  var blocks = {
    parameterPath: "blocks",
    mapper: BlockLookupList
  };
  var comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: true,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"]
      }
    }
  };

  class ServiceImpl {
    constructor(client) {
      this.client = client;
    }
    setProperties(blobServiceProperties2, options3) {
      return this.client.sendOperationRequest({ blobServiceProperties: blobServiceProperties2, options: options3 }, setPropertiesOperationSpec);
    }
    getProperties(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getPropertiesOperationSpec$2);
    }
    getStatistics(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getStatisticsOperationSpec);
    }
    listContainersSegment(options3) {
      return this.client.sendOperationRequest({ options: options3 }, listContainersSegmentOperationSpec);
    }
    getUserDelegationKey(keyInfo2, options3) {
      return this.client.sendOperationRequest({ keyInfo: keyInfo2, options: options3 }, getUserDelegationKeyOperationSpec);
    }
    getAccountInfo(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getAccountInfoOperationSpec$2);
    }
    submitBatch(contentLength2, multipartContentType2, body2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, multipartContentType: multipartContentType2, body: body2, options: options3 }, submitBatchOperationSpec$1);
    }
    filterBlobs(options3) {
      return this.client.sendOperationRequest({ options: options3 }, filterBlobsOperationSpec$1);
    }
  }
  var xmlSerializer$5 = coreClient__namespace.createSerializer(Mappers, true);
  var setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: ServiceSetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceSetPropertiesExceptionHeaders
      }
    },
    requestBody: blobServiceProperties,
    queryParameters: [
      restype,
      comp,
      timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var getPropertiesOperationSpec$2 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobServiceProperties,
        headersMapper: ServiceGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      restype,
      comp,
      timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobServiceStatistics,
        headersMapper: ServiceGetStatisticsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetStatisticsExceptionHeaders
      }
    },
    queryParameters: [
      restype,
      timeoutInSeconds,
      comp1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var listContainersSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListContainersSegmentResponse,
        headersMapper: ServiceListContainersSegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceListContainersSegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      include
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var getUserDelegationKeyOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: UserDelegationKey,
        headersMapper: ServiceGetUserDelegationKeyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetUserDelegationKeyExceptionHeaders
      }
    },
    requestBody: keyInfo,
    queryParameters: [
      restype,
      timeoutInSeconds,
      comp3
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var getAccountInfoOperationSpec$2 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ServiceGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var submitBatchOperationSpec$1 = {
    path: "/",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: ServiceSubmitBatchHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceSubmitBatchExceptionHeaders
      }
    },
    requestBody: body,
    queryParameters: [timeoutInSeconds, comp4],
    urlParameters: [url],
    headerParameters: [
      accept,
      version,
      requestId,
      contentLength,
      multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var filterBlobsOperationSpec$1 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: FilterBlobSegment,
        headersMapper: ServiceFilterBlobsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      comp5,
      where
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };

  class ContainerImpl {
    constructor(client) {
      this.client = client;
    }
    create(options3) {
      return this.client.sendOperationRequest({ options: options3 }, createOperationSpec$2);
    }
    getProperties(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getPropertiesOperationSpec$1);
    }
    delete(options3) {
      return this.client.sendOperationRequest({ options: options3 }, deleteOperationSpec$1);
    }
    setMetadata(options3) {
      return this.client.sendOperationRequest({ options: options3 }, setMetadataOperationSpec$1);
    }
    getAccessPolicy(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getAccessPolicyOperationSpec);
    }
    setAccessPolicy(options3) {
      return this.client.sendOperationRequest({ options: options3 }, setAccessPolicyOperationSpec);
    }
    restore(options3) {
      return this.client.sendOperationRequest({ options: options3 }, restoreOperationSpec);
    }
    rename(sourceContainerName2, options3) {
      return this.client.sendOperationRequest({ sourceContainerName: sourceContainerName2, options: options3 }, renameOperationSpec);
    }
    submitBatch(contentLength2, multipartContentType2, body2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, multipartContentType: multipartContentType2, body: body2, options: options3 }, submitBatchOperationSpec);
    }
    filterBlobs(options3) {
      return this.client.sendOperationRequest({ options: options3 }, filterBlobsOperationSpec);
    }
    acquireLease(options3) {
      return this.client.sendOperationRequest({ options: options3 }, acquireLeaseOperationSpec$1);
    }
    releaseLease(leaseId2, options3) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options: options3 }, releaseLeaseOperationSpec$1);
    }
    renewLease(leaseId2, options3) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options: options3 }, renewLeaseOperationSpec$1);
    }
    breakLease(options3) {
      return this.client.sendOperationRequest({ options: options3 }, breakLeaseOperationSpec$1);
    }
    changeLease(leaseId2, proposedLeaseId2, options3) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, proposedLeaseId: proposedLeaseId2, options: options3 }, changeLeaseOperationSpec$1);
    }
    listBlobFlatSegment(options3) {
      return this.client.sendOperationRequest({ options: options3 }, listBlobFlatSegmentOperationSpec);
    }
    listBlobHierarchySegment(delimiter2, options3) {
      return this.client.sendOperationRequest({ delimiter: delimiter2, options: options3 }, listBlobHierarchySegmentOperationSpec);
    }
    getAccountInfo(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getAccountInfoOperationSpec$1);
    }
  }
  var xmlSerializer$4 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec$2 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      access,
      defaultEncryptionScope,
      preventEncryptionScopeOverride
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getPropertiesOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ContainerGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var deleteOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: ContainerDeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerDeleteExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var setMetadataOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerSetMetadataHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSetMetadataExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp6
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "SignedIdentifier" }
            }
          },
          serializedName: "SignedIdentifiers",
          xmlName: "SignedIdentifiers",
          xmlIsWrapped: true,
          xmlElementName: "SignedIdentifier"
        },
        headersMapper: ContainerGetAccessPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetAccessPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp7
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var setAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerSetAccessPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSetAccessPolicyExceptionHeaders
      }
    },
    requestBody: containerAcl,
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp7
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      access,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$4
  };
  var restoreOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerRestoreHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRestoreExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp8
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      deletedContainerName,
      deletedContainerVersion
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var renameOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerRenameHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRenameExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp9
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      sourceContainerName,
      sourceLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var submitBatchOperationSpec = {
    path: "/{containerName}",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: ContainerSubmitBatchHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSubmitBatchExceptionHeaders
      }
    },
    requestBody: body,
    queryParameters: [
      timeoutInSeconds,
      comp4,
      restype2
    ],
    urlParameters: [url],
    headerParameters: [
      accept,
      version,
      requestId,
      contentLength,
      multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$4
  };
  var filterBlobsOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: FilterBlobSegment,
        headersMapper: ContainerFilterBlobsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      comp5,
      where,
      restype2
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var acquireLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerAcquireLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action,
      duration4,
      proposedLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var releaseLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerReleaseLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action1,
      leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var renewLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerRenewLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action2
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var breakLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: ContainerBreakLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action3,
      breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var changeLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerChangeLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action4,
      proposedLeaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var listBlobFlatSegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListBlobsFlatSegmentResponse,
        headersMapper: ContainerListBlobFlatSegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerListBlobFlatSegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      restype2,
      include1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var listBlobHierarchySegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListBlobsHierarchySegmentResponse,
        headersMapper: ContainerListBlobHierarchySegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerListBlobHierarchySegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      restype2,
      include1,
      delimiter
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getAccountInfoOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ContainerGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };

  class BlobImpl {
    constructor(client) {
      this.client = client;
    }
    download(options3) {
      return this.client.sendOperationRequest({ options: options3 }, downloadOperationSpec);
    }
    getProperties(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getPropertiesOperationSpec);
    }
    delete(options3) {
      return this.client.sendOperationRequest({ options: options3 }, deleteOperationSpec);
    }
    undelete(options3) {
      return this.client.sendOperationRequest({ options: options3 }, undeleteOperationSpec);
    }
    setExpiry(expiryOptions2, options3) {
      return this.client.sendOperationRequest({ expiryOptions: expiryOptions2, options: options3 }, setExpiryOperationSpec);
    }
    setHttpHeaders(options3) {
      return this.client.sendOperationRequest({ options: options3 }, setHttpHeadersOperationSpec);
    }
    setImmutabilityPolicy(options3) {
      return this.client.sendOperationRequest({ options: options3 }, setImmutabilityPolicyOperationSpec);
    }
    deleteImmutabilityPolicy(options3) {
      return this.client.sendOperationRequest({ options: options3 }, deleteImmutabilityPolicyOperationSpec);
    }
    setLegalHold(legalHold2, options3) {
      return this.client.sendOperationRequest({ legalHold: legalHold2, options: options3 }, setLegalHoldOperationSpec);
    }
    setMetadata(options3) {
      return this.client.sendOperationRequest({ options: options3 }, setMetadataOperationSpec);
    }
    acquireLease(options3) {
      return this.client.sendOperationRequest({ options: options3 }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId2, options3) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options: options3 }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId2, options3) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options: options3 }, renewLeaseOperationSpec);
    }
    changeLease(leaseId2, proposedLeaseId2, options3) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, proposedLeaseId: proposedLeaseId2, options: options3 }, changeLeaseOperationSpec);
    }
    breakLease(options3) {
      return this.client.sendOperationRequest({ options: options3 }, breakLeaseOperationSpec);
    }
    createSnapshot(options3) {
      return this.client.sendOperationRequest({ options: options3 }, createSnapshotOperationSpec);
    }
    startCopyFromURL(copySource2, options3) {
      return this.client.sendOperationRequest({ copySource: copySource2, options: options3 }, startCopyFromURLOperationSpec);
    }
    copyFromURL(copySource2, options3) {
      return this.client.sendOperationRequest({ copySource: copySource2, options: options3 }, copyFromURLOperationSpec);
    }
    abortCopyFromURL(copyId2, options3) {
      return this.client.sendOperationRequest({ copyId: copyId2, options: options3 }, abortCopyFromURLOperationSpec);
    }
    setTier(tier2, options3) {
      return this.client.sendOperationRequest({ tier: tier2, options: options3 }, setTierOperationSpec);
    }
    getAccountInfo(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getAccountInfoOperationSpec);
    }
    query(options3) {
      return this.client.sendOperationRequest({ options: options3 }, queryOperationSpec);
    }
    getTags(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getTagsOperationSpec);
    }
    setTags(options3) {
      return this.client.sendOperationRequest({ options: options3 }, setTagsOperationSpec);
    }
  }
  var xmlSerializer$3 = coreClient__namespace.createSerializer(Mappers, true);
  var downloadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobDownloadHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobDownloadHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDownloadExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      rangeGetContentMD5,
      rangeGetContentCRC64,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var getPropertiesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "HEAD",
    responses: {
      200: {
        headersMapper: BlobGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var deleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: BlobDeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDeleteExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      blobDeleteType
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var undeleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobUndeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobUndeleteExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp8],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setExpiryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetExpiryHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetExpiryExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      expiryOptions,
      expiresOn
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setHttpHeadersOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetHttpHeadersHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetHttpHeadersExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp12],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifUnmodifiedSince,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var deleteImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      200: {
        headersMapper: BlobDeleteImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDeleteImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp12],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setLegalHoldOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetLegalHoldHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetLegalHoldExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp13],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      legalHold
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setMetadataOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetMetadataHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetMetadataExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp6],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var acquireLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlobAcquireLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action,
      duration4,
      proposedLeaseId,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var releaseLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobReleaseLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action1,
      leaseId1,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var renewLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobRenewLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action2,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var changeLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobChangeLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action4,
      proposedLeaseId1,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var breakLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobBreakLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action3,
      breakPeriod,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var createSnapshotOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlobCreateSnapshotHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobCreateSnapshotExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp14],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var startCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobStartCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobStartCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      tier,
      rehydratePriority,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceIfTags,
      copySource,
      blobTagsString,
      sealBlob,
      legalHold1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var copyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      copySource,
      blobTagsString,
      legalHold1,
      xMsRequiresSync,
      sourceContentMD5,
      copySourceAuthorization,
      copySourceTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var abortCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: BlobAbortCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobAbortCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp15,
      copyId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setTierOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetTierHeaders
      },
      202: {
        headersMapper: BlobSetTierHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetTierExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp16
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags,
      rehydratePriority,
      tier1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var getAccountInfoOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: BlobGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var queryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobQueryHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobQueryHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobQueryExceptionHeaders
      }
    },
    requestBody: queryRequest,
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      comp17
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$3
  };
  var getTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobTags,
        headersMapper: BlobGetTagsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetTagsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp18
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: BlobSetTagsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetTagsExceptionHeaders
      }
    },
    requestBody: tags,
    queryParameters: [
      timeoutInSeconds,
      versionId,
      comp18
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      leaseId,
      ifTags,
      transactionalContentMD5,
      transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$3
  };

  class PageBlobImpl {
    constructor(client) {
      this.client = client;
    }
    create(contentLength2, blobContentLength2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, blobContentLength: blobContentLength2, options: options3 }, createOperationSpec$1);
    }
    uploadPages(contentLength2, body2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options: options3 }, uploadPagesOperationSpec);
    }
    clearPages(contentLength2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, options: options3 }, clearPagesOperationSpec);
    }
    uploadPagesFromURL(sourceUrl2, sourceRange2, contentLength2, range2, options3) {
      return this.client.sendOperationRequest({ sourceUrl: sourceUrl2, sourceRange: sourceRange2, contentLength: contentLength2, range: range2, options: options3 }, uploadPagesFromURLOperationSpec);
    }
    getPageRanges(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getPageRangesOperationSpec);
    }
    getPageRangesDiff(options3) {
      return this.client.sendOperationRequest({ options: options3 }, getPageRangesDiffOperationSpec);
    }
    resize(blobContentLength2, options3) {
      return this.client.sendOperationRequest({ blobContentLength: blobContentLength2, options: options3 }, resizeOperationSpec);
    }
    updateSequenceNumber(sequenceNumberAction2, options3) {
      return this.client.sendOperationRequest({ sequenceNumberAction: sequenceNumberAction2, options: options3 }, updateSequenceNumberOperationSpec);
    }
    copyIncremental(copySource2, options3) {
      return this.client.sendOperationRequest({ copySource: copySource2, options: options3 }, copyIncrementalOperationSpec);
    }
  }
  var xmlSerializer$2 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec$1 = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      blobType,
      blobContentLength,
      blobSequenceNumber
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var uploadPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobUploadPagesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUploadPagesExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      pageWrite,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer$2
  };
  var clearPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobClearPagesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobClearPagesExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo,
      pageWrite1
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var uploadPagesFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobUploadPagesFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUploadPagesFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      pageWrite,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo,
      sourceUrl,
      sourceRange,
      sourceContentCrc64,
      range1
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var getPageRangesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: PageList,
        headersMapper: PageBlobGetPageRangesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobGetPageRangesExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      snapshot,
      comp20
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var getPageRangesDiffOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: PageList,
        headersMapper: PageBlobGetPageRangesDiffHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobGetPageRangesDiffExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      snapshot,
      comp20,
      prevsnapshot
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      ifMatch,
      ifNoneMatch,
      ifTags,
      prevSnapshotUrl
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var resizeOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: PageBlobResizeHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobResizeExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      blobContentLength
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var updateSequenceNumberOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: PageBlobUpdateSequenceNumberHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUpdateSequenceNumberExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobSequenceNumber,
      sequenceNumberAction
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var copyIncrementalOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: PageBlobCopyIncrementalHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobCopyIncrementalExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp21],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      copySource
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };

  class AppendBlobImpl {
    constructor(client) {
      this.client = client;
    }
    create(contentLength2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, options: options3 }, createOperationSpec);
    }
    appendBlock(contentLength2, body2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options: options3 }, appendBlockOperationSpec);
    }
    appendBlockFromUrl(sourceUrl2, contentLength2, options3) {
      return this.client.sendOperationRequest({ sourceUrl: sourceUrl2, contentLength: contentLength2, options: options3 }, appendBlockFromUrlOperationSpec);
    }
    seal(options3) {
      return this.client.sendOperationRequest({ options: options3 }, sealOperationSpec);
    }
  }
  var xmlSerializer$1 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      blobTagsString,
      legalHold1,
      blobType1
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };
  var appendBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobAppendBlockHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobAppendBlockExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds, comp22],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      maxSize,
      appendPosition
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer$1
  };
  var appendBlockFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobAppendBlockFromUrlHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobAppendBlockFromUrlExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp22],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      transactionalContentMD5,
      sourceUrl,
      sourceContentCrc64,
      maxSize,
      appendPosition,
      sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };
  var sealOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: AppendBlobSealHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobSealExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp23],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      appendPosition
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };

  class BlockBlobImpl {
    constructor(client) {
      this.client = client;
    }
    upload(contentLength2, body2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options: options3 }, uploadOperationSpec);
    }
    putBlobFromUrl(contentLength2, copySource2, options3) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, copySource: copySource2, options: options3 }, putBlobFromUrlOperationSpec);
    }
    stageBlock(blockId2, contentLength2, body2, options3) {
      return this.client.sendOperationRequest({ blockId: blockId2, contentLength: contentLength2, body: body2, options: options3 }, stageBlockOperationSpec);
    }
    stageBlockFromURL(blockId2, contentLength2, sourceUrl2, options3) {
      return this.client.sendOperationRequest({ blockId: blockId2, contentLength: contentLength2, sourceUrl: sourceUrl2, options: options3 }, stageBlockFromURLOperationSpec);
    }
    commitBlockList(blocks2, options3) {
      return this.client.sendOperationRequest({ blocks: blocks2, options: options3 }, commitBlockListOperationSpec);
    }
    getBlockList(listType2, options3) {
      return this.client.sendOperationRequest({ listType: listType2, options: options3 }, getBlockListOperationSpec);
    }
  }
  var xmlSerializer = coreClient__namespace.createSerializer(Mappers, true);
  var uploadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobUploadHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobUploadExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      blobType2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var putBlobFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobPutBlobFromUrlHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobPutBlobFromUrlExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      encryptionScope,
      tier,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceIfTags,
      copySource,
      blobTagsString,
      sourceContentMD5,
      copySourceAuthorization,
      copySourceTags,
      transactionalContentMD5,
      blobType2,
      copySourceBlobProperties
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var stageBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobStageBlockHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobStageBlockExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [
      timeoutInSeconds,
      comp24,
      blockId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var stageBlockFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobStageBlockFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobStageBlockFromURLExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp24,
      blockId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      sourceUrl,
      sourceContentCrc64,
      sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var commitBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobCommitBlockListHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobCommitBlockListExceptionHeaders
      }
    },
    requestBody: blocks,
    queryParameters: [timeoutInSeconds, comp25],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      transactionalContentMD5,
      transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlockList,
        headersMapper: BlockBlobGetBlockListHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobGetBlockListExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      comp25,
      listType
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var StorageClient$1 = class StorageClient2 extends coreHttpCompat__namespace.ExtendedServiceClient {
    constructor(url2, options3) {
      var _a, _b;
      if (url2 === undefined) {
        throw new Error("'url' cannot be null");
      }
      if (!options3) {
        options3 = {};
      }
      const defaults = {
        requestContentType: "application/json; charset=utf-8"
      };
      const packageDetails = `azsdk-js-azure-storage-blob/12.24.0`;
      const userAgentPrefix = options3.userAgentOptions && options3.userAgentOptions.userAgentPrefix ? `${options3.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options3), { userAgentOptions: {
        userAgentPrefix
      }, endpoint: (_b = (_a = options3.endpoint) !== null && _a !== undefined ? _a : options3.baseUri) !== null && _b !== undefined ? _b : "{url}" });
      super(optionsWithDefaults);
      this.url = url2;
      this.version = options3.version || "2024-08-04";
      this.service = new ServiceImpl(this);
      this.container = new ContainerImpl(this);
      this.blob = new BlobImpl(this);
      this.pageBlob = new PageBlobImpl(this);
      this.appendBlob = new AppendBlobImpl(this);
      this.blockBlob = new BlockBlobImpl(this);
    }
  };

  class StorageContextClient extends StorageClient$1 {
    async sendOperationRequest(operationArguments, operationSpec) {
      const operationSpecToSend = Object.assign({}, operationSpec);
      if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
        operationSpecToSend.path = "";
      }
      return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
  }

  class StorageClient {
    constructor(url2, pipeline4) {
      this.url = escapeURLPath(url2);
      this.accountName = getAccountNameFromUrl(url2);
      this.pipeline = pipeline4;
      this.storageClientContext = new StorageContextClient(this.url, getCoreClientOptions(pipeline4));
      this.isHttps = iEqual(getURLScheme(this.url) || "", "https");
      this.credential = getCredentialFromPipeline(pipeline4);
      const storageClientContext = this.storageClientContext;
      storageClientContext.requestContentType = undefined;
    }
  }
  var tracingClient = coreTracing.createTracingClient({
    packageName: "@azure/storage-blob",
    packageVersion: SDK_VERSION,
    namespace: "Microsoft.Storage"
  });

  class BlobSASPermissions {
    constructor() {
      this.read = false;
      this.add = false;
      this.create = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.tag = false;
      this.move = false;
      this.execute = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
    }
    static parse(permissions) {
      const blobSASPermissions = new BlobSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            blobSASPermissions.read = true;
            break;
          case "a":
            blobSASPermissions.add = true;
            break;
          case "c":
            blobSASPermissions.create = true;
            break;
          case "w":
            blobSASPermissions.write = true;
            break;
          case "d":
            blobSASPermissions.delete = true;
            break;
          case "x":
            blobSASPermissions.deleteVersion = true;
            break;
          case "t":
            blobSASPermissions.tag = true;
            break;
          case "m":
            blobSASPermissions.move = true;
            break;
          case "e":
            blobSASPermissions.execute = true;
            break;
          case "i":
            blobSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            blobSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission: ${char}`);
        }
      }
      return blobSASPermissions;
    }
    static from(permissionLike) {
      const blobSASPermissions = new BlobSASPermissions;
      if (permissionLike.read) {
        blobSASPermissions.read = true;
      }
      if (permissionLike.add) {
        blobSASPermissions.add = true;
      }
      if (permissionLike.create) {
        blobSASPermissions.create = true;
      }
      if (permissionLike.write) {
        blobSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        blobSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        blobSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        blobSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        blobSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        blobSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        blobSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        blobSASPermissions.permanentDelete = true;
      }
      return blobSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }

  class ContainerSASPermissions {
    constructor() {
      this.read = false;
      this.add = false;
      this.create = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.list = false;
      this.tag = false;
      this.move = false;
      this.execute = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
      this.filterByTags = false;
    }
    static parse(permissions) {
      const containerSASPermissions = new ContainerSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            containerSASPermissions.read = true;
            break;
          case "a":
            containerSASPermissions.add = true;
            break;
          case "c":
            containerSASPermissions.create = true;
            break;
          case "w":
            containerSASPermissions.write = true;
            break;
          case "d":
            containerSASPermissions.delete = true;
            break;
          case "l":
            containerSASPermissions.list = true;
            break;
          case "t":
            containerSASPermissions.tag = true;
            break;
          case "x":
            containerSASPermissions.deleteVersion = true;
            break;
          case "m":
            containerSASPermissions.move = true;
            break;
          case "e":
            containerSASPermissions.execute = true;
            break;
          case "i":
            containerSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            containerSASPermissions.permanentDelete = true;
            break;
          case "f":
            containerSASPermissions.filterByTags = true;
            break;
          default:
            throw new RangeError(`Invalid permission ${char}`);
        }
      }
      return containerSASPermissions;
    }
    static from(permissionLike) {
      const containerSASPermissions = new ContainerSASPermissions;
      if (permissionLike.read) {
        containerSASPermissions.read = true;
      }
      if (permissionLike.add) {
        containerSASPermissions.add = true;
      }
      if (permissionLike.create) {
        containerSASPermissions.create = true;
      }
      if (permissionLike.write) {
        containerSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        containerSASPermissions.delete = true;
      }
      if (permissionLike.list) {
        containerSASPermissions.list = true;
      }
      if (permissionLike.deleteVersion) {
        containerSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        containerSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        containerSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        containerSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        containerSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        containerSASPermissions.permanentDelete = true;
      }
      if (permissionLike.filterByTags) {
        containerSASPermissions.filterByTags = true;
      }
      return containerSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      if (this.filterByTags) {
        permissions.push("f");
      }
      return permissions.join("");
    }
  }

  class UserDelegationKeyCredential {
    constructor(accountName, userDelegationKey) {
      this.accountName = accountName;
      this.userDelegationKey = userDelegationKey;
      this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    computeHMACSHA256(stringToSign) {
      return crypto.createHmac("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
  }
  exports.SASProtocol = undefined;
  (function(SASProtocol) {
    SASProtocol["Https"] = "https";
    SASProtocol["HttpsAndHttp"] = "https,http";
  })(exports.SASProtocol || (exports.SASProtocol = {}));

  class SASQueryParameters {
    get ipRange() {
      if (this.ipRangeInner) {
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
      }
      return;
    }
    constructor(version2, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn2, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType2, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope2) {
      this.version = version2;
      this.signature = signature;
      if (permissionsOrOptions !== undefined && typeof permissionsOrOptions !== "string") {
        this.permissions = permissionsOrOptions.permissions;
        this.services = permissionsOrOptions.services;
        this.resourceTypes = permissionsOrOptions.resourceTypes;
        this.protocol = permissionsOrOptions.protocol;
        this.startsOn = permissionsOrOptions.startsOn;
        this.expiresOn = permissionsOrOptions.expiresOn;
        this.ipRangeInner = permissionsOrOptions.ipRange;
        this.identifier = permissionsOrOptions.identifier;
        this.encryptionScope = permissionsOrOptions.encryptionScope;
        this.resource = permissionsOrOptions.resource;
        this.cacheControl = permissionsOrOptions.cacheControl;
        this.contentDisposition = permissionsOrOptions.contentDisposition;
        this.contentEncoding = permissionsOrOptions.contentEncoding;
        this.contentLanguage = permissionsOrOptions.contentLanguage;
        this.contentType = permissionsOrOptions.contentType;
        if (permissionsOrOptions.userDelegationKey) {
          this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
          this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
          this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
          this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
          this.signedService = permissionsOrOptions.userDelegationKey.signedService;
          this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
          this.correlationId = permissionsOrOptions.correlationId;
        }
      } else {
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn2;
        this.permissions = permissionsOrOptions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.encryptionScope = encryptionScope2;
        this.identifier = identifier;
        this.resource = resource;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType2;
        if (userDelegationKey) {
          this.signedOid = userDelegationKey.signedObjectId;
          this.signedTenantId = userDelegationKey.signedTenantId;
          this.signedStartsOn = userDelegationKey.signedStartsOn;
          this.signedExpiresOn = userDelegationKey.signedExpiresOn;
          this.signedService = userDelegationKey.signedService;
          this.signedVersion = userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
          this.correlationId = correlationId;
        }
      }
    }
    toString() {
      const params = [
        "sv",
        "ss",
        "srt",
        "spr",
        "st",
        "se",
        "sip",
        "si",
        "ses",
        "skoid",
        "sktid",
        "skt",
        "ske",
        "sks",
        "skv",
        "sr",
        "sp",
        "sig",
        "rscc",
        "rscd",
        "rsce",
        "rscl",
        "rsct",
        "saoid",
        "scid"
      ];
      const queries = [];
      for (const param of params) {
        switch (param) {
          case "sv":
            this.tryAppendQueryParameter(queries, param, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(queries, param, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(queries, param, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(queries, param, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : undefined);
            break;
          case "se":
            this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : undefined);
            break;
          case "sip":
            this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
            break;
          case "si":
            this.tryAppendQueryParameter(queries, param, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(queries, param, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(queries, param, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(queries, param, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, false) : undefined);
            break;
          case "ske":
            this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, false) : undefined);
            break;
          case "sks":
            this.tryAppendQueryParameter(queries, param, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(queries, param, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(queries, param, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(queries, param, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(queries, param, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(queries, param, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(queries, param, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(queries, param, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(queries, param, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(queries, param, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(queries, param, this.correlationId);
            break;
        }
      }
      return queries.join("&");
    }
    tryAppendQueryParameter(queries, key, value) {
      if (!value) {
        return;
      }
      key = encodeURIComponent(key);
      value = encodeURIComponent(value);
      if (key.length > 0 && value.length > 0) {
        queries.push(`${key}=${value}`);
      }
    }
  }

  class BlobLeaseClient {
    get leaseId() {
      return this._leaseId;
    }
    get url() {
      return this._url;
    }
    constructor(client, leaseId2) {
      const clientContext = client.storageClientContext;
      this._url = client.url;
      if (client.name === undefined) {
        this._isContainer = true;
        this._containerOrBlobOperation = clientContext.container;
      } else {
        this._isContainer = false;
        this._containerOrBlobOperation = clientContext.blob;
      }
      if (!leaseId2) {
        leaseId2 = coreUtil.randomUUID();
      }
      this._leaseId = leaseId2;
    }
    async acquireLease(duration5, options3 = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options3.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options3.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options3.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options3.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options3.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-acquireLease", options3, async (updatedOptions) => {
        var _a2;
        return assertResponse(await this._containerOrBlobOperation.acquireLease({
          abortSignal: options3.abortSignal,
          duration: duration5,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a2 = options3.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          proposedLeaseId: this._leaseId,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async changeLease(proposedLeaseId2, options3 = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options3.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options3.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options3.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options3.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options3.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-changeLease", options3, async (updatedOptions) => {
        var _a2;
        const response = assertResponse(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId2, {
          abortSignal: options3.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a2 = options3.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        this._leaseId = proposedLeaseId2;
        return response;
      });
    }
    async releaseLease(options3 = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options3.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options3.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options3.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options3.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options3.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-releaseLease", options3, async (updatedOptions) => {
        var _a2;
        return assertResponse(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
          abortSignal: options3.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a2 = options3.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async renewLease(options3 = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options3.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options3.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options3.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options3.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options3.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-renewLease", options3, async (updatedOptions) => {
        var _a2;
        return this._containerOrBlobOperation.renewLease(this._leaseId, {
          abortSignal: options3.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a2 = options3.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async breakLease(breakPeriod2, options3 = {}) {
      var _a, _b, _c, _d, _e;
      if (this._isContainer && (((_a = options3.conditions) === null || _a === undefined ? undefined : _a.ifMatch) && ((_b = options3.conditions) === null || _b === undefined ? undefined : _b.ifMatch) !== ETagNone || ((_c = options3.conditions) === null || _c === undefined ? undefined : _c.ifNoneMatch) && ((_d = options3.conditions) === null || _d === undefined ? undefined : _d.ifNoneMatch) !== ETagNone || ((_e = options3.conditions) === null || _e === undefined ? undefined : _e.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-breakLease", options3, async (updatedOptions) => {
        var _a2;
        const operationOptions = {
          abortSignal: options3.abortSignal,
          breakPeriod: breakPeriod2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a2 = options3.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        };
        return assertResponse(await this._containerOrBlobOperation.breakLease(operationOptions));
      });
    }
  }

  class RetriableReadableStream extends stream3.Readable {
    constructor(source, getter, offset, count2, options3 = {}) {
      super({ highWaterMark: options3.highWaterMark });
      this.retries = 0;
      this.sourceDataHandler = (data) => {
        if (this.options.doInjectErrorOnce) {
          this.options.doInjectErrorOnce = undefined;
          this.source.pause();
          this.sourceErrorOrEndHandler();
          this.source.destroy();
          return;
        }
        this.offset += data.length;
        if (this.onProgress) {
          this.onProgress({ loadedBytes: this.offset - this.start });
        }
        if (!this.push(data)) {
          this.source.pause();
        }
      };
      this.sourceAbortedHandler = () => {
        const abortError = new abortController.AbortError("The operation was aborted.");
        this.destroy(abortError);
      };
      this.sourceErrorOrEndHandler = (err) => {
        if (err && err.name === "AbortError") {
          this.destroy(err);
          return;
        }
        this.removeSourceEventHandlers();
        if (this.offset - 1 === this.end) {
          this.push(null);
        } else if (this.offset <= this.end) {
          if (this.retries < this.maxRetryRequests) {
            this.retries += 1;
            this.getter(this.offset).then((newSource) => {
              this.source = newSource;
              this.setSourceEventHandlers();
              return;
            }).catch((error2) => {
              this.destroy(error2);
            });
          } else {
            this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
          }
        } else {
          this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
        }
      };
      this.getter = getter;
      this.source = source;
      this.start = offset;
      this.offset = offset;
      this.end = offset + count2 - 1;
      this.maxRetryRequests = options3.maxRetryRequests && options3.maxRetryRequests >= 0 ? options3.maxRetryRequests : 0;
      this.onProgress = options3.onProgress;
      this.options = options3;
      this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler);
      this.source.on("end", this.sourceErrorOrEndHandler);
      this.source.on("error", this.sourceErrorOrEndHandler);
      this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler);
      this.source.removeListener("end", this.sourceErrorOrEndHandler);
      this.source.removeListener("error", this.sourceErrorOrEndHandler);
      this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    _destroy(error2, callback) {
      this.removeSourceEventHandlers();
      this.source.destroy();
      callback(error2 === null ? undefined : error2);
    }
  }

  class BlobDownloadResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get versionId() {
      return this.originalResponse.versionId;
    }
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    get readableStreamBody() {
      return coreUtil.isNode ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    constructor(originalResponse, getter, offset, count2, options3 = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count2, options3);
    }
  }
  var AVRO_SYNC_MARKER_SIZE = 16;
  var AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  var AVRO_CODEC_KEY = "avro.codec";
  var AVRO_SCHEMA_KEY = "avro.schema";

  class AvroParser {
    static async readFixedBytes(stream4, length, options3 = {}) {
      const bytes = await stream4.read(length, { abortSignal: options3.abortSignal });
      if (bytes.length !== length) {
        throw new Error("Hit stream end.");
      }
      return bytes;
    }
    static async readByte(stream4, options3 = {}) {
      const buf = await AvroParser.readFixedBytes(stream4, 1, options3);
      return buf[0];
    }
    static async readZigZagLong(stream4, options3 = {}) {
      let zigZagEncoded = 0;
      let significanceInBit = 0;
      let byte, haveMoreByte, significanceInFloat;
      do {
        byte = await AvroParser.readByte(stream4, options3);
        haveMoreByte = byte & 128;
        zigZagEncoded |= (byte & 127) << significanceInBit;
        significanceInBit += 7;
      } while (haveMoreByte && significanceInBit < 28);
      if (haveMoreByte) {
        zigZagEncoded = zigZagEncoded;
        significanceInFloat = 268435456;
        do {
          byte = await AvroParser.readByte(stream4, options3);
          zigZagEncoded += (byte & 127) * significanceInFloat;
          significanceInFloat *= 128;
        } while (byte & 128);
        const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
        if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
          throw new Error("Integer overflow.");
        }
        return res;
      }
      return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream4, options3 = {}) {
      return AvroParser.readZigZagLong(stream4, options3);
    }
    static async readInt(stream4, options3 = {}) {
      return AvroParser.readZigZagLong(stream4, options3);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(stream4, options3 = {}) {
      const b = await AvroParser.readByte(stream4, options3);
      if (b === 1) {
        return true;
      } else if (b === 0) {
        return false;
      } else {
        throw new Error("Byte was not a boolean.");
      }
    }
    static async readFloat(stream4, options3 = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream4, 4, options3);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat32(0, true);
    }
    static async readDouble(stream4, options3 = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream4, 8, options3);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat64(0, true);
    }
    static async readBytes(stream4, options3 = {}) {
      const size = await AvroParser.readLong(stream4, options3);
      if (size < 0) {
        throw new Error("Bytes size was negative.");
      }
      return stream4.read(size, { abortSignal: options3.abortSignal });
    }
    static async readString(stream4, options3 = {}) {
      const u8arr = await AvroParser.readBytes(stream4, options3);
      const utf8decoder = new TextDecoder;
      return utf8decoder.decode(u8arr);
    }
    static async readMapPair(stream4, readItemMethod, options3 = {}) {
      const key = await AvroParser.readString(stream4, options3);
      const value = await readItemMethod(stream4, options3);
      return { key, value };
    }
    static async readMap(stream4, readItemMethod, options3 = {}) {
      const readPairMethod = (s, opts = {}) => {
        return AvroParser.readMapPair(s, readItemMethod, opts);
      };
      const pairs = await AvroParser.readArray(stream4, readPairMethod, options3);
      const dict = {};
      for (const pair of pairs) {
        dict[pair.key] = pair.value;
      }
      return dict;
    }
    static async readArray(stream4, readItemMethod, options3 = {}) {
      const items = [];
      for (let count2 = await AvroParser.readLong(stream4, options3);count2 !== 0; count2 = await AvroParser.readLong(stream4, options3)) {
        if (count2 < 0) {
          await AvroParser.readLong(stream4, options3);
          count2 = -count2;
        }
        while (count2--) {
          const item = await readItemMethod(stream4, options3);
          items.push(item);
        }
      }
      return items;
    }
  }
  var AvroComplex;
  (function(AvroComplex2) {
    AvroComplex2["RECORD"] = "record";
    AvroComplex2["ENUM"] = "enum";
    AvroComplex2["ARRAY"] = "array";
    AvroComplex2["MAP"] = "map";
    AvroComplex2["UNION"] = "union";
    AvroComplex2["FIXED"] = "fixed";
  })(AvroComplex || (AvroComplex = {}));
  var AvroPrimitive;
  (function(AvroPrimitive2) {
    AvroPrimitive2["NULL"] = "null";
    AvroPrimitive2["BOOLEAN"] = "boolean";
    AvroPrimitive2["INT"] = "int";
    AvroPrimitive2["LONG"] = "long";
    AvroPrimitive2["FLOAT"] = "float";
    AvroPrimitive2["DOUBLE"] = "double";
    AvroPrimitive2["BYTES"] = "bytes";
    AvroPrimitive2["STRING"] = "string";
  })(AvroPrimitive || (AvroPrimitive = {}));

  class AvroType {
    static fromSchema(schema) {
      if (typeof schema === "string") {
        return AvroType.fromStringSchema(schema);
      } else if (Array.isArray(schema)) {
        return AvroType.fromArraySchema(schema);
      } else {
        return AvroType.fromObjectSchema(schema);
      }
    }
    static fromStringSchema(schema) {
      switch (schema) {
        case AvroPrimitive.NULL:
        case AvroPrimitive.BOOLEAN:
        case AvroPrimitive.INT:
        case AvroPrimitive.LONG:
        case AvroPrimitive.FLOAT:
        case AvroPrimitive.DOUBLE:
        case AvroPrimitive.BYTES:
        case AvroPrimitive.STRING:
          return new AvroPrimitiveType(schema);
        default:
          throw new Error(`Unexpected Avro type ${schema}`);
      }
    }
    static fromArraySchema(schema) {
      return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
      const type15 = schema.type;
      try {
        return AvroType.fromStringSchema(type15);
      } catch (err) {
      }
      switch (type15) {
        case AvroComplex.RECORD:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.name) {
            throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
          }
          const fields = {};
          if (!schema.fields) {
            throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
          }
          for (const field of schema.fields) {
            fields[field.name] = AvroType.fromSchema(field.type);
          }
          return new AvroRecordType(fields, schema.name);
        case AvroComplex.ENUM:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.symbols) {
            throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
          }
          return new AvroEnumType(schema.symbols);
        case AvroComplex.MAP:
          if (!schema.values) {
            throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
          }
          return new AvroMapType(AvroType.fromSchema(schema.values));
        case AvroComplex.ARRAY:
        case AvroComplex.FIXED:
        default:
          throw new Error(`Unexpected Avro type ${type15} in ${schema}`);
      }
    }
  }

  class AvroPrimitiveType extends AvroType {
    constructor(primitive) {
      super();
      this._primitive = primitive;
    }
    read(stream4, options3 = {}) {
      switch (this._primitive) {
        case AvroPrimitive.NULL:
          return AvroParser.readNull();
        case AvroPrimitive.BOOLEAN:
          return AvroParser.readBoolean(stream4, options3);
        case AvroPrimitive.INT:
          return AvroParser.readInt(stream4, options3);
        case AvroPrimitive.LONG:
          return AvroParser.readLong(stream4, options3);
        case AvroPrimitive.FLOAT:
          return AvroParser.readFloat(stream4, options3);
        case AvroPrimitive.DOUBLE:
          return AvroParser.readDouble(stream4, options3);
        case AvroPrimitive.BYTES:
          return AvroParser.readBytes(stream4, options3);
        case AvroPrimitive.STRING:
          return AvroParser.readString(stream4, options3);
        default:
          throw new Error("Unknown Avro Primitive");
      }
    }
  }

  class AvroEnumType extends AvroType {
    constructor(symbols) {
      super();
      this._symbols = symbols;
    }
    async read(stream4, options3 = {}) {
      const value = await AvroParser.readInt(stream4, options3);
      return this._symbols[value];
    }
  }

  class AvroUnionType extends AvroType {
    constructor(types) {
      super();
      this._types = types;
    }
    async read(stream4, options3 = {}) {
      const typeIndex = await AvroParser.readInt(stream4, options3);
      return this._types[typeIndex].read(stream4, options3);
    }
  }

  class AvroMapType extends AvroType {
    constructor(itemType) {
      super();
      this._itemType = itemType;
    }
    read(stream4, options3 = {}) {
      const readItemMethod = (s, opts) => {
        return this._itemType.read(s, opts);
      };
      return AvroParser.readMap(stream4, readItemMethod, options3);
    }
  }

  class AvroRecordType extends AvroType {
    constructor(fields, name) {
      super();
      this._fields = fields;
      this._name = name;
    }
    async read(stream4, options3 = {}) {
      const record = {};
      record["$schema"] = this._name;
      for (const key in this._fields) {
        if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
          record[key] = await this._fields[key].read(stream4, options3);
        }
      }
      return record;
    }
  }

  class AvroReader {
    get blockOffset() {
      return this._blockOffset;
    }
    get objectIndex() {
      return this._objectIndex;
    }
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
      this._dataStream = dataStream;
      this._headerStream = headerStream || dataStream;
      this._initialized = false;
      this._blockOffset = currentBlockOffset || 0;
      this._objectIndex = indexWithinCurrentBlock || 0;
      this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options3 = {}) {
      const header = await AvroParser.readFixedBytes(this._headerStream, AVRO_INIT_BYTES.length, {
        abortSignal: options3.abortSignal
      });
      if (!arraysEqual(header, AVRO_INIT_BYTES)) {
        throw new Error("Stream is not an Avro file.");
      }
      this._metadata = await AvroParser.readMap(this._headerStream, AvroParser.readString, {
        abortSignal: options3.abortSignal
      });
      const codec = this._metadata[AVRO_CODEC_KEY];
      if (!(codec === undefined || codec === null || codec === "null")) {
        throw new Error("Codecs are not supported");
      }
      this._syncMarker = await AvroParser.readFixedBytes(this._headerStream, AVRO_SYNC_MARKER_SIZE, {
        abortSignal: options3.abortSignal
      });
      const schema = JSON.parse(this._metadata[AVRO_SCHEMA_KEY]);
      this._itemType = AvroType.fromSchema(schema);
      if (this._blockOffset === 0) {
        this._blockOffset = this._initialBlockOffset + this._dataStream.position;
      }
      this._itemsRemainingInBlock = await AvroParser.readLong(this._dataStream, {
        abortSignal: options3.abortSignal
      });
      await AvroParser.readLong(this._dataStream, { abortSignal: options3.abortSignal });
      this._initialized = true;
      if (this._objectIndex && this._objectIndex > 0) {
        for (let i2 = 0;i2 < this._objectIndex; i2++) {
          await this._itemType.read(this._dataStream, { abortSignal: options3.abortSignal });
          this._itemsRemainingInBlock--;
        }
      }
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    parseObjects() {
      return tslib.__asyncGenerator(this, arguments, function* parseObjects_1(options3 = {}) {
        if (!this._initialized) {
          yield tslib.__await(this.initialize(options3));
        }
        while (this.hasNext()) {
          const result5 = yield tslib.__await(this._itemType.read(this._dataStream, {
            abortSignal: options3.abortSignal
          }));
          this._itemsRemainingInBlock--;
          this._objectIndex++;
          if (this._itemsRemainingInBlock === 0) {
            const marker2 = yield tslib.__await(AvroParser.readFixedBytes(this._dataStream, AVRO_SYNC_MARKER_SIZE, {
              abortSignal: options3.abortSignal
            }));
            this._blockOffset = this._initialBlockOffset + this._dataStream.position;
            this._objectIndex = 0;
            if (!arraysEqual(this._syncMarker, marker2)) {
              throw new Error("Stream is not a valid Avro file.");
            }
            try {
              this._itemsRemainingInBlock = yield tslib.__await(AvroParser.readLong(this._dataStream, {
                abortSignal: options3.abortSignal
              }));
            } catch (err) {
              this._itemsRemainingInBlock = 0;
            }
            if (this._itemsRemainingInBlock > 0) {
              yield tslib.__await(AvroParser.readLong(this._dataStream, { abortSignal: options3.abortSignal }));
            }
          }
          yield yield tslib.__await(result5);
        }
      });
    }
  }

  class AvroReadable {
  }
  var ABORT_ERROR = new abortController.AbortError("Reading from the avro stream was aborted.");

  class AvroReadableFromStream extends AvroReadable {
    toUint8Array(data) {
      if (typeof data === "string") {
        return Buffer.from(data);
      }
      return data;
    }
    constructor(readable4) {
      super();
      this._readable = readable4;
      this._position = 0;
    }
    get position() {
      return this._position;
    }
    async read(size, options3 = {}) {
      var _a;
      if ((_a = options3.abortSignal) === null || _a === undefined ? undefined : _a.aborted) {
        throw ABORT_ERROR;
      }
      if (size < 0) {
        throw new Error(`size parameter should be positive: ${size}`);
      }
      if (size === 0) {
        return new Uint8Array;
      }
      if (!this._readable.readable) {
        throw new Error("Stream no longer readable.");
      }
      const chunk = this._readable.read(size);
      if (chunk) {
        this._position += chunk.length;
        return this.toUint8Array(chunk);
      } else {
        return new Promise((resolve, reject4) => {
          const cleanUp = () => {
            this._readable.removeListener("readable", readableCallback);
            this._readable.removeListener("error", rejectCallback);
            this._readable.removeListener("end", rejectCallback);
            this._readable.removeListener("close", rejectCallback);
            if (options3.abortSignal) {
              options3.abortSignal.removeEventListener("abort", abortHandler);
            }
          };
          const readableCallback = () => {
            const callbackChunk = this._readable.read(size);
            if (callbackChunk) {
              this._position += callbackChunk.length;
              cleanUp();
              resolve(this.toUint8Array(callbackChunk));
            }
          };
          const rejectCallback = () => {
            cleanUp();
            reject4();
          };
          const abortHandler = () => {
            cleanUp();
            reject4(ABORT_ERROR);
          };
          this._readable.on("readable", readableCallback);
          this._readable.once("error", rejectCallback);
          this._readable.once("end", rejectCallback);
          this._readable.once("close", rejectCallback);
          if (options3.abortSignal) {
            options3.abortSignal.addEventListener("abort", abortHandler);
          }
        });
      }
    }
  }

  class BlobQuickQueryStream extends stream3.Readable {
    constructor(source, options3 = {}) {
      super();
      this.avroPaused = true;
      this.source = source;
      this.onProgress = options3.onProgress;
      this.onError = options3.onError;
      this.avroReader = new AvroReader(new AvroReadableFromStream(this.source));
      this.avroIter = this.avroReader.parseObjects({ abortSignal: options3.abortSignal });
    }
    _read() {
      if (this.avroPaused) {
        this.readInternal().catch((err) => {
          this.emit("error", err);
        });
      }
    }
    async readInternal() {
      this.avroPaused = false;
      let avroNext;
      do {
        avroNext = await this.avroIter.next();
        if (avroNext.done) {
          break;
        }
        const obj = avroNext.value;
        const schema = obj.$schema;
        if (typeof schema !== "string") {
          throw Error("Missing schema in avro record.");
        }
        switch (schema) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              const data = obj.data;
              if (data instanceof Uint8Array === false) {
                throw Error("Invalid data in avro result record.");
              }
              if (!this.push(Buffer.from(data))) {
                this.avroPaused = true;
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              const bytesScanned = obj.bytesScanned;
              if (typeof bytesScanned !== "number") {
                throw Error("Invalid bytesScanned in avro progress record.");
              }
              if (this.onProgress) {
                this.onProgress({ loadedBytes: bytesScanned });
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              const totalBytes = obj.totalBytes;
              if (typeof totalBytes !== "number") {
                throw Error("Invalid totalBytes in avro end record.");
              }
              this.onProgress({ loadedBytes: totalBytes });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              const fatal = obj.fatal;
              if (typeof fatal !== "boolean") {
                throw Error("Invalid fatal in avro error record.");
              }
              const name = obj.name;
              if (typeof name !== "string") {
                throw Error("Invalid name in avro error record.");
              }
              const description = obj.description;
              if (typeof description !== "string") {
                throw Error("Invalid description in avro error record.");
              }
              const position = obj.position;
              if (typeof position !== "number") {
                throw Error("Invalid position in avro error record.");
              }
              this.onError({
                position,
                name,
                isFatal: fatal,
                description
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${schema} in avro progress record.`);
        }
      } while (!avroNext.done && !this.avroPaused);
    }
  }

  class BlobQueryResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get blobBody() {
      return;
    }
    get readableStreamBody() {
      return coreUtil.isNode ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    constructor(originalResponse, options3 = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new BlobQuickQueryStream(this.originalResponse.readableStreamBody, options3);
    }
  }
  exports.BlockBlobTier = undefined;
  (function(BlockBlobTier) {
    BlockBlobTier["Hot"] = "Hot";
    BlockBlobTier["Cool"] = "Cool";
    BlockBlobTier["Cold"] = "Cold";
    BlockBlobTier["Archive"] = "Archive";
  })(exports.BlockBlobTier || (exports.BlockBlobTier = {}));
  exports.PremiumPageBlobTier = undefined;
  (function(PremiumPageBlobTier) {
    PremiumPageBlobTier["P4"] = "P4";
    PremiumPageBlobTier["P6"] = "P6";
    PremiumPageBlobTier["P10"] = "P10";
    PremiumPageBlobTier["P15"] = "P15";
    PremiumPageBlobTier["P20"] = "P20";
    PremiumPageBlobTier["P30"] = "P30";
    PremiumPageBlobTier["P40"] = "P40";
    PremiumPageBlobTier["P50"] = "P50";
    PremiumPageBlobTier["P60"] = "P60";
    PremiumPageBlobTier["P70"] = "P70";
    PremiumPageBlobTier["P80"] = "P80";
  })(exports.PremiumPageBlobTier || (exports.PremiumPageBlobTier = {}));
  exports.StorageBlobAudience = undefined;
  (function(StorageBlobAudience) {
    StorageBlobAudience["StorageOAuthScopes"] = "https://storage.azure.com/.default";
    StorageBlobAudience["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
  })(exports.StorageBlobAudience || (exports.StorageBlobAudience = {}));

  class BlobBeginCopyFromUrlPoller extends coreLro.Poller {
    constructor(options3) {
      const { blobClient, copySource: copySource2, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options3;
      let state;
      if (resumeFrom) {
        state = JSON.parse(resumeFrom).state;
      }
      const operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state), {
        blobClient,
        copySource: copySource2,
        startCopyFromURLOptions
      }));
      super(operation);
      if (typeof onProgress === "function") {
        this.onProgress(onProgress);
      }
      this.intervalInMs = intervalInMs;
    }
    delay() {
      return coreUtil.delay(this.intervalInMs);
    }
  }
  var cancel3 = async function cancel(options3 = {}) {
    const state = this.state;
    const { copyId: copyId2 } = state;
    if (state.isCompleted) {
      return makeBlobBeginCopyFromURLPollOperation(state);
    }
    if (!copyId2) {
      state.isCancelled = true;
      return makeBlobBeginCopyFromURLPollOperation(state);
    }
    await state.blobClient.abortCopyFromURL(copyId2, {
      abortSignal: options3.abortSignal
    });
    state.isCancelled = true;
    return makeBlobBeginCopyFromURLPollOperation(state);
  };
  var update = async function update(options3 = {}) {
    const state = this.state;
    const { blobClient, copySource: copySource2, startCopyFromURLOptions } = state;
    if (!state.isStarted) {
      state.isStarted = true;
      const result5 = await blobClient.startCopyFromURL(copySource2, startCopyFromURLOptions);
      state.copyId = result5.copyId;
      if (result5.copyStatus === "success") {
        state.result = result5;
        state.isCompleted = true;
      }
    } else if (!state.isCompleted) {
      try {
        const result5 = await state.blobClient.getProperties({ abortSignal: options3.abortSignal });
        const { copyStatus, copyProgress } = result5;
        const prevCopyProgress = state.copyProgress;
        if (copyProgress) {
          state.copyProgress = copyProgress;
        }
        if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options3.fireProgress === "function") {
          options3.fireProgress(state);
        } else if (copyStatus === "success") {
          state.result = result5;
          state.isCompleted = true;
        } else if (copyStatus === "failed") {
          state.error = new Error(`Blob copy failed with reason: "${result5.copyStatusDescription || "unknown"}"`);
          state.isCompleted = true;
        }
      } catch (err) {
        state.error = err;
        state.isCompleted = true;
      }
    }
    return makeBlobBeginCopyFromURLPollOperation(state);
  };
  var toString2 = function toString() {
    return JSON.stringify({ state: this.state }, (key, value) => {
      if (key === "blobClient") {
        return;
      }
      return value;
    });
  };
  var BatchStates;
  (function(BatchStates2) {
    BatchStates2[BatchStates2["Good"] = 0] = "Good";
    BatchStates2[BatchStates2["Error"] = 1] = "Error";
  })(BatchStates || (BatchStates = {}));

  class Batch {
    constructor(concurrency = 5) {
      this.actives = 0;
      this.completed = 0;
      this.offset = 0;
      this.operations = [];
      this.state = BatchStates.Good;
      if (concurrency < 1) {
        throw new RangeError("concurrency must be larger than 0");
      }
      this.concurrency = concurrency;
      this.emitter = new events.EventEmitter;
    }
    addOperation(operation) {
      this.operations.push(async () => {
        try {
          this.actives++;
          await operation();
          this.actives--;
          this.completed++;
          this.parallelExecute();
        } catch (error2) {
          this.emitter.emit("error", error2);
        }
      });
    }
    async do() {
      if (this.operations.length === 0) {
        return Promise.resolve();
      }
      this.parallelExecute();
      return new Promise((resolve, reject4) => {
        this.emitter.on("finish", resolve);
        this.emitter.on("error", (error2) => {
          this.state = BatchStates.Error;
          reject4(error2);
        });
      });
    }
    nextOperation() {
      if (this.offset < this.operations.length) {
        return this.operations[this.offset++];
      }
      return null;
    }
    parallelExecute() {
      if (this.state === BatchStates.Error) {
        return;
      }
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        const operation = this.nextOperation();
        if (operation) {
          operation();
        } else {
          return;
        }
      }
    }
  }

  class BuffersStream extends stream3.Readable {
    constructor(buffers, byteLength, options3) {
      super(options3);
      this.buffers = buffers;
      this.byteLength = byteLength;
      this.byteOffsetInCurrentBuffer = 0;
      this.bufferIndex = 0;
      this.pushedBytesLength = 0;
      let buffersLength = 0;
      for (const buf of this.buffers) {
        buffersLength += buf.byteLength;
      }
      if (buffersLength < this.byteLength) {
        throw new Error("Data size shouldn't be larger than the total length of buffers.");
      }
    }
    _read(size) {
      if (this.pushedBytesLength >= this.byteLength) {
        this.push(null);
      }
      if (!size) {
        size = this.readableHighWaterMark;
      }
      const outBuffers = [];
      let i2 = 0;
      while (i2 < size && this.pushedBytesLength < this.byteLength) {
        const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
        const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
        const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
        if (remaining > size - i2) {
          const end = this.byteOffsetInCurrentBuffer + size - i2;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          this.pushedBytesLength += size - i2;
          this.byteOffsetInCurrentBuffer = end;
          i2 = size;
          break;
        } else {
          const end = this.byteOffsetInCurrentBuffer + remaining;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          if (remaining === remainingCapacityInThisBuffer) {
            this.byteOffsetInCurrentBuffer = 0;
            this.bufferIndex++;
          } else {
            this.byteOffsetInCurrentBuffer = end;
          }
          this.pushedBytesLength += remaining;
          i2 += remaining;
        }
      }
      if (outBuffers.length > 1) {
        this.push(Buffer.concat(outBuffers));
      } else if (outBuffers.length === 1) {
        this.push(outBuffers[0]);
      }
    }
  }
  var maxBufferLength = buffer.constants.MAX_LENGTH;

  class PooledBuffer {
    get size() {
      return this._size;
    }
    constructor(capacity, buffers, totalLength) {
      this.buffers = [];
      this.capacity = capacity;
      this._size = 0;
      const bufferNum = Math.ceil(capacity / maxBufferLength);
      for (let i2 = 0;i2 < bufferNum; i2++) {
        let len = i2 === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
        if (len === 0) {
          len = maxBufferLength;
        }
        this.buffers.push(Buffer.allocUnsafe(len));
      }
      if (buffers) {
        this.fill(buffers, totalLength);
      }
    }
    fill(buffers, totalLength) {
      this._size = Math.min(this.capacity, totalLength);
      let i2 = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
      while (totalCopiedNum < this._size) {
        const source = buffers[i2];
        const target = this.buffers[j];
        const copiedNum = source.copy(target, targetOffset, sourceOffset);
        totalCopiedNum += copiedNum;
        sourceOffset += copiedNum;
        targetOffset += copiedNum;
        if (sourceOffset === source.length) {
          i2++;
          sourceOffset = 0;
        }
        if (targetOffset === target.length) {
          j++;
          targetOffset = 0;
        }
      }
      buffers.splice(0, i2);
      if (buffers.length > 0) {
        buffers[0] = buffers[0].slice(sourceOffset);
      }
    }
    getReadableStream() {
      return new BuffersStream(this.buffers, this.size);
    }
  }

  class BufferScheduler {
    constructor(readable4, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
      this.emitter = new events.EventEmitter;
      this.offset = 0;
      this.isStreamEnd = false;
      this.isError = false;
      this.executingOutgoingHandlers = 0;
      this.numBuffers = 0;
      this.unresolvedDataArray = [];
      this.unresolvedLength = 0;
      this.incoming = [];
      this.outgoing = [];
      if (bufferSize <= 0) {
        throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
      }
      if (maxBuffers <= 0) {
        throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
      }
      if (concurrency <= 0) {
        throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
      }
      this.bufferSize = bufferSize;
      this.maxBuffers = maxBuffers;
      this.readable = readable4;
      this.outgoingHandler = outgoingHandler;
      this.concurrency = concurrency;
      this.encoding = encoding;
    }
    async do() {
      return new Promise((resolve, reject4) => {
        this.readable.on("data", (data) => {
          data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
          this.appendUnresolvedData(data);
          if (!this.resolveData()) {
            this.readable.pause();
          }
        });
        this.readable.on("error", (err) => {
          this.emitter.emit("error", err);
        });
        this.readable.on("end", () => {
          this.isStreamEnd = true;
          this.emitter.emit("checkEnd");
        });
        this.emitter.on("error", (err) => {
          this.isError = true;
          this.readable.pause();
          reject4(err);
        });
        this.emitter.on("checkEnd", () => {
          if (this.outgoing.length > 0) {
            this.triggerOutgoingHandlers();
            return;
          }
          if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
            if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
              const buffer2 = this.shiftBufferFromUnresolvedDataArray();
              this.outgoingHandler(() => buffer2.getReadableStream(), buffer2.size, this.offset).then(resolve).catch(reject4);
            } else if (this.unresolvedLength >= this.bufferSize) {
              return;
            } else {
              resolve();
            }
          }
        });
      });
    }
    appendUnresolvedData(data) {
      this.unresolvedDataArray.push(data);
      this.unresolvedLength += data.length;
    }
    shiftBufferFromUnresolvedDataArray(buffer2) {
      if (!buffer2) {
        buffer2 = new PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
      } else {
        buffer2.fill(this.unresolvedDataArray, this.unresolvedLength);
      }
      this.unresolvedLength -= buffer2.size;
      return buffer2;
    }
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let buffer2;
        if (this.incoming.length > 0) {
          buffer2 = this.incoming.shift();
          this.shiftBufferFromUnresolvedDataArray(buffer2);
        } else {
          if (this.numBuffers < this.maxBuffers) {
            buffer2 = this.shiftBufferFromUnresolvedDataArray();
            this.numBuffers++;
          } else {
            return false;
          }
        }
        this.outgoing.push(buffer2);
        this.triggerOutgoingHandlers();
      }
      return true;
    }
    async triggerOutgoingHandlers() {
      let buffer2;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency) {
          return;
        }
        buffer2 = this.outgoing.shift();
        if (buffer2) {
          this.triggerOutgoingHandler(buffer2);
        }
      } while (buffer2);
    }
    async triggerOutgoingHandler(buffer2) {
      const bufferLength = buffer2.size;
      this.executingOutgoingHandlers++;
      this.offset += bufferLength;
      try {
        await this.outgoingHandler(() => buffer2.getReadableStream(), bufferLength, this.offset - bufferLength);
      } catch (err) {
        this.emitter.emit("error", err);
        return;
      }
      this.executingOutgoingHandlers--;
      this.reuseBuffer(buffer2);
      this.emitter.emit("checkEnd");
    }
    reuseBuffer(buffer2) {
      this.incoming.push(buffer2);
      if (!this.isError && this.resolveData() && !this.isStreamEnd) {
        this.readable.resume();
      }
    }
  }
  var fsStat = util__namespace.promisify(fs__namespace.stat);
  var fsCreateReadStream = fs__namespace.createReadStream;

  class BlobClient extends StorageClient {
    get name() {
      return this._name;
    }
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options3) {
      options3 = options3 || {};
      let pipeline4;
      let url2;
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline4 = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options3 = blobNameOrOptions;
        pipeline4 = newPipeline(credentialOrPipelineOrContainerName, options3);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options3 = blobNameOrOptions;
        }
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options3.proxyOptions) {
              options3.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline4 = newPipeline(sharedKeyCredential, options3);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline4 = newPipeline(new AnonymousCredential, options3);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline4);
      ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
      this.blobContext = this.storageClientContext.blob;
      this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);
      this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);
    }
    withSnapshot(snapshot2) {
      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    withVersion(versionId2) {
      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId2.length === 0 ? undefined : versionId2), this.pipeline);
    }
    getAppendBlobClient() {
      return new AppendBlobClient(this.url, this.pipeline);
    }
    getBlockBlobClient() {
      return new BlockBlobClient(this.url, this.pipeline);
    }
    getPageBlobClient() {
      return new PageBlobClient(this.url, this.pipeline);
    }
    async download(offset = 0, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-download", options3, async (updatedOptions) => {
        var _a;
        const res = assertResponse(await this.blobContext.download({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onDownloadProgress: coreUtil.isNode ? undefined : options3.onProgress
          },
          range: offset === 0 && !count2 ? undefined : rangeToString({ offset, count: count2 }),
          rangeGetContentMD5: options3.rangeGetContentMD5,
          rangeGetContentCRC64: options3.rangeGetContentCrc64,
          snapshot: options3.snapshot,
          cpkInfo: options3.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedRes = Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });
        if (!coreUtil.isNode) {
          return wrappedRes;
        }
        if (options3.maxRetryRequests === undefined || options3.maxRetryRequests < 0) {
          options3.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
        }
        if (res.contentLength === undefined) {
          throw new RangeError(`File download response doesn't contain valid content length header`);
        }
        if (!res.etag) {
          throw new RangeError(`File download response doesn't contain valid etag header`);
        }
        return new BlobDownloadResponse(wrappedRes, async (start2) => {
          var _a2;
          const updatedDownloadOptions = {
            leaseAccessConditions: options3.conditions,
            modifiedAccessConditions: {
              ifMatch: options3.conditions.ifMatch || res.etag,
              ifModifiedSince: options3.conditions.ifModifiedSince,
              ifNoneMatch: options3.conditions.ifNoneMatch,
              ifUnmodifiedSince: options3.conditions.ifUnmodifiedSince,
              ifTags: (_a2 = options3.conditions) === null || _a2 === undefined ? undefined : _a2.tagConditions
            },
            range: rangeToString({
              count: offset + res.contentLength - start2,
              offset: start2
            }),
            rangeGetContentMD5: options3.rangeGetContentMD5,
            rangeGetContentCRC64: options3.rangeGetContentCrc64,
            snapshot: options3.snapshot,
            cpkInfo: options3.customerProvidedKey
          };
          return (await this.blobContext.download(Object.assign({ abortSignal: options3.abortSignal }, updatedDownloadOptions))).readableStreamBody;
        }, offset, res.contentLength, {
          maxRetryRequests: options3.maxRetryRequests,
          onProgress: options3.onProgress
        });
      });
    }
    async exists(options3 = {}) {
      return tracingClient.withSpan("BlobClient-exists", options3, async (updatedOptions) => {
        try {
          ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
          await this.getProperties({
            abortSignal: options3.abortSignal,
            customerProvidedKey: options3.customerProvidedKey,
            conditions: options3.conditions,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          } else if (e.statusCode === 409 && (e.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)) {
            return true;
          }
          throw e;
        }
      });
    }
    async getProperties(options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-getProperties", options3, async (updatedOptions) => {
        var _a;
        const res = assertResponse(await this.blobContext.getProperties({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });
      });
    }
    async delete(options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("BlobClient-delete", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.delete({
          abortSignal: options3.abortSignal,
          deleteSnapshots: options3.deleteSnapshots,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options3 = {}) {
      return tracingClient.withSpan("BlobClient-deleteIfExists", options3, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = assertResponse(await this.delete(updatedOptions));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "BlobNotFound") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async undelete(options3 = {}) {
      return tracingClient.withSpan("BlobClient-undelete", options3, async (updatedOptions) => {
        return assertResponse(await this.blobContext.undelete({
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setHTTPHeaders(blobHTTPHeaders, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-setHTTPHeaders", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setHttpHeaders({
          abortSignal: options3.abortSignal,
          blobHttpHeaders: blobHTTPHeaders,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setMetadata(metadata2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-setMetadata", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setMetadata({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          metadata: metadata2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setTags(tags2, options3 = {}) {
      return tracingClient.withSpan("BlobClient-setTags", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setTags({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions,
          tags: toBlobTags(tags2)
        }));
      });
    }
    async getTags(options3 = {}) {
      return tracingClient.withSpan("BlobClient-getTags", options3, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.blobContext.getTags({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, tags: toTags({ blobTagSet: response.blobTagSet }) || {} });
        return wrappedResponse;
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient(this, proposeLeaseId);
    }
    async createSnapshot(options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-createSnapshot", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.createSnapshot({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          metadata: options3.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async beginCopyFromURL(copySource2, options3 = {}) {
      const client = {
        abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
        getProperties: (...args) => this.getProperties(...args),
        startCopyFromURL: (...args) => this.startCopyFromURL(...args)
      };
      const poller = new BlobBeginCopyFromUrlPoller({
        blobClient: client,
        copySource: copySource2,
        intervalInMs: options3.intervalInMs,
        onProgress: options3.onProgress,
        resumeFrom: options3.resumeFrom,
        startCopyFromURLOptions: options3
      });
      await poller.poll();
      return poller;
    }
    async abortCopyFromURL(copyId2, options3 = {}) {
      return tracingClient.withSpan("BlobClient-abortCopyFromURL", options3, async (updatedOptions) => {
        return assertResponse(await this.blobContext.abortCopyFromURL(copyId2, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncCopyFromURL(copySource2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      options3.sourceConditions = options3.sourceConditions || {};
      return tracingClient.withSpan("BlobClient-syncCopyFromURL", options3, async (updatedOptions) => {
        var _a, _b, _c, _d, _e, _f, _g;
        return assertResponse(await this.blobContext.copyFromURL(copySource2, {
          abortSignal: options3.abortSignal,
          metadata: options3.metadata,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b = options3.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
            sourceIfModifiedSince: (_c = options3.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
            sourceIfNoneMatch: (_d = options3.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e = options3.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince
          },
          sourceContentMD5: options3.sourceContentMD5,
          copySourceAuthorization: httpAuthorizationToString(options3.sourceAuthorization),
          tier: toAccessTier(options3.tier),
          blobTagsString: toBlobTagsString(options3.tags),
          immutabilityPolicyExpiry: (_f = options3.immutabilityPolicy) === null || _f === undefined ? undefined : _f.expiriesOn,
          immutabilityPolicyMode: (_g = options3.immutabilityPolicy) === null || _g === undefined ? undefined : _g.policyMode,
          legalHold: options3.legalHold,
          encryptionScope: options3.encryptionScope,
          copySourceTags: options3.copySourceTags,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setAccessTier(tier2, options3 = {}) {
      return tracingClient.withSpan("BlobClient-setAccessTier", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.blobContext.setTier(toAccessTier(tier2), {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          rehydratePriority: options3.rehydratePriority,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async downloadToBuffer(param1, param2, param3, param4 = {}) {
      var _a;
      let buffer2;
      let offset = 0;
      let count2 = 0;
      let options3 = param4;
      if (param1 instanceof Buffer) {
        buffer2 = param1;
        offset = param2 || 0;
        count2 = typeof param3 === "number" ? param3 : 0;
      } else {
        offset = typeof param1 === "number" ? param1 : 0;
        count2 = typeof param2 === "number" ? param2 : 0;
        options3 = param3 || {};
      }
      let blockSize = (_a = options3.blockSize) !== null && _a !== undefined ? _a : 0;
      if (blockSize < 0) {
        throw new RangeError("blockSize option must be >= 0");
      }
      if (blockSize === 0) {
        blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      }
      if (offset < 0) {
        throw new RangeError("offset option must be >= 0");
      }
      if (count2 && count2 <= 0) {
        throw new RangeError("count option must be greater than 0");
      }
      if (!options3.conditions) {
        options3.conditions = {};
      }
      return tracingClient.withSpan("BlobClient-downloadToBuffer", options3, async (updatedOptions) => {
        if (!count2) {
          const response = await this.getProperties(Object.assign(Object.assign({}, options3), { tracingOptions: updatedOptions.tracingOptions }));
          count2 = response.contentLength - offset;
          if (count2 < 0) {
            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
          }
        }
        if (!buffer2) {
          try {
            buffer2 = Buffer.alloc(count2);
          } catch (error2) {
            throw new Error(`Unable to allocate the buffer of size: ${count2}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${error2.message}`);
          }
        }
        if (buffer2.length < count2) {
          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count2}`);
        }
        let transferProgress = 0;
        const batch = new Batch(options3.concurrency);
        for (let off = offset;off < offset + count2; off = off + blockSize) {
          batch.addOperation(async () => {
            let chunkEnd = offset + count2;
            if (off + blockSize < chunkEnd) {
              chunkEnd = off + blockSize;
            }
            const response = await this.download(off, chunkEnd - off, {
              abortSignal: options3.abortSignal,
              conditions: options3.conditions,
              maxRetryRequests: options3.maxRetryRequestsPerBlock,
              customerProvidedKey: options3.customerProvidedKey,
              tracingOptions: updatedOptions.tracingOptions
            });
            const stream4 = response.readableStreamBody;
            await streamToBuffer(stream4, buffer2, off - offset, chunkEnd - offset);
            transferProgress += chunkEnd - off;
            if (options3.onProgress) {
              options3.onProgress({ loadedBytes: transferProgress });
            }
          });
        }
        await batch.do();
        return buffer2;
      });
    }
    async downloadToFile(filePath, offset = 0, count2, options3 = {}) {
      return tracingClient.withSpan("BlobClient-downloadToFile", options3, async (updatedOptions) => {
        const response = await this.download(offset, count2, Object.assign(Object.assign({}, options3), { tracingOptions: updatedOptions.tracingOptions }));
        if (response.readableStreamBody) {
          await readStreamToLocalFile(response.readableStreamBody, filePath);
        }
        response.blobDownloadStream = undefined;
        return response;
      });
    }
    getBlobAndContainerNamesFromUrl() {
      let containerName;
      let blobName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.host.split(".")[1] === "blob") {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        } else if (isIpEndpointStyle(parsedUrl)) {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          containerName = pathComponents[2];
          blobName = pathComponents[4];
        } else {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        }
        containerName = decodeURIComponent(containerName);
        blobName = decodeURIComponent(blobName);
        blobName = blobName.replace(/\\/g, "/");
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return { blobName, containerName };
      } catch (error2) {
        throw new Error("Unable to extract blobName and containerName with provided information.");
      }
    }
    async startCopyFromURL(copySource2, options3 = {}) {
      return tracingClient.withSpan("BlobClient-startCopyFromURL", options3, async (updatedOptions) => {
        var _a, _b, _c;
        options3.conditions = options3.conditions || {};
        options3.sourceConditions = options3.sourceConditions || {};
        return assertResponse(await this.blobContext.startCopyFromURL(copySource2, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          metadata: options3.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: options3.sourceConditions.ifMatch,
            sourceIfModifiedSince: options3.sourceConditions.ifModifiedSince,
            sourceIfNoneMatch: options3.sourceConditions.ifNoneMatch,
            sourceIfUnmodifiedSince: options3.sourceConditions.ifUnmodifiedSince,
            sourceIfTags: options3.sourceConditions.tagConditions
          },
          immutabilityPolicyExpiry: (_b = options3.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options3.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options3.legalHold,
          rehydratePriority: options3.rehydratePriority,
          tier: toAccessTier(options3.tier),
          blobTagsString: toBlobTagsString(options3.tags),
          sealBlob: options3.sealBlob,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    generateSasUrl(options3) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options3), this.credential).toString();
        resolve(appendToURLQuery(this.url, sas));
      });
    }
    async deleteImmutabilityPolicy(options3 = {}) {
      return tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options3, async (updatedOptions) => {
        return assertResponse(await this.blobContext.deleteImmutabilityPolicy({
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setImmutabilityPolicy(immutabilityPolicy, options3 = {}) {
      return tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options3, async (updatedOptions) => {
        return assertResponse(await this.blobContext.setImmutabilityPolicy({
          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
          immutabilityPolicyMode: immutabilityPolicy.policyMode,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setLegalHold(legalHoldEnabled, options3 = {}) {
      return tracingClient.withSpan("BlobClient-setLegalHold", options3, async (updatedOptions) => {
        return assertResponse(await this.blobContext.setLegalHold(legalHoldEnabled, {
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options3 = {}) {
      return tracingClient.withSpan("BlobClient-getAccountInfo", options3, async (updatedOptions) => {
        return assertResponse(await this.blobContext.getAccountInfo({
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }

  class AppendBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options3) {
      let pipeline4;
      let url2;
      options3 = options3 || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline4 = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options3 = blobNameOrOptions;
        pipeline4 = newPipeline(credentialOrPipelineOrContainerName, options3);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options3.proxyOptions) {
              options3.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline4 = newPipeline(sharedKeyCredential, options3);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline4 = newPipeline(new AnonymousCredential, options3);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline4);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    withSnapshot(snapshot2) {
      return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async create(options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-create", options3, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.appendBlobContext.create(0, {
          abortSignal: options3.abortSignal,
          blobHttpHeaders: options3.blobHTTPHeaders,
          leaseAccessConditions: options3.conditions,
          metadata: options3.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          immutabilityPolicyExpiry: (_b = options3.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options3.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options3.legalHold,
          blobTagsString: toBlobTagsString(options3.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(options3 = {}) {
      const conditions = { ifNoneMatch: ETagAny };
      return tracingClient.withSpan("AppendBlobClient-createIfNotExists", options3, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = assertResponse(await this.create(Object.assign(Object.assign({}, updatedOptions), { conditions })));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "BlobAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async seal(options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("AppendBlobClient-seal", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.appendBlobContext.seal({
          abortSignal: options3.abortSignal,
          appendPositionAccessConditions: options3.conditions,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlock(body2, contentLength2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-appendBlock", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.appendBlobContext.appendBlock(contentLength2, body2, {
          abortSignal: options3.abortSignal,
          appendPositionAccessConditions: options3.conditions,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onUploadProgress: options3.onProgress
          },
          transactionalContentMD5: options3.transactionalContentMD5,
          transactionalContentCrc64: options3.transactionalContentCrc64,
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlockFromURL(sourceURL, sourceOffset, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      options3.sourceConditions = options3.sourceConditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options3, async (updatedOptions) => {
        var _a, _b, _c, _d, _e;
        return assertResponse(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
          abortSignal: options3.abortSignal,
          sourceRange: rangeToString({ offset: sourceOffset, count: count2 }),
          sourceContentMD5: options3.sourceContentMD5,
          sourceContentCrc64: options3.sourceContentCrc64,
          leaseAccessConditions: options3.conditions,
          appendPositionAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b = options3.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
            sourceIfModifiedSince: (_c = options3.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
            sourceIfNoneMatch: (_d = options3.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e = options3.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince
          },
          copySourceAuthorization: httpAuthorizationToString(options3.sourceAuthorization),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }

  class BlockBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options3) {
      let pipeline4;
      let url2;
      options3 = options3 || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline4 = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options3 = blobNameOrOptions;
        pipeline4 = newPipeline(credentialOrPipelineOrContainerName, options3);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options3 = blobNameOrOptions;
        }
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options3.proxyOptions) {
              options3.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline4 = newPipeline(sharedKeyCredential, options3);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline4 = newPipeline(new AnonymousCredential, options3);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline4);
      this.blockBlobContext = this.storageClientContext.blockBlob;
      this._blobContext = this.storageClientContext.blob;
    }
    withSnapshot(snapshot2) {
      return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async query(query, options3 = {}) {
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      if (!coreUtil.isNode) {
        throw new Error("This operation currently is only supported in Node.js.");
      }
      return tracingClient.withSpan("BlockBlobClient-query", options3, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this._blobContext.query({
          abortSignal: options3.abortSignal,
          queryRequest: {
            queryType: "SQL",
            expression: query,
            inputSerialization: toQuerySerialization(options3.inputTextConfiguration),
            outputSerialization: toQuerySerialization(options3.outputTextConfiguration)
          },
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return new BlobQueryResponse(response, {
          abortSignal: options3.abortSignal,
          onProgress: options3.onProgress,
          onError: options3.onError
        });
      });
    }
    async upload(body2, contentLength2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-upload", options3, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.blockBlobContext.upload(contentLength2, body2, {
          abortSignal: options3.abortSignal,
          blobHttpHeaders: options3.blobHTTPHeaders,
          leaseAccessConditions: options3.conditions,
          metadata: options3.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onUploadProgress: options3.onProgress
          },
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          immutabilityPolicyExpiry: (_b = options3.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options3.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options3.legalHold,
          tier: toAccessTier(options3.tier),
          blobTagsString: toBlobTagsString(options3.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncUploadFromURL(sourceURL, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options3, async (updatedOptions) => {
        var _a, _b, _c, _d, _e, _f;
        return assertResponse(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign({}, options3), { blobHttpHeaders: options3.blobHTTPHeaders, leaseAccessConditions: options3.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }), sourceModifiedAccessConditions: {
          sourceIfMatch: (_b = options3.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
          sourceIfModifiedSince: (_c = options3.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
          sourceIfNoneMatch: (_d = options3.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
          sourceIfUnmodifiedSince: (_e = options3.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince,
          sourceIfTags: (_f = options3.sourceConditions) === null || _f === undefined ? undefined : _f.tagConditions
        }, cpkInfo: options3.customerProvidedKey, copySourceAuthorization: httpAuthorizationToString(options3.sourceAuthorization), tier: toAccessTier(options3.tier), blobTagsString: toBlobTagsString(options3.tags), copySourceTags: options3.copySourceTags, tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async stageBlock(blockId2, body2, contentLength2, options3 = {}) {
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-stageBlock", options3, async (updatedOptions) => {
        return assertResponse(await this.blockBlobContext.stageBlock(blockId2, contentLength2, body2, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          requestOptions: {
            onUploadProgress: options3.onProgress
          },
          transactionalContentMD5: options3.transactionalContentMD5,
          transactionalContentCrc64: options3.transactionalContentCrc64,
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlockFromURL(blockId2, sourceURL, offset = 0, count2, options3 = {}) {
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options3, async (updatedOptions) => {
        return assertResponse(await this.blockBlobContext.stageBlockFromURL(blockId2, 0, sourceURL, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          sourceContentMD5: options3.sourceContentMD5,
          sourceContentCrc64: options3.sourceContentCrc64,
          sourceRange: offset === 0 && !count2 ? undefined : rangeToString({ offset, count: count2 }),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          copySourceAuthorization: httpAuthorizationToString(options3.sourceAuthorization),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async commitBlockList(blocks2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-commitBlockList", options3, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.blockBlobContext.commitBlockList({ latest: blocks2 }, {
          abortSignal: options3.abortSignal,
          blobHttpHeaders: options3.blobHTTPHeaders,
          leaseAccessConditions: options3.conditions,
          metadata: options3.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          immutabilityPolicyExpiry: (_b = options3.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options3.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options3.legalHold,
          tier: toAccessTier(options3.tier),
          blobTagsString: toBlobTagsString(options3.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getBlockList(listType2, options3 = {}) {
      return tracingClient.withSpan("BlockBlobClient-getBlockList", options3, async (updatedOptions) => {
        var _a;
        const res = assertResponse(await this.blockBlobContext.getBlockList(listType2, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        if (!res.committedBlocks) {
          res.committedBlocks = [];
        }
        if (!res.uncommittedBlocks) {
          res.uncommittedBlocks = [];
        }
        return res;
      });
    }
    async uploadData(data, options3 = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadData", options3, async (updatedOptions) => {
        if (coreUtil.isNode) {
          let buffer2;
          if (data instanceof Buffer) {
            buffer2 = data;
          } else if (data instanceof ArrayBuffer) {
            buffer2 = Buffer.from(data);
          } else {
            data = data;
            buffer2 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          }
          return this.uploadSeekableInternal((offset, size) => buffer2.slice(offset, offset + size), buffer2.byteLength, updatedOptions);
        } else {
          const browserBlob = new Blob([data]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        }
      });
    }
    async uploadBrowserData(browserData, options3 = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options3, async (updatedOptions) => {
        const browserBlob = new Blob([browserData]);
        return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
      });
    }
    async uploadSeekableInternal(bodyFactory, size, options3 = {}) {
      var _a, _b;
      let blockSize = (_a = options3.blockSize) !== null && _a !== undefined ? _a : 0;
      if (blockSize < 0 || blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
        throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
      }
      const maxSingleShotSize = (_b = options3.maxSingleShotSize) !== null && _b !== undefined ? _b : BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (maxSingleShotSize < 0 || maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
      }
      if (blockSize === 0) {
        if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`${size} is too larger to upload to a block blob.`);
        }
        if (size > maxSingleShotSize) {
          blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);
          if (blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
            blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
          }
        }
      }
      if (!options3.blobHTTPHeaders) {
        options3.blobHTTPHeaders = {};
      }
      if (!options3.conditions) {
        options3.conditions = {};
      }
      return tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options3, async (updatedOptions) => {
        if (size <= maxSingleShotSize) {
          return assertResponse(await this.upload(bodyFactory(0, size), size, updatedOptions));
        }
        const numBlocks = Math.floor((size - 1) / blockSize) + 1;
        if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` + `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);
        }
        const blockList = [];
        const blockIDPrefix = coreUtil.randomUUID();
        let transferProgress = 0;
        const batch = new Batch(options3.concurrency);
        for (let i2 = 0;i2 < numBlocks; i2++) {
          batch.addOperation(async () => {
            const blockID = generateBlockID(blockIDPrefix, i2);
            const start2 = blockSize * i2;
            const end = i2 === numBlocks - 1 ? size : start2 + blockSize;
            const contentLength2 = end - start2;
            blockList.push(blockID);
            await this.stageBlock(blockID, bodyFactory(start2, contentLength2), contentLength2, {
              abortSignal: options3.abortSignal,
              conditions: options3.conditions,
              encryptionScope: options3.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            });
            transferProgress += contentLength2;
            if (options3.onProgress) {
              options3.onProgress({
                loadedBytes: transferProgress
              });
            }
          });
        }
        await batch.do();
        return this.commitBlockList(blockList, updatedOptions);
      });
    }
    async uploadFile(filePath, options3 = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadFile", options3, async (updatedOptions) => {
        const size = (await fsStat(filePath)).size;
        return this.uploadSeekableInternal((offset, count2) => {
          return () => fsCreateReadStream(filePath, {
            autoClose: true,
            end: count2 ? offset + count2 - 1 : Infinity,
            start: offset
          });
        }, size, Object.assign(Object.assign({}, options3), { tracingOptions: updatedOptions.tracingOptions }));
      });
    }
    async uploadStream(stream4, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options3 = {}) {
      if (!options3.blobHTTPHeaders) {
        options3.blobHTTPHeaders = {};
      }
      if (!options3.conditions) {
        options3.conditions = {};
      }
      return tracingClient.withSpan("BlockBlobClient-uploadStream", options3, async (updatedOptions) => {
        let blockNum = 0;
        const blockIDPrefix = coreUtil.randomUUID();
        let transferProgress = 0;
        const blockList = [];
        const scheduler3 = new BufferScheduler(stream4, bufferSize, maxConcurrency, async (body2, length) => {
          const blockID = generateBlockID(blockIDPrefix, blockNum);
          blockList.push(blockID);
          blockNum++;
          await this.stageBlock(blockID, body2, length, {
            conditions: options3.conditions,
            encryptionScope: options3.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          });
          transferProgress += length;
          if (options3.onProgress) {
            options3.onProgress({ loadedBytes: transferProgress });
          }
        }, Math.ceil(maxConcurrency / 4 * 3));
        await scheduler3.do();
        return assertResponse(await this.commitBlockList(blockList, Object.assign(Object.assign({}, options3), { tracingOptions: updatedOptions.tracingOptions })));
      });
    }
  }

  class PageBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options3) {
      let pipeline4;
      let url2;
      options3 = options3 || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline4 = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options3 = blobNameOrOptions;
        pipeline4 = newPipeline(credentialOrPipelineOrContainerName, options3);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options3.proxyOptions) {
              options3.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline4 = newPipeline(sharedKeyCredential, options3);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline4 = newPipeline(new AnonymousCredential, options3);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline4);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    withSnapshot(snapshot2) {
      return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async create(size, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-create", options3, async (updatedOptions) => {
        var _a, _b, _c;
        return assertResponse(await this.pageBlobContext.create(0, size, {
          abortSignal: options3.abortSignal,
          blobHttpHeaders: options3.blobHTTPHeaders,
          blobSequenceNumber: options3.blobSequenceNumber,
          leaseAccessConditions: options3.conditions,
          metadata: options3.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          immutabilityPolicyExpiry: (_b = options3.immutabilityPolicy) === null || _b === undefined ? undefined : _b.expiriesOn,
          immutabilityPolicyMode: (_c = options3.immutabilityPolicy) === null || _c === undefined ? undefined : _c.policyMode,
          legalHold: options3.legalHold,
          tier: toAccessTier(options3.tier),
          blobTagsString: toBlobTagsString(options3.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(size, options3 = {}) {
      return tracingClient.withSpan("PageBlobClient-createIfNotExists", options3, async (updatedOptions) => {
        var _a, _b;
        try {
          const conditions = { ifNoneMatch: ETagAny };
          const res = assertResponse(await this.create(size, Object.assign(Object.assign({}, options3), { conditions, tracingOptions: updatedOptions.tracingOptions })));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "BlobAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async uploadPages(body2, offset, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-uploadPages", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.uploadPages(count2, body2, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          requestOptions: {
            onUploadProgress: options3.onProgress
          },
          range: rangeToString({ offset, count: count2 }),
          sequenceNumberAccessConditions: options3.conditions,
          transactionalContentMD5: options3.transactionalContentMD5,
          transactionalContentCrc64: options3.transactionalContentCrc64,
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      options3.sourceConditions = options3.sourceConditions || {};
      ensureCpkIfSpecified(options3.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options3, async (updatedOptions) => {
        var _a, _b, _c, _d, _e;
        return assertResponse(await this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({ offset: sourceOffset, count: count2 }), 0, rangeToString({ offset: destOffset, count: count2 }), {
          abortSignal: options3.abortSignal,
          sourceContentMD5: options3.sourceContentMD5,
          sourceContentCrc64: options3.sourceContentCrc64,
          leaseAccessConditions: options3.conditions,
          sequenceNumberAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b = options3.sourceConditions) === null || _b === undefined ? undefined : _b.ifMatch,
            sourceIfModifiedSince: (_c = options3.sourceConditions) === null || _c === undefined ? undefined : _c.ifModifiedSince,
            sourceIfNoneMatch: (_d = options3.sourceConditions) === null || _d === undefined ? undefined : _d.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e = options3.sourceConditions) === null || _e === undefined ? undefined : _e.ifUnmodifiedSince
          },
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          copySourceAuthorization: httpAuthorizationToString(options3.sourceAuthorization),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async clearPages(offset = 0, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("PageBlobClient-clearPages", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.clearPages(0, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          range: rangeToString({ offset, count: count2 }),
          sequenceNumberAccessConditions: options3.conditions,
          cpkInfo: options3.customerProvidedKey,
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getPageRanges(offset = 0, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("PageBlobClient-getPageRanges", options3, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.pageBlobContext.getPageRanges({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          range: rangeToString({ offset, count: count2 }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(response);
      });
    }
    async listPageRangesSegment(offset = 0, count2, marker2, options3 = {}) {
      return tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.getPageRanges({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          range: rangeToString({ offset, count: count2 }),
          marker: marker2,
          maxPageSize: options3.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    listPageRangeItemSegments() {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeItemSegments_1(offset = 0, count2, marker2, options3 = {}) {
        let getPageRangeItemSegmentsResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            getPageRangeItemSegmentsResponse = yield tslib.__await(this.listPageRangesSegment(offset, count2, marker2, options3));
            marker2 = getPageRangeItemSegmentsResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(getPageRangeItemSegmentsResponse));
          } while (marker2);
        }
      });
    }
    listPageRangeItems() {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeItems_1(offset = 0, count2, options3 = {}) {
        var _a, e_1, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listPageRangeItemSegments(offset, count2, marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const getPageRangesSegment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    listPageRanges(offset = 0, count2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      const iter = this.listPageRangeItems(offset, count2, options3);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeItemSegments(offset, count2, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options3));
        }
      };
    }
    async getPageRangesDiff(offset, count2, prevSnapshot, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options3, async (updatedOptions) => {
        var _a;
        const result5 = assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          prevsnapshot: prevSnapshot,
          range: rangeToString({ offset, count: count2 }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(result5);
      });
    }
    async listPageRangesDiffSegment(offset, count2, prevSnapshotOrUrl, marker2, options3 = {}) {
      return tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options3 === null || options3 === undefined ? undefined : options3.abortSignal,
          leaseAccessConditions: options3 === null || options3 === undefined ? undefined : options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3 === null || options3 === undefined ? undefined : options3.conditions), { ifTags: (_a = options3 === null || options3 === undefined ? undefined : options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          prevsnapshot: prevSnapshotOrUrl,
          range: rangeToString({
            offset,
            count: count2
          }),
          marker: marker2,
          maxPageSize: options3 === null || options3 === undefined ? undefined : options3.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    listPageRangeDiffItemSegments(offset, count2, prevSnapshotOrUrl, marker2, options3) {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeDiffItemSegments_1() {
        let getPageRangeItemSegmentsResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            getPageRangeItemSegmentsResponse = yield tslib.__await(this.listPageRangesDiffSegment(offset, count2, prevSnapshotOrUrl, marker2, options3));
            marker2 = getPageRangeItemSegmentsResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(getPageRangeItemSegmentsResponse));
          } while (marker2);
        }
      });
    }
    listPageRangeDiffItems(offset, count2, prevSnapshotOrUrl, options3) {
      return tslib.__asyncGenerator(this, arguments, function* listPageRangeDiffItems_1() {
        var _a, e_2, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listPageRangeDiffItemSegments(offset, count2, prevSnapshotOrUrl, marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const getPageRangesSegment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listPageRangesDiff(offset, count2, prevSnapshot, options3 = {}) {
      options3.conditions = options3.conditions || {};
      const iter = this.listPageRangeDiffItems(offset, count2, prevSnapshot, Object.assign({}, options3));
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeDiffItemSegments(offset, count2, prevSnapshot, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options3));
        }
      };
    }
    async getPageRangesDiffForManagedDisks(offset, count2, prevSnapshotUrl2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options3, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          prevSnapshotUrl: prevSnapshotUrl2,
          range: rangeToString({ offset, count: count2 }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(response);
      });
    }
    async resize(size, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("PageBlobClient-resize", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.resize(size, {
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          encryptionScope: options3.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async updateSequenceNumber(sequenceNumberAction2, sequenceNumber, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction2, {
          abortSignal: options3.abortSignal,
          blobSequenceNumber: sequenceNumber,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async startCopyIncremental(copySource2, options3 = {}) {
      return tracingClient.withSpan("PageBlobClient-startCopyIncremental", options3, async (updatedOptions) => {
        var _a;
        return assertResponse(await this.pageBlobContext.copyIncremental(copySource2, {
          abortSignal: options3.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options3.conditions), { ifTags: (_a = options3.conditions) === null || _a === undefined ? undefined : _a.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  var HTTP_HEADER_DELIMITER = ": ";
  var SPACE_DELIMITER = " ";
  var NOT_FOUND = -1;

  class BatchResponseParser {
    constructor(batchResponse, subRequests) {
      if (!batchResponse || !batchResponse.contentType) {
        throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
      }
      if (!subRequests || subRequests.size === 0) {
        throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
      }
      this.batchResponse = batchResponse;
      this.subRequests = subRequests;
      this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
      this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;
      this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    async parseBatchResponse() {
      if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {
        throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
      }
      const responseBodyAsText = await getBodyAsText(this.batchResponse);
      const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
      const subResponseCount = subResponses.length;
      if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
        throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
      }
      const deserializedSubResponses = new Array(subResponseCount);
      let subResponsesSucceededCount = 0;
      let subResponsesFailedCount = 0;
      for (let index = 0;index < subResponseCount; index++) {
        const subResponse = subResponses[index];
        const deserializedSubResponse = {};
        deserializedSubResponse.headers = coreHttpCompat.toHttpHeadersLike(coreRestPipeline.createHttpHeaders());
        const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);
        let subRespHeaderStartFound = false;
        let subRespHeaderEndFound = false;
        let subRespFailed = false;
        let contentId = NOT_FOUND;
        for (const responseLine of responseLines) {
          if (!subRespHeaderStartFound) {
            if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {
              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
            }
            if (responseLine.startsWith(HTTP_VERSION_1_1)) {
              subRespHeaderStartFound = true;
              const tokens = responseLine.split(SPACE_DELIMITER);
              deserializedSubResponse.status = parseInt(tokens[1]);
              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
            }
            continue;
          }
          if (responseLine.trim() === "") {
            if (!subRespHeaderEndFound) {
              subRespHeaderEndFound = true;
            }
            continue;
          }
          if (!subRespHeaderEndFound) {
            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
            }
            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
            deserializedSubResponse.headers.set(tokens[0], tokens[1]);
            if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {
              deserializedSubResponse.errorCode = tokens[1];
              subRespFailed = true;
            }
          } else {
            if (!deserializedSubResponse.bodyAsText) {
              deserializedSubResponse.bodyAsText = "";
            }
            deserializedSubResponse.bodyAsText += responseLine;
          }
        }
        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {
          deserializedSubResponse._request = this.subRequests.get(contentId);
          deserializedSubResponses[contentId] = deserializedSubResponse;
        } else {
          logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
        }
        if (subRespFailed) {
          subResponsesFailedCount++;
        } else {
          subResponsesSucceededCount++;
        }
      }
      return {
        subResponses: deserializedSubResponses,
        subResponsesSucceededCount,
        subResponsesFailedCount
      };
    }
  }
  var MutexLockStatus;
  (function(MutexLockStatus2) {
    MutexLockStatus2[MutexLockStatus2["LOCKED"] = 0] = "LOCKED";
    MutexLockStatus2[MutexLockStatus2["UNLOCKED"] = 1] = "UNLOCKED";
  })(MutexLockStatus || (MutexLockStatus = {}));

  class Mutex {
    static async lock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {
          this.keys[key] = MutexLockStatus.LOCKED;
          resolve();
        } else {
          this.onUnlockEvent(key, () => {
            this.keys[key] = MutexLockStatus.LOCKED;
            resolve();
          });
        }
      });
    }
    static async unlock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === MutexLockStatus.LOCKED) {
          this.emitUnlockEvent(key);
        }
        delete this.keys[key];
        resolve();
      });
    }
    static onUnlockEvent(key, handler) {
      if (this.listeners[key] === undefined) {
        this.listeners[key] = [handler];
      } else {
        this.listeners[key].push(handler);
      }
    }
    static emitUnlockEvent(key) {
      if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {
        const handler = this.listeners[key].shift();
        setImmediate(() => {
          handler.call(this);
        });
      }
    }
  }
  Mutex.keys = {};
  Mutex.listeners = {};

  class BlobBatch {
    constructor() {
      this.batch = "batch";
      this.batchRequest = new InnerBatchRequest;
    }
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
      await Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(subRequest);
        await assembleSubRequestFunc();
        this.batchRequest.postAddSubRequest(subRequest);
      } finally {
        await Mutex.unlock(this.batch);
      }
    }
    setBatchType(batchType) {
      if (!this.batchType) {
        this.batchType = batchType;
      }
      if (this.batchType !== batchType) {
        throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
      }
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options3) {
      let url2;
      let credential;
      if (typeof urlOrBlobClient === "string" && (coreUtil.isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrOptions))) {
        url2 = urlOrBlobClient;
        credential = credentialOrOptions;
      } else if (urlOrBlobClient instanceof BlobClient) {
        url2 = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        options3 = credentialOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options3) {
        options3 = {};
      }
      return tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options3, async (updatedOptions) => {
        this.setBatchType("delete");
        await this.addSubRequestInternal({
          url: url2,
          credential
        }, async () => {
          await new BlobClient(url2, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
        });
      });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options3) {
      let url2;
      let credential;
      let tier2;
      if (typeof urlOrBlobClient === "string" && (coreUtil.isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrTier))) {
        url2 = urlOrBlobClient;
        credential = credentialOrTier;
        tier2 = tierOrOptions;
      } else if (urlOrBlobClient instanceof BlobClient) {
        url2 = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        tier2 = credentialOrTier;
        options3 = tierOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options3) {
        options3 = {};
      }
      return tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options3, async (updatedOptions) => {
        this.setBatchType("setAccessTier");
        await this.addSubRequestInternal({
          url: url2,
          credential
        }, async () => {
          await new BlobClient(url2, this.batchRequest.createPipeline(credential)).setAccessTier(tier2, updatedOptions);
        });
      });
    }
  }

  class InnerBatchRequest {
    constructor() {
      this.operationCount = 0;
      this.body = "";
      const tempGuid = coreUtil.randomUUID();
      this.boundary = `batch_${tempGuid}`;
      this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
      this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
      this.batchRequestEnding = `--${this.boundary}--`;
      this.subRequests = new Map;
    }
    createPipeline(credential) {
      const corePipeline = coreRestPipeline.createEmptyPipeline();
      corePipeline.addPolicy(coreClient.serializationPolicy({
        stringifyXML: coreXml.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }), { phase: "Serialize" });
      corePipeline.addPolicy(batchHeaderFilterPolicy());
      corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
      if (coreAuth.isTokenCredential(credential)) {
        corePipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential,
          scopes: StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: coreClient.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential) {
        corePipeline.addPolicy(storageSharedKeyCredentialPolicy({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      const pipeline4 = new Pipeline([]);
      pipeline4._credential = credential;
      pipeline4._corePipeline = corePipeline;
      return pipeline4;
    }
    appendSubRequestToBody(request) {
      this.body += [
        this.subRequestPrefix,
        `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        "",
        `${request.method.toString()} ${getURLPathAndQuery(request.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`
      ].join(HTTP_LINE_ENDING);
      for (const [name, value] of request.headers) {
        this.body += `${name}: ${value}${HTTP_LINE_ENDING}`;
      }
      this.body += HTTP_LINE_ENDING;
    }
    preAddSubRequest(subRequest) {
      if (this.operationCount >= BATCH_MAX_REQUEST) {
        throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);
      }
      const path5 = getURLPath(subRequest.url);
      if (!path5 || path5 === "") {
        throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
      }
    }
    postAddSubRequest(subRequest) {
      this.subRequests.set(this.operationCount, subRequest);
      this.operationCount++;
    }
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }

  class BlobBatchClient {
    constructor(url2, credentialOrPipeline, options3) {
      let pipeline4;
      if (isPipelineLike(credentialOrPipeline)) {
        pipeline4 = credentialOrPipeline;
      } else if (!credentialOrPipeline) {
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      } else {
        pipeline4 = newPipeline(credentialOrPipeline, options3);
      }
      const storageClientContext = new StorageContextClient(url2, getCoreClientOptions(pipeline4));
      const path5 = getURLPath(url2);
      if (path5 && path5 !== "/") {
        this.serviceOrContainerContext = storageClientContext.container;
      } else {
        this.serviceOrContainerContext = storageClientContext.service;
      }
    }
    createBatch() {
      return new BlobBatch;
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options3) {
      const batch = new BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options3);
        } else {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options3) {
      const batch = new BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options3);
        } else {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async submitBatch(batchRequest, options3 = {}) {
      if (!batchRequest || batchRequest.getSubRequests().size === 0) {
        throw new RangeError("Batch request should contain one or more sub requests.");
      }
      return tracingClient.withSpan("BlobBatchClient-submitBatch", options3, async (updatedOptions) => {
        const batchRequestBody = batchRequest.getHttpRequestBody();
        const rawBatchResponse = assertResponse(await this.serviceOrContainerContext.submitBatch(utf8ByteLength(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, Object.assign({}, updatedOptions)));
        const batchResponseParser = new BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
        const responseSummary = await batchResponseParser.parseBatchResponse();
        const res = {
          _response: rawBatchResponse._response,
          contentType: rawBatchResponse.contentType,
          errorCode: rawBatchResponse.errorCode,
          requestId: rawBatchResponse.requestId,
          clientRequestId: rawBatchResponse.clientRequestId,
          version: rawBatchResponse.version,
          subResponses: responseSummary.subResponses,
          subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
          subResponsesFailedCount: responseSummary.subResponsesFailedCount
        };
        return res;
      });
    }
  }

  class ContainerClient extends StorageClient {
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options3) {
      let pipeline4;
      let url2;
      options3 = options3 || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline4 = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline4 = newPipeline(credentialOrPipelineOrContainerName, options3);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));
            if (!options3.proxyOptions) {
              options3.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline4 = newPipeline(sharedKeyCredential, options3);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
          pipeline4 = newPipeline(new AnonymousCredential, options3);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName parameter");
      }
      super(url2, pipeline4);
      this._containerName = this.getContainerNameFromUrl();
      this.containerContext = this.storageClientContext.container;
    }
    async create(options3 = {}) {
      return tracingClient.withSpan("ContainerClient-create", options3, async (updatedOptions) => {
        return assertResponse(await this.containerContext.create(updatedOptions));
      });
    }
    async createIfNotExists(options3 = {}) {
      return tracingClient.withSpan("ContainerClient-createIfNotExists", options3, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = await this.create(updatedOptions);
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "ContainerAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          } else {
            throw e;
          }
        }
      });
    }
    async exists(options3 = {}) {
      return tracingClient.withSpan("ContainerClient-exists", options3, async (updatedOptions) => {
        try {
          await this.getProperties({
            abortSignal: options3.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e) {
          if (e.statusCode === 404) {
            return false;
          }
          throw e;
        }
      });
    }
    getBlobClient(blobName) {
      return new BlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getAppendBlobClient(blobName) {
      return new AppendBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getBlockBlobClient(blobName) {
      return new BlockBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getPageBlobClient(blobName) {
      return new PageBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    async getProperties(options3 = {}) {
      if (!options3.conditions) {
        options3.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-getProperties", options3, async (updatedOptions) => {
        return assertResponse(await this.containerContext.getProperties(Object.assign(Object.assign({ abortSignal: options3.abortSignal }, options3.conditions), { tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async delete(options3 = {}) {
      if (!options3.conditions) {
        options3.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-delete", options3, async (updatedOptions) => {
        return assertResponse(await this.containerContext.delete({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: options3.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options3 = {}) {
      return tracingClient.withSpan("ContainerClient-deleteIfExists", options3, async (updatedOptions) => {
        var _a, _b;
        try {
          const res = await this.delete(updatedOptions);
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e) {
          if (((_a = e.details) === null || _a === undefined ? undefined : _a.errorCode) === "ContainerNotFound") {
            return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === undefined ? undefined : _b.parsedHeaders), { _response: e.response });
          }
          throw e;
        }
      });
    }
    async setMetadata(metadata2, options3 = {}) {
      if (!options3.conditions) {
        options3.conditions = {};
      }
      if (options3.conditions.ifUnmodifiedSince) {
        throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
      }
      return tracingClient.withSpan("ContainerClient-setMetadata", options3, async (updatedOptions) => {
        return assertResponse(await this.containerContext.setMetadata({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          metadata: metadata2,
          modifiedAccessConditions: options3.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccessPolicy(options3 = {}) {
      if (!options3.conditions) {
        options3.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-getAccessPolicy", options3, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.getAccessPolicy({
          abortSignal: options3.abortSignal,
          leaseAccessConditions: options3.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const res = {
          _response: response._response,
          blobPublicAccess: response.blobPublicAccess,
          date: response.date,
          etag: response.etag,
          errorCode: response.errorCode,
          lastModified: response.lastModified,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          signedIdentifiers: [],
          version: response.version
        };
        for (const identifier of response) {
          let accessPolicy = undefined;
          if (identifier.accessPolicy) {
            accessPolicy = {
              permissions: identifier.accessPolicy.permissions
            };
            if (identifier.accessPolicy.expiresOn) {
              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
            }
            if (identifier.accessPolicy.startsOn) {
              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
            }
          }
          res.signedIdentifiers.push({
            accessPolicy,
            id: identifier.id
          });
        }
        return res;
      });
    }
    async setAccessPolicy(access2, containerAcl2, options3 = {}) {
      options3.conditions = options3.conditions || {};
      return tracingClient.withSpan("ContainerClient-setAccessPolicy", options3, async (updatedOptions) => {
        const acl = [];
        for (const identifier of containerAcl2 || []) {
          acl.push({
            accessPolicy: {
              expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : "",
              permissions: identifier.accessPolicy.permissions,
              startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : ""
            },
            id: identifier.id
          });
        }
        return assertResponse(await this.containerContext.setAccessPolicy({
          abortSignal: options3.abortSignal,
          access: access2,
          containerAcl: acl,
          leaseAccessConditions: options3.conditions,
          modifiedAccessConditions: options3.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient(this, proposeLeaseId);
    }
    async uploadBlockBlob(blobName, body2, contentLength2, options3 = {}) {
      return tracingClient.withSpan("ContainerClient-uploadBlockBlob", options3, async (updatedOptions) => {
        const blockBlobClient = this.getBlockBlobClient(blobName);
        const response = await blockBlobClient.upload(body2, contentLength2, updatedOptions);
        return {
          blockBlobClient,
          response
        };
      });
    }
    async deleteBlob(blobName, options3 = {}) {
      return tracingClient.withSpan("ContainerClient-deleteBlob", options3, async (updatedOptions) => {
        let blobClient = this.getBlobClient(blobName);
        if (options3.versionId) {
          blobClient = blobClient.withVersion(options3.versionId);
        }
        return blobClient.delete(updatedOptions);
      });
    }
    async listBlobFlatSegment(marker2, options3 = {}) {
      return tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options3, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({ marker: marker2 }, options3), { tracingOptions: updatedOptions.tracingOptions })));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: Object.assign(Object.assign({}, response._response), { parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody) }), segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInternal) => {
          const blobItem = Object.assign(Object.assign({}, blobItemInternal), { name: BlobNameToString(blobItemInternal.name), tags: toTags(blobItemInternal.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInternal.objectReplicationMetadata) });
          return blobItem;
        }) }) });
        return wrappedResponse;
      });
    }
    async listBlobHierarchySegment(delimiter2, marker2, options3 = {}) {
      return tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options3, async (updatedOptions) => {
        var _a;
        const response = assertResponse(await this.containerContext.listBlobHierarchySegment(delimiter2, Object.assign(Object.assign({ marker: marker2 }, options3), { tracingOptions: updatedOptions.tracingOptions })));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: Object.assign(Object.assign({}, response._response), { parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody) }), segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInternal) => {
          const blobItem = Object.assign(Object.assign({}, blobItemInternal), { name: BlobNameToString(blobItemInternal.name), tags: toTags(blobItemInternal.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInternal.objectReplicationMetadata) });
          return blobItem;
        }), blobPrefixes: (_a = response.segment.blobPrefixes) === null || _a === undefined ? undefined : _a.map((blobPrefixInternal) => {
          const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), { name: BlobNameToString(blobPrefixInternal.name) });
          return blobPrefix;
        }) }) });
        return wrappedResponse;
      });
    }
    listSegments(marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* listSegments_1(marker2, options3 = {}) {
        let listBlobsFlatSegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listBlobsFlatSegmentResponse = yield tslib.__await(this.listBlobFlatSegment(marker2, options3));
            marker2 = listBlobsFlatSegmentResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(listBlobsFlatSegmentResponse));
          } while (marker2);
        }
      });
    }
    listItems() {
      return tslib.__asyncGenerator(this, arguments, function* listItems_1(options3 = {}) {
        var _a, e_1, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listSegments(marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const listBlobsFlatSegmentResponse = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    listBlobsFlat(options3 = {}) {
      const include2 = [];
      if (options3.includeCopy) {
        include2.push("copy");
      }
      if (options3.includeDeleted) {
        include2.push("deleted");
      }
      if (options3.includeMetadata) {
        include2.push("metadata");
      }
      if (options3.includeSnapshots) {
        include2.push("snapshots");
      }
      if (options3.includeVersions) {
        include2.push("versions");
      }
      if (options3.includeUncommitedBlobs) {
        include2.push("uncommittedblobs");
      }
      if (options3.includeTags) {
        include2.push("tags");
      }
      if (options3.includeDeletedWithVersions) {
        include2.push("deletedwithversions");
      }
      if (options3.includeImmutabilityPolicy) {
        include2.push("immutabilitypolicy");
      }
      if (options3.includeLegalHold) {
        include2.push("legalhold");
      }
      if (options3.prefix === "") {
        options3.prefix = undefined;
      }
      const updatedOptions = Object.assign(Object.assign({}, options3), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItems(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
        }
      };
    }
    listHierarchySegments(delimiter_1, marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* listHierarchySegments_1(delimiter2, marker2, options3 = {}) {
        let listBlobsHierarchySegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listBlobsHierarchySegmentResponse = yield tslib.__await(this.listBlobHierarchySegment(delimiter2, marker2, options3));
            marker2 = listBlobsHierarchySegmentResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(listBlobsHierarchySegmentResponse));
          } while (marker2);
        }
      });
    }
    listItemsByHierarchy(delimiter_1) {
      return tslib.__asyncGenerator(this, arguments, function* listItemsByHierarchy_1(delimiter2, options3 = {}) {
        var _a, e_2, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listHierarchySegments(delimiter2, marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const listBlobsHierarchySegmentResponse = _c;
            const segment = listBlobsHierarchySegmentResponse.segment;
            if (segment.blobPrefixes) {
              for (const prefix2 of segment.blobPrefixes) {
                yield yield tslib.__await(Object.assign({ kind: "prefix" }, prefix2));
              }
            }
            for (const blob of segment.blobItems) {
              yield yield tslib.__await(Object.assign({ kind: "blob" }, blob));
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listBlobsByHierarchy(delimiter2, options3 = {}) {
      if (delimiter2 === "") {
        throw new RangeError("delimiter should contain one or more characters");
      }
      const include2 = [];
      if (options3.includeCopy) {
        include2.push("copy");
      }
      if (options3.includeDeleted) {
        include2.push("deleted");
      }
      if (options3.includeMetadata) {
        include2.push("metadata");
      }
      if (options3.includeSnapshots) {
        include2.push("snapshots");
      }
      if (options3.includeVersions) {
        include2.push("versions");
      }
      if (options3.includeUncommitedBlobs) {
        include2.push("uncommittedblobs");
      }
      if (options3.includeTags) {
        include2.push("tags");
      }
      if (options3.includeDeletedWithVersions) {
        include2.push("deletedwithversions");
      }
      if (options3.includeImmutabilityPolicy) {
        include2.push("immutabilitypolicy");
      }
      if (options3.includeLegalHold) {
        include2.push("legalhold");
      }
      if (options3.prefix === "") {
        options3.prefix = undefined;
      }
      const updatedOptions = Object.assign(Object.assign({}, options3), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItemsByHierarchy(delimiter2, updatedOptions);
      return {
        async next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listHierarchySegments(delimiter2, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
        }
      };
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options3 = {}) {
      return tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options3, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.filterBlobs({
          abortSignal: options3.abortSignal,
          where: tagFilterSqlExpression,
          marker: marker2,
          maxPageSize: options3.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {
          var _a;
          let tagValue = "";
          if (((_a = blob.tags) === null || _a === undefined ? undefined : _a.blobTagSet.length) === 1) {
            tagValue = blob.tags.blobTagSet[0].value;
          }
          return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });
        }) });
        return wrappedResponse;
      });
    }
    findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker2, options3 = {}) {
        let response;
        if (!!marker2 || marker2 === undefined) {
          do {
            response = yield tslib.__await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options3));
            response.blobs = response.blobs || [];
            marker2 = response.continuationToken;
            yield yield tslib.__await(response);
          } while (marker2);
        }
      });
    }
    findBlobsByTagsItems(tagFilterSqlExpression_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options3 = {}) {
        var _a, e_3, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const segment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.blobs)));
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      });
    }
    findBlobsByTags(tagFilterSqlExpression, options3 = {}) {
      const listSegmentOptions = Object.assign({}, options3);
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    async getAccountInfo(options3 = {}) {
      return tracingClient.withSpan("ContainerClient-getAccountInfo", options3, async (updatedOptions) => {
        return assertResponse(await this.containerContext.getAccountInfo({
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getContainerNameFromUrl() {
      let containerName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          containerName = parsedUrl.pathname.split("/")[1];
        } else if (isIpEndpointStyle(parsedUrl)) {
          containerName = parsedUrl.pathname.split("/")[2];
        } else {
          containerName = parsedUrl.pathname.split("/")[1];
        }
        containerName = decodeURIComponent(containerName);
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return containerName;
      } catch (error2) {
        throw new Error("Unable to extract containerName with provided information.");
      }
    }
    generateSasUrl(options3) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName }, options3), this.credential).toString();
        resolve(appendToURLQuery(this.url, sas));
      });
    }
    getBlobBatchClient() {
      return new BlobBatchClient(this.url, this.pipeline);
    }
  }

  class AccountSASPermissions {
    constructor() {
      this.read = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.list = false;
      this.add = false;
      this.create = false;
      this.update = false;
      this.process = false;
      this.tag = false;
      this.filter = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
    }
    static parse(permissions) {
      const accountSASPermissions = new AccountSASPermissions;
      for (const c3 of permissions) {
        switch (c3) {
          case "r":
            accountSASPermissions.read = true;
            break;
          case "w":
            accountSASPermissions.write = true;
            break;
          case "d":
            accountSASPermissions.delete = true;
            break;
          case "x":
            accountSASPermissions.deleteVersion = true;
            break;
          case "l":
            accountSASPermissions.list = true;
            break;
          case "a":
            accountSASPermissions.add = true;
            break;
          case "c":
            accountSASPermissions.create = true;
            break;
          case "u":
            accountSASPermissions.update = true;
            break;
          case "p":
            accountSASPermissions.process = true;
            break;
          case "t":
            accountSASPermissions.tag = true;
            break;
          case "f":
            accountSASPermissions.filter = true;
            break;
          case "i":
            accountSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            accountSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission character: ${c3}`);
        }
      }
      return accountSASPermissions;
    }
    static from(permissionLike) {
      const accountSASPermissions = new AccountSASPermissions;
      if (permissionLike.read) {
        accountSASPermissions.read = true;
      }
      if (permissionLike.write) {
        accountSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        accountSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        accountSASPermissions.deleteVersion = true;
      }
      if (permissionLike.filter) {
        accountSASPermissions.filter = true;
      }
      if (permissionLike.tag) {
        accountSASPermissions.tag = true;
      }
      if (permissionLike.list) {
        accountSASPermissions.list = true;
      }
      if (permissionLike.add) {
        accountSASPermissions.add = true;
      }
      if (permissionLike.create) {
        accountSASPermissions.create = true;
      }
      if (permissionLike.update) {
        accountSASPermissions.update = true;
      }
      if (permissionLike.process) {
        accountSASPermissions.process = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        accountSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        accountSASPermissions.permanentDelete = true;
      }
      return accountSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.filter) {
        permissions.push("f");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.update) {
        permissions.push("u");
      }
      if (this.process) {
        permissions.push("p");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }

  class AccountSASResourceTypes {
    constructor() {
      this.service = false;
      this.container = false;
      this.object = false;
    }
    static parse(resourceTypes) {
      const accountSASResourceTypes = new AccountSASResourceTypes;
      for (const c3 of resourceTypes) {
        switch (c3) {
          case "s":
            accountSASResourceTypes.service = true;
            break;
          case "c":
            accountSASResourceTypes.container = true;
            break;
          case "o":
            accountSASResourceTypes.object = true;
            break;
          default:
            throw new RangeError(`Invalid resource type: ${c3}`);
        }
      }
      return accountSASResourceTypes;
    }
    toString() {
      const resourceTypes = [];
      if (this.service) {
        resourceTypes.push("s");
      }
      if (this.container) {
        resourceTypes.push("c");
      }
      if (this.object) {
        resourceTypes.push("o");
      }
      return resourceTypes.join("");
    }
  }

  class AccountSASServices {
    constructor() {
      this.blob = false;
      this.file = false;
      this.queue = false;
      this.table = false;
    }
    static parse(services) {
      const accountSASServices = new AccountSASServices;
      for (const c3 of services) {
        switch (c3) {
          case "b":
            accountSASServices.blob = true;
            break;
          case "f":
            accountSASServices.file = true;
            break;
          case "q":
            accountSASServices.queue = true;
            break;
          case "t":
            accountSASServices.table = true;
            break;
          default:
            throw new RangeError(`Invalid service character: ${c3}`);
        }
      }
      return accountSASServices;
    }
    toString() {
      const services = [];
      if (this.blob) {
        services.push("b");
      }
      if (this.table) {
        services.push("t");
      }
      if (this.queue) {
        services.push("q");
      }
      if (this.file) {
        services.push("f");
      }
      return services.join("");
    }
  }

  class BlobServiceClient extends StorageClient {
    static fromConnectionString(connectionString, options3) {
      options3 = options3 || {};
      const extractedCreds = extractConnectionStringParts(connectionString);
      if (extractedCreds.kind === "AccountConnString") {
        if (coreUtil.isNode) {
          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          if (!options3.proxyOptions) {
            options3.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
          }
          const pipeline4 = newPipeline(sharedKeyCredential, options3);
          return new BlobServiceClient(extractedCreds.url, pipeline4);
        } else {
          throw new Error("Account connection string is only supported in Node.js environment");
        }
      } else if (extractedCreds.kind === "SASConnString") {
        const pipeline4 = newPipeline(new AnonymousCredential, options3);
        return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline4);
      } else {
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
      }
    }
    constructor(url2, credentialOrPipeline, options3) {
      let pipeline4;
      if (isPipelineLike(credentialOrPipeline)) {
        pipeline4 = credentialOrPipeline;
      } else if (coreUtil.isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipeline)) {
        pipeline4 = newPipeline(credentialOrPipeline, options3);
      } else {
        pipeline4 = newPipeline(new AnonymousCredential, options3);
      }
      super(url2, pipeline4);
      this.serviceContext = this.storageClientContext.service;
    }
    getContainerClient(containerName) {
      return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    async createContainer(containerName, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-createContainer", options3, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        const containerCreateResponse = await containerClient.create(updatedOptions);
        return {
          containerClient,
          containerCreateResponse
        };
      });
    }
    async deleteContainer(containerName, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-deleteContainer", options3, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        return containerClient.delete(updatedOptions);
      });
    }
    async undeleteContainer(deletedContainerName2, deletedContainerVersion2, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-undeleteContainer", options3, async (updatedOptions) => {
        const containerClient = this.getContainerClient(options3.destinationContainerName || deletedContainerName2);
        const containerContext = containerClient["storageClientContext"].container;
        const containerUndeleteResponse = assertResponse(await containerContext.restore({
          deletedContainerName: deletedContainerName2,
          deletedContainerVersion: deletedContainerVersion2,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return { containerClient, containerUndeleteResponse };
      });
    }
    async renameContainer(sourceContainerName2, destinationContainerName, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-renameContainer", options3, async (updatedOptions) => {
        var _a;
        const containerClient = this.getContainerClient(destinationContainerName);
        const containerContext = containerClient["storageClientContext"].container;
        const containerRenameResponse = assertResponse(await containerContext.rename(sourceContainerName2, Object.assign(Object.assign({}, updatedOptions), { sourceLeaseId: (_a = options3.sourceCondition) === null || _a === undefined ? undefined : _a.leaseId })));
        return { containerClient, containerRenameResponse };
      });
    }
    async getProperties(options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-getProperties", options3, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getProperties({
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setProperties(properties, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-setProperties", options3, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.setProperties(properties, {
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getStatistics(options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-getStatistics", options3, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getStatistics({
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-getAccountInfo", options3, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getAccountInfo({
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async listContainersSegment(marker2, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-listContainersSegment", options3, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.listContainersSegment(Object.assign(Object.assign({ abortSignal: options3.abortSignal, marker: marker2 }, options3), { include: typeof options3.include === "string" ? [options3.include] : options3.include, tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options3, async (updatedOptions) => {
        const response = assertResponse(await this.serviceContext.filterBlobs({
          abortSignal: options3.abortSignal,
          where: tagFilterSqlExpression,
          marker: marker2,
          maxPageSize: options3.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {
          var _a;
          let tagValue = "";
          if (((_a = blob.tags) === null || _a === undefined ? undefined : _a.blobTagSet.length) === 1) {
            tagValue = blob.tags.blobTagSet[0].value;
          }
          return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });
        }) });
        return wrappedResponse;
      });
    }
    findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker2, options3 = {}) {
        let response;
        if (!!marker2 || marker2 === undefined) {
          do {
            response = yield tslib.__await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options3));
            response.blobs = response.blobs || [];
            marker2 = response.continuationToken;
            yield yield tslib.__await(response);
          } while (marker2);
        }
      });
    }
    findBlobsByTagsItems(tagFilterSqlExpression_1) {
      return tslib.__asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options3 = {}) {
        var _a, e_1, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const segment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.blobs)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    findBlobsByTags(tagFilterSqlExpression, options3 = {}) {
      const listSegmentOptions = Object.assign({}, options3);
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    listSegments(marker_1) {
      return tslib.__asyncGenerator(this, arguments, function* listSegments_1(marker2, options3 = {}) {
        let listContainersSegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listContainersSegmentResponse = yield tslib.__await(this.listContainersSegment(marker2, options3));
            listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
            marker2 = listContainersSegmentResponse.continuationToken;
            yield yield tslib.__await(yield tslib.__await(listContainersSegmentResponse));
          } while (marker2);
        }
      });
    }
    listItems() {
      return tslib.__asyncGenerator(this, arguments, function* listItems_1(options3 = {}) {
        var _a, e_2, _b, _c;
        let marker2;
        try {
          for (var _d = true, _e = tslib.__asyncValues(this.listSegments(marker2, options3)), _f;_f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const segment = _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.containerItems)));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield tslib.__await(_b.call(_e));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listContainers(options3 = {}) {
      if (options3.prefix === "") {
        options3.prefix = undefined;
      }
      const include2 = [];
      if (options3.includeDeleted) {
        include2.push("deleted");
      }
      if (options3.includeMetadata) {
        include2.push("metadata");
      }
      if (options3.includeSystem) {
        include2.push("system");
      }
      const listSegmentOptions = Object.assign(Object.assign({}, options3), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItems(listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    async getUserDelegationKey(startsOn, expiresOn2, options3 = {}) {
      return tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options3, async (updatedOptions) => {
        const response = assertResponse(await this.serviceContext.getUserDelegationKey({
          startsOn: truncatedISO8061Date(startsOn, false),
          expiresOn: truncatedISO8061Date(expiresOn2, false)
        }, {
          abortSignal: options3.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const userDelegationKey = {
          signedObjectId: response.signedObjectId,
          signedTenantId: response.signedTenantId,
          signedStartsOn: new Date(response.signedStartsOn),
          signedExpiresOn: new Date(response.signedExpiresOn),
          signedService: response.signedService,
          signedVersion: response.signedVersion,
          value: response.value
        };
        const res = Object.assign({ _response: response._response, requestId: response.requestId, clientRequestId: response.clientRequestId, version: response.version, date: response.date, errorCode: response.errorCode }, userDelegationKey);
        return res;
      });
    }
    getBlobBatchClient() {
      return new BlobBatchClient(this.url, this.pipeline);
    }
    generateAccountSasUrl(expiresOn2, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options3 = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn2 === undefined) {
        const now = new Date;
        expiresOn2 = new Date(now.getTime() + 3600 * 1000);
      }
      const sas = generateAccountSASQueryParameters(Object.assign({
        permissions,
        expiresOn: expiresOn2,
        resourceTypes,
        services: AccountSASServices.parse("b").toString()
      }, options3), this.credential).toString();
      return appendToURLQuery(this.url, sas);
    }
  }
  exports.KnownEncryptionAlgorithmType = undefined;
  (function(KnownEncryptionAlgorithmType) {
    KnownEncryptionAlgorithmType["AES256"] = "AES256";
  })(exports.KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = {}));
  Object.defineProperty(exports, "RestError", {
    enumerable: true,
    get: function() {
      return coreRestPipeline.RestError;
    }
  });
  exports.AccountSASPermissions = AccountSASPermissions;
  exports.AccountSASResourceTypes = AccountSASResourceTypes;
  exports.AccountSASServices = AccountSASServices;
  exports.AnonymousCredential = AnonymousCredential;
  exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
  exports.AppendBlobClient = AppendBlobClient;
  exports.BaseRequestPolicy = BaseRequestPolicy;
  exports.BlobBatch = BlobBatch;
  exports.BlobBatchClient = BlobBatchClient;
  exports.BlobClient = BlobClient;
  exports.BlobLeaseClient = BlobLeaseClient;
  exports.BlobSASPermissions = BlobSASPermissions;
  exports.BlobServiceClient = BlobServiceClient;
  exports.BlockBlobClient = BlockBlobClient;
  exports.ContainerClient = ContainerClient;
  exports.ContainerSASPermissions = ContainerSASPermissions;
  exports.Credential = Credential;
  exports.CredentialPolicy = CredentialPolicy;
  exports.PageBlobClient = PageBlobClient;
  exports.Pipeline = Pipeline;
  exports.SASQueryParameters = SASQueryParameters;
  exports.StorageBrowserPolicy = StorageBrowserPolicy;
  exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
  exports.StorageOAuthScopes = StorageOAuthScopes;
  exports.StorageRetryPolicy = StorageRetryPolicy;
  exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
  exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
  exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
  exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
  exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
  exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
  exports.isPipelineLike = isPipelineLike;
  exports.logger = logger;
  exports.newPipeline = newPipeline;
});

// node_modules/@actions/cache/lib/internal/requestUtils.js
var require_requestUtils = __commonJS((exports) => {
  function isSuccessStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    return statusCode >= 200 && statusCode < 300;
  }
  function isServerErrorStatusCode(statusCode) {
    if (!statusCode) {
      return true;
    }
    return statusCode >= 500;
  }
  function isRetryableStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    const retryableStatusCodes = [
      http_client_1.HttpCodes.BadGateway,
      http_client_1.HttpCodes.ServiceUnavailable,
      http_client_1.HttpCodes.GatewayTimeout
    ];
    return retryableStatusCodes.includes(statusCode);
  }
  function sleep(milliseconds) {
    return __awaiter(this, undefined, undefined, function* () {
      return new Promise((resolve) => setTimeout(resolve, milliseconds));
    });
  }
  function retry(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay, onError = undefined) {
    return __awaiter(this, undefined, undefined, function* () {
      let errorMessage = "";
      let attempt = 1;
      while (attempt <= maxAttempts) {
        let response = undefined;
        let statusCode = undefined;
        let isRetryable = false;
        try {
          response = yield method();
        } catch (error2) {
          if (onError) {
            response = onError(error2);
          }
          isRetryable = true;
          errorMessage = error2.message;
        }
        if (response) {
          statusCode = getStatusCode(response);
          if (!isServerErrorStatusCode(statusCode)) {
            return response;
          }
        }
        if (statusCode) {
          isRetryable = isRetryableStatusCode(statusCode);
          errorMessage = `Cache service responded with ${statusCode}`;
        }
        core2.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
        if (!isRetryable) {
          core2.debug(`${name} - Error is not retryable`);
          break;
        }
        yield sleep(delay);
        attempt++;
      }
      throw Error(`${name} failed: ${errorMessage}`);
    });
  }
  function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield retry(name, method, (response) => response.statusCode, maxAttempts, delay, (error2) => {
        if (error2 instanceof http_client_1.HttpClientError) {
          return {
            statusCode: error2.statusCode,
            result: null,
            headers: {},
            error: error2
          };
        } else {
          return;
        }
      });
    });
  }
  function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay = constants_1.DefaultRetryDelay) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield retry(name, method, (response) => response.message.statusCode, maxAttempts, delay);
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryHttpClientResponse = exports.retryTypedResponse = exports.retry = exports.isRetryableStatusCode = exports.isServerErrorStatusCode = exports.isSuccessStatusCode = undefined;
  var core2 = __importStar(require_core());
  var http_client_1 = require_lib();
  var constants_1 = require_constants6();
  exports.isSuccessStatusCode = isSuccessStatusCode;
  exports.isServerErrorStatusCode = isServerErrorStatusCode;
  exports.isRetryableStatusCode = isRetryableStatusCode;
  exports.retry = retry;
  exports.retryTypedResponse = retryTypedResponse;
  exports.retryHttpClientResponse = retryHttpClientResponse;
});

// node_modules/@actions/cache/lib/internal/downloadUtils.js
var require_downloadUtils = __commonJS((exports) => {
  function pipeResponseToStream(response, output3) {
    return __awaiter(this, undefined, undefined, function* () {
      const pipeline4 = util.promisify(stream3.pipeline);
      yield pipeline4(response.message, output3);
    });
  }
  function downloadCacheHttpClient(archiveLocation, archivePath) {
    return __awaiter(this, undefined, undefined, function* () {
      const writeStream = fs.createWriteStream(archivePath);
      const httpClient = new http_client_1.HttpClient("actions/cache");
      const downloadResponse = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.get(archiveLocation);
      }));
      downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, () => {
        downloadResponse.message.destroy();
        core2.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
      });
      yield pipeResponseToStream(downloadResponse, writeStream);
      const contentLengthHeader = downloadResponse.message.headers["content-length"];
      if (contentLengthHeader) {
        const expectedLength = parseInt(contentLengthHeader);
        const actualLength = utils4.getArchiveFileSizeInBytes(archivePath);
        if (actualLength !== expectedLength) {
          throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
        }
      } else {
        core2.debug("Unable to validate download, no Content-Length header");
      }
    });
  }
  function downloadCacheHttpClientConcurrent(archiveLocation, archivePath, options3) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const archiveDescriptor = yield fs.promises.open(archivePath, "w");
      const httpClient = new http_client_1.HttpClient("actions/cache", undefined, {
        socketTimeout: options3.timeoutInMs,
        keepAlive: true
      });
      try {
        const res = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCacheMetadata", () => __awaiter(this, undefined, undefined, function* () {
          return yield httpClient.request("HEAD", archiveLocation, null, {});
        }));
        const lengthHeader = res.message.headers["content-length"];
        if (lengthHeader === undefined || lengthHeader === null) {
          throw new Error("Content-Length not found on blob response");
        }
        const length = parseInt(lengthHeader);
        if (Number.isNaN(length)) {
          throw new Error(`Could not interpret Content-Length: ${length}`);
        }
        const downloads = [];
        const blockSize = 4 * 1024 * 1024;
        for (let offset = 0;offset < length; offset += blockSize) {
          const count2 = Math.min(blockSize, length - offset);
          downloads.push({
            offset,
            promiseGetter: () => __awaiter(this, undefined, undefined, function* () {
              return yield downloadSegmentRetry(httpClient, archiveLocation, offset, count2);
            })
          });
        }
        downloads.reverse();
        let actives = 0;
        let bytesDownloaded = 0;
        const progress = new DownloadProgress(length);
        progress.startDisplayTimer();
        const progressFn = progress.onProgress();
        const activeDownloads = [];
        let nextDownload;
        const waitAndWrite = () => __awaiter(this, undefined, undefined, function* () {
          const segment = yield Promise.race(Object.values(activeDownloads));
          yield archiveDescriptor.write(segment.buffer, 0, segment.count, segment.offset);
          actives--;
          delete activeDownloads[segment.offset];
          bytesDownloaded += segment.count;
          progressFn({ loadedBytes: bytesDownloaded });
        });
        while (nextDownload = downloads.pop()) {
          activeDownloads[nextDownload.offset] = nextDownload.promiseGetter();
          actives++;
          if (actives >= ((_a = options3.downloadConcurrency) !== null && _a !== undefined ? _a : 10)) {
            yield waitAndWrite();
          }
        }
        while (actives > 0) {
          yield waitAndWrite();
        }
      } finally {
        httpClient.dispose();
        yield archiveDescriptor.close();
      }
    });
  }
  function downloadSegmentRetry(httpClient, archiveLocation, offset, count2) {
    return __awaiter(this, undefined, undefined, function* () {
      const retries = 5;
      let failures = 0;
      while (true) {
        try {
          const timeout3 = 30000;
          const result5 = yield promiseWithTimeout(timeout3, downloadSegment(httpClient, archiveLocation, offset, count2));
          if (typeof result5 === "string") {
            throw new Error("downloadSegmentRetry failed due to timeout");
          }
          return result5;
        } catch (err) {
          if (failures >= retries) {
            throw err;
          }
          failures++;
        }
      }
    });
  }
  function downloadSegment(httpClient, archiveLocation, offset, count2) {
    return __awaiter(this, undefined, undefined, function* () {
      const partRes = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCachePart", () => __awaiter(this, undefined, undefined, function* () {
        return yield httpClient.get(archiveLocation, {
          Range: `bytes=${offset}-${offset + count2 - 1}`
        });
      }));
      if (!partRes.readBodyBuffer) {
        throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
      }
      return {
        offset,
        count: count2,
        buffer: yield partRes.readBodyBuffer()
      };
    });
  }
  function downloadCacheStorageSDK(archiveLocation, archivePath, options3) {
    var _a;
    return __awaiter(this, undefined, undefined, function* () {
      const client = new storage_blob_1.BlockBlobClient(archiveLocation, undefined, {
        retryOptions: {
          tryTimeoutInMs: options3.timeoutInMs
        }
      });
      const properties = yield client.getProperties();
      const contentLength = (_a = properties.contentLength) !== null && _a !== undefined ? _a : -1;
      if (contentLength < 0) {
        core2.debug("Unable to determine content length, downloading file with http-client...");
        yield downloadCacheHttpClient(archiveLocation, archivePath);
      } else {
        const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH);
        const downloadProgress = new DownloadProgress(contentLength);
        const fd = fs.openSync(archivePath, "w");
        try {
          downloadProgress.startDisplayTimer();
          const controller = new abort_controller_1.AbortController;
          const abortSignal = controller.signal;
          while (!downloadProgress.isDone()) {
            const segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize;
            const segmentSize = Math.min(maxSegmentSize, contentLength - segmentStart);
            downloadProgress.nextSegment(segmentSize);
            const result5 = yield promiseWithTimeout(options3.segmentTimeoutInMs || 3600000, client.downloadToBuffer(segmentStart, segmentSize, {
              abortSignal,
              concurrency: options3.downloadConcurrency,
              onProgress: downloadProgress.onProgress()
            }));
            if (result5 === "timeout") {
              controller.abort();
              throw new Error("Aborting cache download as the download time exceeded the timeout.");
            } else if (Buffer.isBuffer(result5)) {
              fs.writeFileSync(fd, result5);
            }
          }
        } finally {
          downloadProgress.stopDisplayTimer();
          fs.closeSync(fd);
        }
      }
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.downloadCacheStorageSDK = exports.downloadCacheHttpClientConcurrent = exports.downloadCacheHttpClient = exports.DownloadProgress = undefined;
  var core2 = __importStar(require_core());
  var http_client_1 = require_lib();
  var storage_blob_1 = require_dist6();
  var buffer = __importStar(__require("buffer"));
  var fs = __importStar(__require("fs"));
  var stream3 = __importStar(__require("stream"));
  var util = __importStar(__require("util"));
  var utils4 = __importStar(require_cacheUtils());
  var constants_1 = require_constants6();
  var requestUtils_1 = require_requestUtils();
  var abort_controller_1 = require_dist5();

  class DownloadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.segmentIndex = 0;
      this.segmentSize = 0;
      this.segmentOffset = 0;
      this.receivedBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    nextSegment(segmentSize) {
      this.segmentOffset = this.segmentOffset + this.segmentSize;
      this.segmentIndex = this.segmentIndex + 1;
      this.segmentSize = segmentSize;
      this.receivedBytes = 0;
      core2.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
    }
    setReceivedBytes(receivedBytes) {
      this.receivedBytes = receivedBytes;
    }
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.segmentOffset + this.receivedBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const downloadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1000)).toFixed(1);
      core2.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    onProgress() {
      return (progress) => {
        this.setReceivedBytes(progress.loadedBytes);
      };
    }
    startDisplayTimer(delayInMs = 1000) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = undefined;
      }
      this.display();
    }
  }
  exports.DownloadProgress = DownloadProgress;
  exports.downloadCacheHttpClient = downloadCacheHttpClient;
  exports.downloadCacheHttpClientConcurrent = downloadCacheHttpClientConcurrent;
  exports.downloadCacheStorageSDK = downloadCacheStorageSDK;
  var promiseWithTimeout = (timeoutMs, promise2) => __awaiter(undefined, undefined, undefined, function* () {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve) => {
      timeoutHandle = setTimeout(() => resolve("timeout"), timeoutMs);
    });
    return Promise.race([promise2, timeoutPromise]).then((result5) => {
      clearTimeout(timeoutHandle);
      return result5;
    });
  });
});

// node_modules/@actions/cache/lib/options.js
var require_options = __commonJS((exports) => {
  function getUploadOptions(copy) {
    const result5 = {
      uploadConcurrency: 4,
      uploadChunkSize: 32 * 1024 * 1024
    };
    if (copy) {
      if (typeof copy.uploadConcurrency === "number") {
        result5.uploadConcurrency = copy.uploadConcurrency;
      }
      if (typeof copy.uploadChunkSize === "number") {
        result5.uploadChunkSize = copy.uploadChunkSize;
      }
    }
    core2.debug(`Upload concurrency: ${result5.uploadConcurrency}`);
    core2.debug(`Upload chunk size: ${result5.uploadChunkSize}`);
    return result5;
  }
  function getDownloadOptions(copy) {
    const result5 = {
      useAzureSdk: false,
      concurrentBlobDownloads: true,
      downloadConcurrency: 8,
      timeoutInMs: 30000,
      segmentTimeoutInMs: 600000,
      lookupOnly: false
    };
    if (copy) {
      if (typeof copy.useAzureSdk === "boolean") {
        result5.useAzureSdk = copy.useAzureSdk;
      }
      if (typeof copy.concurrentBlobDownloads === "boolean") {
        result5.concurrentBlobDownloads = copy.concurrentBlobDownloads;
      }
      if (typeof copy.downloadConcurrency === "number") {
        result5.downloadConcurrency = copy.downloadConcurrency;
      }
      if (typeof copy.timeoutInMs === "number") {
        result5.timeoutInMs = copy.timeoutInMs;
      }
      if (typeof copy.segmentTimeoutInMs === "number") {
        result5.segmentTimeoutInMs = copy.segmentTimeoutInMs;
      }
      if (typeof copy.lookupOnly === "boolean") {
        result5.lookupOnly = copy.lookupOnly;
      }
    }
    const segmentDownloadTimeoutMins = process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"];
    if (segmentDownloadTimeoutMins && !isNaN(Number(segmentDownloadTimeoutMins)) && isFinite(Number(segmentDownloadTimeoutMins))) {
      result5.segmentTimeoutInMs = Number(segmentDownloadTimeoutMins) * 60 * 1000;
    }
    core2.debug(`Use Azure SDK: ${result5.useAzureSdk}`);
    core2.debug(`Download concurrency: ${result5.downloadConcurrency}`);
    core2.debug(`Request timeout (ms): ${result5.timeoutInMs}`);
    core2.debug(`Cache segment download timeout mins env var: ${process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"]}`);
    core2.debug(`Segment download timeout (ms): ${result5.segmentTimeoutInMs}`);
    core2.debug(`Lookup only: ${result5.lookupOnly}`);
    return result5;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDownloadOptions = exports.getUploadOptions = undefined;
  var core2 = __importStar(require_core());
  exports.getUploadOptions = getUploadOptions;
  exports.getDownloadOptions = getDownloadOptions;
});

// node_modules/@actions/cache/lib/internal/cacheHttpClient.js
var require_cacheHttpClient = __commonJS((exports) => {
  function getCacheApiUrl(resource) {
    const baseUrl = process.env["ACTIONS_CACHE_URL"] || "";
    if (!baseUrl) {
      throw new Error("Cache Service Url not found, unable to restore cache.");
    }
    const url = `${baseUrl}_apis/artifactcache/${resource}`;
    core2.debug(`Resource Url: ${url}`);
    return url;
  }
  function createAcceptHeader(type15, apiVersion) {
    return `${type15};api-version=${apiVersion}`;
  }
  function getRequestOptions() {
    const requestOptions = {
      headers: {
        Accept: createAcceptHeader("application/json", "6.0-preview.1")
      }
    };
    return requestOptions;
  }
  function createHttpClient() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"] || "";
    const bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
    return new http_client_1.HttpClient("actions/cache", [bearerCredentialHandler], getRequestOptions());
  }
  function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
    const components = paths.slice();
    if (compressionMethod) {
      components.push(compressionMethod);
    }
    if (process.platform === "win32" && !enableCrossOsArchive) {
      components.push("windows-only");
    }
    components.push(versionSalt);
    return crypto.createHash("sha256").update(components.join("|")).digest("hex");
  }
  function getCacheEntry(keys, paths, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      const version = getCacheVersion(paths, options3 === null || options3 === undefined ? undefined : options3.compressionMethod, options3 === null || options3 === undefined ? undefined : options3.enableCrossOsArchive);
      const resource = `cache?keys=${encodeURIComponent(keys.join(","))}&version=${version}`;
      const response = yield (0, requestUtils_1.retryTypedResponse)("getCacheEntry", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 204) {
        if (core2.isDebug()) {
          yield printCachesListForDiagnostics(keys[0], httpClient, version);
        }
        return null;
      }
      if (!(0, requestUtils_1.isSuccessStatusCode)(response.statusCode)) {
        throw new Error(`Cache service responded with ${response.statusCode}`);
      }
      const cacheResult = response.result;
      const cacheDownloadUrl = cacheResult === null || cacheResult === undefined ? undefined : cacheResult.archiveLocation;
      if (!cacheDownloadUrl) {
        throw new Error("Cache not found.");
      }
      core2.setSecret(cacheDownloadUrl);
      core2.debug(`Cache Result:`);
      core2.debug(JSON.stringify(cacheResult));
      return cacheResult;
    });
  }
  function printCachesListForDiagnostics(key, httpClient, version) {
    return __awaiter(this, undefined, undefined, function* () {
      const resource = `caches?key=${encodeURIComponent(key)}`;
      const response = yield (0, requestUtils_1.retryTypedResponse)("listCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 200) {
        const cacheListResult = response.result;
        const totalCount = cacheListResult === null || cacheListResult === undefined ? undefined : cacheListResult.totalCount;
        if (totalCount && totalCount > 0) {
          core2.debug(`No matching cache found for cache key '${key}', version '${version} and scope ${process.env["GITHUB_REF"]}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key \nOther caches with similar key:`);
          for (const cacheEntry of (cacheListResult === null || cacheListResult === undefined ? undefined : cacheListResult.artifactCaches) || []) {
            core2.debug(`Cache Key: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.cacheKey}, Cache Version: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.cacheVersion}, Cache Scope: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.scope}, Cache Created: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.creationTime}`);
          }
        }
      }
    });
  }
  function downloadCache(archiveLocation, archivePath, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      const archiveUrl = new url_1.URL(archiveLocation);
      const downloadOptions = (0, options_1.getDownloadOptions)(options3);
      if (archiveUrl.hostname.endsWith(".blob.core.windows.net")) {
        if (downloadOptions.useAzureSdk) {
          yield (0, downloadUtils_1.downloadCacheStorageSDK)(archiveLocation, archivePath, downloadOptions);
        } else if (downloadOptions.concurrentBlobDownloads) {
          yield (0, downloadUtils_1.downloadCacheHttpClientConcurrent)(archiveLocation, archivePath, downloadOptions);
        } else {
          yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
        }
      } else {
        yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
      }
    });
  }
  function reserveCache(key, paths, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      const version = getCacheVersion(paths, options3 === null || options3 === undefined ? undefined : options3.compressionMethod, options3 === null || options3 === undefined ? undefined : options3.enableCrossOsArchive);
      const reserveCacheRequest = {
        key,
        version,
        cacheSize: options3 === null || options3 === undefined ? undefined : options3.cacheSize
      };
      const response = yield (0, requestUtils_1.retryTypedResponse)("reserveCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.postJson(getCacheApiUrl("caches"), reserveCacheRequest);
      }));
      return response;
    });
  }
  function getContentRange(start2, end) {
    return `bytes ${start2}-${end}/*`;
  }
  function uploadChunk(httpClient, resourceUrl, openStream, start2, end) {
    return __awaiter(this, undefined, undefined, function* () {
      core2.debug(`Uploading chunk of size ${end - start2 + 1} bytes at offset ${start2} with content range: ${getContentRange(start2, end)}`);
      const additionalHeaders = {
        "Content-Type": "application/octet-stream",
        "Content-Range": getContentRange(start2, end)
      };
      const uploadChunkResponse = yield (0, requestUtils_1.retryHttpClientResponse)(`uploadChunk (start: ${start2}, end: ${end})`, () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.sendStream("PATCH", resourceUrl, openStream(), additionalHeaders);
      }));
      if (!(0, requestUtils_1.isSuccessStatusCode)(uploadChunkResponse.message.statusCode)) {
        throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
      }
    });
  }
  function uploadFile(httpClient, cacheId, archivePath, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      const fileSize = utils4.getArchiveFileSizeInBytes(archivePath);
      const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`);
      const fd = fs.openSync(archivePath, "r");
      const uploadOptions = (0, options_1.getUploadOptions)(options3);
      const concurrency = utils4.assertDefined("uploadConcurrency", uploadOptions.uploadConcurrency);
      const maxChunkSize = utils4.assertDefined("uploadChunkSize", uploadOptions.uploadChunkSize);
      const parallelUploads = [...new Array(concurrency).keys()];
      core2.debug("Awaiting all uploads");
      let offset = 0;
      try {
        yield Promise.all(parallelUploads.map(() => __awaiter(this, undefined, undefined, function* () {
          while (offset < fileSize) {
            const chunkSize = Math.min(fileSize - offset, maxChunkSize);
            const start2 = offset;
            const end = offset + chunkSize - 1;
            offset += maxChunkSize;
            yield uploadChunk(httpClient, resourceUrl, () => fs.createReadStream(archivePath, {
              fd,
              start: start2,
              end,
              autoClose: false
            }).on("error", (error2) => {
              throw new Error(`Cache upload failed because file read failed with ${error2.message}`);
            }), start2, end);
          }
        })));
      } finally {
        fs.closeSync(fd);
      }
      return;
    });
  }
  function commitCache(httpClient, cacheId, filesize) {
    return __awaiter(this, undefined, undefined, function* () {
      const commitCacheRequest = { size: filesize };
      return yield (0, requestUtils_1.retryTypedResponse)("commitCache", () => __awaiter(this, undefined, undefined, function* () {
        return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
      }));
    });
  }
  function saveCache(cacheId, archivePath, options3) {
    return __awaiter(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      core2.debug("Upload cache");
      yield uploadFile(httpClient, cacheId, archivePath, options3);
      core2.debug("Commiting cache");
      const cacheSize = utils4.getArchiveFileSizeInBytes(archivePath);
      core2.info(`Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`);
      const commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
      if (!(0, requestUtils_1.isSuccessStatusCode)(commitCacheResponse.statusCode)) {
        throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
      }
      core2.info("Cache saved successfully");
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saveCache = exports.reserveCache = exports.downloadCache = exports.getCacheEntry = exports.getCacheVersion = undefined;
  var core2 = __importStar(require_core());
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var crypto = __importStar(__require("crypto"));
  var fs = __importStar(__require("fs"));
  var url_1 = __require("url");
  var utils4 = __importStar(require_cacheUtils());
  var downloadUtils_1 = require_downloadUtils();
  var options_1 = require_options();
  var requestUtils_1 = require_requestUtils();
  var versionSalt = "1.0";
  exports.getCacheVersion = getCacheVersion;
  exports.getCacheEntry = getCacheEntry;
  exports.downloadCache = downloadCache;
  exports.reserveCache = reserveCache;
  exports.saveCache = saveCache;
});

// node_modules/@actions/cache/lib/internal/tar.js
var require_tar = __commonJS((exports) => {
  function getTarPath() {
    return __awaiter(this, undefined, undefined, function* () {
      switch (process.platform) {
        case "win32": {
          const gnuTar = yield utils4.getGnuTarPathOnWindows();
          const systemTar = constants_1.SystemTarPathOnWindows;
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else if ((0, fs_1.existsSync)(systemTar)) {
            return { path: systemTar, type: constants_1.ArchiveToolType.BSD };
          }
          break;
        }
        case "darwin": {
          const gnuTar = yield io.which("gtar", false);
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else {
            return {
              path: yield io.which("tar", true),
              type: constants_1.ArchiveToolType.BSD
            };
          }
        }
        default:
          break;
      }
      return {
        path: yield io.which("tar", true),
        type: constants_1.ArchiveToolType.GNU
      };
    });
  }
  function getTarArgs(tarPath, compressionMethod, type15, archivePath = "") {
    return __awaiter(this, undefined, undefined, function* () {
      const args = [`"${tarPath.path}"`];
      const cacheFileName = utils4.getCacheFileName(compressionMethod);
      const tarFile = "cache.tar";
      const workingDirectory = getWorkingDirectory();
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (type15) {
        case "create":
          args.push("--posix", "-cf", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path5.sep}`, "g"), "/"), "--exclude", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path5.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path5.sep}`, "g"), "/"), "--files-from", constants_1.ManifestFilename);
          break;
        case "extract":
          args.push("-xf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path5.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path5.sep}`, "g"), "/"));
          break;
        case "list":
          args.push("-tf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path5.sep}`, "g"), "/"), "-P");
          break;
      }
      if (tarPath.type === constants_1.ArchiveToolType.GNU) {
        switch (process.platform) {
          case "win32":
            args.push("--force-local");
            break;
          case "darwin":
            args.push("--delay-directory-restore");
            break;
        }
      }
      return args;
    });
  }
  function getCommands(compressionMethod, type15, archivePath = "") {
    return __awaiter(this, undefined, undefined, function* () {
      let args;
      const tarPath = yield getTarPath();
      const tarArgs = yield getTarArgs(tarPath, compressionMethod, type15, archivePath);
      const compressionArgs = type15 !== "create" ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath) : yield getCompressionProgram(tarPath, compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      if (BSD_TAR_ZSTD && type15 !== "create") {
        args = [[...compressionArgs].join(" "), [...tarArgs].join(" ")];
      } else {
        args = [[...tarArgs].join(" "), [...compressionArgs].join(" ")];
      }
      if (BSD_TAR_ZSTD) {
        return args;
      }
      return [args.join(" ")];
    });
  }
  function getWorkingDirectory() {
    var _a;
    return (_a = process.env["GITHUB_WORKSPACE"]) !== null && _a !== undefined ? _a : process.cwd();
  }
  function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
    return __awaiter(this, undefined, undefined, function* () {
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -d --long=30 --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path5.sep}`, "g"), "/")
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -d --long=30"' : "unzstd --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -d --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path5.sep}`, "g"), "/")
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -d"' : "unzstd"];
        default:
          return ["-z"];
      }
    });
  }
  function getCompressionProgram(tarPath, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      const cacheFileName = utils4.getCacheFileName(compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --long=30 --force -o",
            cacheFileName.replace(new RegExp(`\\${path5.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --force -o",
            cacheFileName.replace(new RegExp(`\\${path5.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -T0"' : "zstdmt"];
        default:
          return ["-z"];
      }
    });
  }
  function execCommands(commands, cwd3) {
    return __awaiter(this, undefined, undefined, function* () {
      for (const command4 of commands) {
        try {
          yield (0, exec_1.exec)(command4, undefined, {
            cwd: cwd3,
            env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
          });
        } catch (error2) {
          throw new Error(`${command4.split(" ")[0]} failed with error: ${error2 === null || error2 === undefined ? undefined : error2.message}`);
        }
      }
    });
  }
  function listTar(archivePath, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      const commands = yield getCommands(compressionMethod, "list", archivePath);
      yield execCommands(commands);
    });
  }
  function extractTar(archivePath, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      const workingDirectory = getWorkingDirectory();
      yield io.mkdirP(workingDirectory);
      const commands = yield getCommands(compressionMethod, "extract", archivePath);
      yield execCommands(commands);
    });
  }
  function createTar(archiveFolder, sourceDirectories, compressionMethod) {
    return __awaiter(this, undefined, undefined, function* () {
      (0, fs_1.writeFileSync)(path5.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join("\n"));
      const commands = yield getCommands(compressionMethod, "create");
      yield execCommands(commands, archiveFolder);
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTar = exports.extractTar = exports.listTar = undefined;
  var exec_1 = require_exec();
  var io = __importStar(require_io());
  var fs_1 = __require("fs");
  var path5 = __importStar(__require("path"));
  var utils4 = __importStar(require_cacheUtils());
  var constants_1 = require_constants6();
  var IS_WINDOWS = process.platform === "win32";
  exports.listTar = listTar;
  exports.extractTar = extractTar;
  exports.createTar = createTar;
});

// node_modules/@actions/cache/lib/cache.js
var require_cache2 = __commonJS((exports) => {
  function checkPaths(paths) {
    if (!paths || paths.length === 0) {
      throw new ValidationError(`Path Validation Error: At least one directory or file path is required`);
    }
  }
  function checkKey(key) {
    if (key.length > 512) {
      throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
    }
    const regex = /^[^,]*$/;
    if (!regex.test(key)) {
      throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
    }
  }
  function isFeatureAvailable() {
    return !!process.env["ACTIONS_CACHE_URL"];
  }
  function restoreCache(paths, primaryKey, restoreKeys, options3, enableCrossOsArchive = false) {
    return __awaiter(this, undefined, undefined, function* () {
      checkPaths(paths);
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core2.debug("Resolved Keys:");
      core2.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      const compressionMethod = yield utils4.getCompressionMethod();
      let archivePath = "";
      try {
        const cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
          compressionMethod,
          enableCrossOsArchive
        });
        if (!(cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.archiveLocation)) {
          return;
        }
        if (options3 === null || options3 === undefined ? undefined : options3.lookupOnly) {
          core2.info("Lookup only - skipping download");
          return cacheEntry.cacheKey;
        }
        archivePath = path5.join(yield utils4.createTempDirectory(), utils4.getCacheFileName(compressionMethod));
        core2.debug(`Archive Path: ${archivePath}`);
        yield cacheHttpClient.downloadCache(cacheEntry.archiveLocation, archivePath, options3);
        if (core2.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils4.getArchiveFileSizeInBytes(archivePath);
        core2.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core2.info("Cache restored successfully");
        return cacheEntry.cacheKey;
      } catch (error2) {
        const typedError = error2;
        if (typedError.name === ValidationError.name) {
          throw error2;
        } else {
          core2.warning(`Failed to restore: ${error2.message}`);
        }
      } finally {
        try {
          yield utils4.unlinkFile(archivePath);
        } catch (error2) {
          core2.debug(`Failed to delete archive: ${error2}`);
        }
      }
      return;
    });
  }
  function saveCache(paths, key, options3, enableCrossOsArchive = false) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, undefined, undefined, function* () {
      checkPaths(paths);
      checkKey(key);
      const compressionMethod = yield utils4.getCompressionMethod();
      let cacheId = -1;
      const cachePaths = yield utils4.resolvePaths(paths);
      core2.debug("Cache Paths:");
      core2.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils4.createTempDirectory();
      const archivePath = path5.join(archiveFolder, utils4.getCacheFileName(compressionMethod));
      core2.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core2.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const fileSizeLimit = 10 * 1024 * 1024 * 1024;
        const archiveFileSize = utils4.getArchiveFileSizeInBytes(archivePath);
        core2.debug(`File Size: ${archiveFileSize}`);
        if (archiveFileSize > fileSizeLimit && !utils4.isGhes()) {
          throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
        }
        core2.debug("Reserving Cache");
        const reserveCacheResponse = yield cacheHttpClient.reserveCache(key, paths, {
          compressionMethod,
          enableCrossOsArchive,
          cacheSize: archiveFileSize
        });
        if ((_a = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.result) === null || _a === undefined ? undefined : _a.cacheId) {
          cacheId = (_b = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.result) === null || _b === undefined ? undefined : _b.cacheId;
        } else if ((reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.statusCode) === 400) {
          throw new Error((_d = (_c = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.error) === null || _c === undefined ? undefined : _c.message) !== null && _d !== undefined ? _d : `Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the data cap limit, not saving cache.`);
        } else {
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache. More details: ${(_e = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.error) === null || _e === undefined ? undefined : _e.message}`);
        }
        core2.debug(`Saving Cache (ID: ${cacheId})`);
        yield cacheHttpClient.saveCache(cacheId, archivePath, options3);
      } catch (error2) {
        const typedError = error2;
        if (typedError.name === ValidationError.name) {
          throw error2;
        } else if (typedError.name === ReserveCacheError.name) {
          core2.info(`Failed to save: ${typedError.message}`);
        } else {
          core2.warning(`Failed to save: ${typedError.message}`);
        }
      } finally {
        try {
          yield utils4.unlinkFile(archivePath);
        } catch (error2) {
          core2.debug(`Failed to delete archive: ${error2}`);
        }
      }
      return cacheId;
    });
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result5 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result5, mod, k);
    }
    __setModuleDefault(result5, mod);
    return result5;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator4) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject4) {
      function fulfilled(value) {
        try {
          step(generator4.next(value));
        } catch (e) {
          reject4(e);
        }
      }
      function rejected(value) {
        try {
          step(generator4["throw"](value));
        } catch (e) {
          reject4(e);
        }
      }
      function step(result5) {
        result5.done ? resolve(result5.value) : adopt(result5.value).then(fulfilled, rejected);
      }
      step((generator4 = generator4.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saveCache = exports.restoreCache = exports.isFeatureAvailable = exports.ReserveCacheError = exports.ValidationError = undefined;
  var core2 = __importStar(require_core());
  var path5 = __importStar(__require("path"));
  var utils4 = __importStar(require_cacheUtils());
  var cacheHttpClient = __importStar(require_cacheHttpClient());
  var tar_1 = require_tar();

  class ValidationError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "ValidationError";
      Object.setPrototypeOf(this, ValidationError.prototype);
    }
  }
  exports.ValidationError = ValidationError;

  class ReserveCacheError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "ReserveCacheError";
      Object.setPrototypeOf(this, ReserveCacheError.prototype);
    }
  }
  exports.ReserveCacheError = ReserveCacheError;
  exports.isFeatureAvailable = isFeatureAvailable;
  exports.restoreCache = restoreCache;
  exports.saveCache = saveCache;
});

// node_modules/semver/semver.js
var require_semver3 = __commonJS((exports, module) => {
  function tok(n2) {
    t[n2] = R++;
  }
  function makeSafeRe(value) {
    for (var i3 = 0;i3 < safeRegexReplacements.length; i3++) {
      var token = safeRegexReplacements[i3][0];
      var max = safeRegexReplacements[i3][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  function parse(version, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options3.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options3);
    } catch (er) {
      return null;
    }
  }
  function valid(version, options3) {
    var v = parse(version, options3);
    return v ? v.version : null;
  }
  function clean(version, options3) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options3);
    return s ? s.version : null;
  }
  function SemVer(version, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options3.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options3);
    }
    debug("SemVer", version, options3);
    this.options = options3;
    this.loose = !!options3.loose;
    var m = version.trim().match(options3.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  function compareIdentifiers(a2, b) {
    var anum = numeric.test(a2);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a2 = +a2;
      b = +b;
    }
    return a2 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b ? -1 : 1;
  }
  function rcompareIdentifiers(a2, b) {
    return compareIdentifiers(b, a2);
  }
  function major(a2, loose) {
    return new SemVer(a2, loose).major;
  }
  function minor(a2, loose) {
    return new SemVer(a2, loose).minor;
  }
  function patch(a2, loose) {
    return new SemVer(a2, loose).patch;
  }
  function compare(a2, b, loose) {
    return new SemVer(a2, loose).compare(new SemVer(b, loose));
  }
  function compareLoose(a2, b) {
    return compare(a2, b, true);
  }
  function compareBuild(a2, b, loose) {
    var versionA = new SemVer(a2, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  function rcompare(a2, b, loose) {
    return compare(b, a2, loose);
  }
  function sort(list, loose) {
    return list.sort(function(a2, b) {
      return exports.compareBuild(a2, b, loose);
    });
  }
  function rsort(list, loose) {
    return list.sort(function(a2, b) {
      return exports.compareBuild(b, a2, loose);
    });
  }
  function gt(a2, b, loose) {
    return compare(a2, b, loose) > 0;
  }
  function lt(a2, b, loose) {
    return compare(a2, b, loose) < 0;
  }
  function eq(a2, b, loose) {
    return compare(a2, b, loose) === 0;
  }
  function neq(a2, b, loose) {
    return compare(a2, b, loose) !== 0;
  }
  function gte(a2, b, loose) {
    return compare(a2, b, loose) >= 0;
  }
  function lte(a2, b, loose) {
    return compare(a2, b, loose) <= 0;
  }
  function cmp(a2, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b === "object")
          b = b.version;
        return a2 === b;
      case "!==":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b === "object")
          b = b.version;
        return a2 !== b;
      case "":
      case "=":
      case "==":
        return eq(a2, b, loose);
      case "!=":
        return neq(a2, b, loose);
      case ">":
        return gt(a2, b, loose);
      case ">=":
        return gte(a2, b, loose);
      case "<":
        return lt(a2, b, loose);
      case "<=":
        return lte(a2, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  function Comparator(comp, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options3.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options3);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options3);
    this.options = options3;
    this.loose = !!options3.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  function Range(range, options3) {
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options3.loose && range.includePrerelease === !!options3.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options3);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options3);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options3);
    }
    this.options = options3;
    this.loose = !!options3.loose;
    this.includePrerelease = !!options3.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c3) {
      return c3.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  }
  function isSatisfiable(comparators, options3) {
    var result5 = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result5 && remainingComparators.length) {
      result5 = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options3);
      });
      testComparator = remainingComparators.pop();
    }
    return result5;
  }
  function toComparators(range, options3) {
    return new Range(range, options3).set.map(function(comp) {
      return comp.map(function(c3) {
        return c3.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options3) {
    debug("comp", comp, options3);
    comp = replaceCarets(comp, options3);
    debug("caret", comp);
    comp = replaceTildes(comp, options3);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options3);
    debug("xrange", comp);
    comp = replaceStars(comp, options3);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options3) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options3);
    }).join(" ");
  }
  function replaceTilde(comp, options3) {
    var r = options3.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options3) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options3);
    }).join(" ");
  }
  function replaceCaret(comp, options3) {
    debug("caret", comp, options3);
    var r = options3.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options3) {
    debug("replaceXRanges", comp, options3);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options3);
    }).join(" ");
  }
  function replaceXRange(comp, options3) {
    comp = comp.trim();
    var r = options3.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options3.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options3) {
    debug("replaceStars", comp, options3);
    return comp.trim().replace(safeRe[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  function testSet(set, version, options3) {
    for (var i3 = 0;i3 < set.length; i3++) {
      if (!set[i3].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options3.includePrerelease) {
      for (i3 = 0;i3 < set.length; i3++) {
        debug(set[i3].semver);
        if (set[i3].semver === ANY) {
          continue;
        }
        if (set[i3].semver.prerelease.length > 0) {
          var allowed = set[i3].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  function satisfies(version, range, options3) {
    try {
      range = new Range(range, options3);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  function maxSatisfying(versions, range, options3) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options3);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options3);
        }
      }
    });
    return max;
  }
  function minSatisfying(versions, range, options3) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options3);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options3);
        }
      }
    });
    return min;
  }
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  function validRange(range, options3) {
    try {
      return new Range(range, options3).range || "*";
    } catch (er) {
      return null;
    }
  }
  function ltr(version, range, options3) {
    return outside(version, range, "<", options3);
  }
  function gtr(version, range, options3) {
    return outside(version, range, ">", options3);
  }
  function outside(version, range, hilo, options3) {
    version = new SemVer(version, options3);
    range = new Range(range, options3);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options3)) {
      return false;
    }
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options3)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options3)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  function prerelease(version, options3) {
    var parsed = parse(version, options3);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  function intersects(r1, r2, options3) {
    r1 = new Range(r1, options3);
    r2 = new Range(r2, options3);
    return r1.intersects(r2);
  }
  function coerce(version, options3) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options3 = options3 || {};
    var match = null;
    if (!options3.rtl) {
      match = version.match(safeRe[t.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options3);
  }
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.tokens = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")\\." + "(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")" + "(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + "(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?" + ")?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])" + "(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAIN] + ")" + "\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (i2 = 0;i2 < R; i2++) {
    debug(i2, src[i2]);
    if (!re[i2]) {
      re[i2] = new RegExp(src[i2]);
      safeRe[i2] = new RegExp(makeSafeRe(src[i2]));
    }
  }
  var i2;
  exports.parse = parse;
  exports.valid = valid;
  exports.clean = clean;
  exports.SemVer = SemVer;
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i3 = 0;
    do {
      var a2 = this.prerelease[i3];
      var b = other.prerelease[i3];
      debug("prerelease compare", i3, a2, b);
      if (a2 === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b) {
        continue;
      } else {
        return compareIdentifiers(a2, b);
      }
    } while (++i3);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i3 = 0;
    do {
      var a2 = this.build[i3];
      var b = other.build[i3];
      debug("prerelease compare", i3, a2, b);
      if (a2 === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b) {
        continue;
      } else {
        return compareIdentifiers(a2, b);
      }
    } while (++i3);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i3 = this.prerelease.length;
          while (--i3 >= 0) {
            if (typeof this.prerelease[i3] === "number") {
              this.prerelease[i3]++;
              i3 = -2;
            }
          }
          if (i3 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  exports.diff = diff;
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  exports.rcompareIdentifiers = rcompareIdentifiers;
  exports.major = major;
  exports.minor = minor;
  exports.patch = patch;
  exports.compare = compare;
  exports.compareLoose = compareLoose;
  exports.compareBuild = compareBuild;
  exports.rcompare = rcompare;
  exports.sort = sort;
  exports.rsort = rsort;
  exports.gt = gt;
  exports.lt = lt;
  exports.eq = eq;
  exports.neq = neq;
  exports.gte = gte;
  exports.lte = lte;
  exports.cmp = cmp;
  exports.Comparator = Comparator;
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== undefined ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options3) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options3 || typeof options3 !== "object") {
      options3 = {
        loose: !!options3,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options3);
      return satisfies(this.value, rangeTmp, options3);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options3);
      return satisfies(comp.semver, rangeTmp, options3);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options3) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options3) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
    range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options3) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options3) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options3) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options3);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i3 = 0;i3 < this.set.length; i3++) {
      if (testSet(this.set[i3], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  exports.satisfies = satisfies;
  exports.maxSatisfying = maxSatisfying;
  exports.minSatisfying = minSatisfying;
  exports.minVersion = minVersion;
  exports.validRange = validRange;
  exports.ltr = ltr;
  exports.gtr = gtr;
  exports.outside = outside;
  exports.prerelease = prerelease;
  exports.intersects = intersects;
  exports.coerce = coerce;
});

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/execa/lib/arguments/file-url.js
import {fileURLToPath} from "node:url";
var safeNormalizeFileUrl = (file, name) => {
  const fileString = normalizeFileUrl(file);
  if (typeof fileString !== "string") {
    throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
  }
  return fileString;
};
var normalizeFileUrl = (file) => file instanceof URL ? fileURLToPath(file) : file;

// node_modules/execa/lib/methods/parameters.js
var normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
  const filePath = safeNormalizeFileUrl(rawFile, "First argument");
  const [commandArguments, options] = isPlainObject(rawArguments) ? [[], rawArguments] : [rawArguments, rawOptions];
  if (!Array.isArray(commandArguments)) {
    throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
  }
  if (commandArguments.some((commandArgument) => typeof commandArgument === "object" && commandArgument !== null)) {
    throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
  }
  const normalizedArguments = commandArguments.map(String);
  const nullByteArgument = normalizedArguments.find((normalizedArgument) => normalizedArgument.includes("\0"));
  if (nullByteArgument !== undefined) {
    throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
  }
  if (!isPlainObject(options)) {
    throw new TypeError(`Last argument must be an options object: ${options}`);
  }
  return [filePath, normalizedArguments, options];
};

// node_modules/execa/lib/methods/template.js
import {ChildProcess} from "node:child_process";

// node_modules/execa/lib/utils/uint-array.js
import {StringDecoder} from "node:string_decoder";
var { toString: objectToString } = Object.prototype;
var isArrayBuffer = (value) => objectToString.call(value) === "[object ArrayBuffer]";
var isUint8Array = (value) => objectToString.call(value) === "[object Uint8Array]";
var bufferToUint8Array = (buffer) => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
var textEncoder = new TextEncoder;
var stringToUint8Array = (string) => textEncoder.encode(string);
var textDecoder = new TextDecoder;
var uint8ArrayToString = (uint8Array) => textDecoder.decode(uint8Array);
var joinToString = (uint8ArraysOrStrings, encoding) => {
  const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
  return strings.join("");
};
var uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
  if (encoding === "utf8" && uint8ArraysOrStrings.every((uint8ArrayOrString) => typeof uint8ArrayOrString === "string")) {
    return uint8ArraysOrStrings;
  }
  const decoder = new StringDecoder(encoding);
  const strings = uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array) => decoder.write(uint8Array));
  const finalString = decoder.end();
  return finalString === "" ? strings : [...strings, finalString];
};
var joinToUint8Array = (uint8ArraysOrStrings) => {
  if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
    return uint8ArraysOrStrings[0];
  }
  return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
var stringsToUint8Arrays = (uint8ArraysOrStrings) => uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
var concatUint8Arrays = (uint8Arrays) => {
  const result = new Uint8Array(getJoinLength(uint8Arrays));
  let index = 0;
  for (const uint8Array of uint8Arrays) {
    result.set(uint8Array, index);
    index += uint8Array.length;
  }
  return result;
};
var getJoinLength = (uint8Arrays) => {
  let joinLength = 0;
  for (const uint8Array of uint8Arrays) {
    joinLength += uint8Array.length;
  }
  return joinLength;
};

// node_modules/execa/lib/methods/template.js
var isTemplateString = (templates) => Array.isArray(templates) && Array.isArray(templates.raw);
var parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index, template] of templates.entries()) {
    tokens = parseTemplate({
      templates,
      expressions,
      tokens,
      index,
      template
    });
  }
  if (tokens.length === 0) {
    throw new TypeError("Template script must not be empty");
  }
  const [file, ...commandArguments] = tokens;
  return [file, commandArguments, {}];
};
var parseTemplate = ({ templates, expressions, tokens, index, template }) => {
  if (template === undefined) {
    throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
  }
  const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
  const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
  if (index === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index];
  const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};
var splitByWhitespaces = (template, rawTemplate) => {
  if (rawTemplate.length === 0) {
    return { nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false };
  }
  const nextTokens = [];
  let templateStart = 0;
  const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
  for (let templateIndex = 0, rawIndex = 0;templateIndex < template.length; templateIndex += 1, rawIndex += 1) {
    const rawCharacter = rawTemplate[rawIndex];
    if (DELIMITERS.has(rawCharacter)) {
      if (templateStart !== templateIndex) {
        nextTokens.push(template.slice(templateStart, templateIndex));
      }
      templateStart = templateIndex + 1;
    } else if (rawCharacter === "\\") {
      const nextRawCharacter = rawTemplate[rawIndex + 1];
      if (nextRawCharacter === "u" && rawTemplate[rawIndex + 2] === "{") {
        rawIndex = rawTemplate.indexOf("}", rawIndex + 3);
      } else {
        rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
      }
    }
  }
  const trailingWhitespaces = templateStart === template.length;
  if (!trailingWhitespaces) {
    nextTokens.push(template.slice(templateStart));
  }
  return { nextTokens, leadingWhitespaces, trailingWhitespaces };
};
var DELIMITERS = new Set([" ", "\t", "\r", "\n"]);
var ESCAPE_LENGTH = { x: 3, u: 5 };
var concatTokens = (tokens, nextTokens, isSeparated) => isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens.at(-1)}${nextTokens[0]}`,
  ...nextTokens.slice(1)
];
var parseExpression = (expression) => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === "string") {
    return expression;
  }
  if (typeOfExpression === "number") {
    return String(expression);
  }
  if (isPlainObject(expression) && (("stdout" in expression) || ("isMaxBuffer" in expression))) {
    return getSubprocessResult(expression);
  }
  if (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === "[object Promise]") {
    throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
var getSubprocessResult = ({ stdout }) => {
  if (typeof stdout === "string") {
    return stdout;
  }
  if (isUint8Array(stdout)) {
    return uint8ArrayToString(stdout);
  }
  if (stdout === undefined) {
    throw new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');
  }
  throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};

// node_modules/execa/lib/methods/main-sync.js
import {spawnSync} from "node:child_process";

// node_modules/execa/lib/arguments/specific.js
import {debuglog} from "node:util";

// node_modules/execa/lib/utils/standard-stream.js
import process2 from "node:process";
var isStandardStream = (stream) => STANDARD_STREAMS.includes(stream);
var STANDARD_STREAMS = [process2.stdin, process2.stdout, process2.stderr];
var STANDARD_STREAMS_ALIASES = ["stdin", "stdout", "stderr"];
var getStreamName = (fdNumber) => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;

// node_modules/execa/lib/arguments/specific.js
var normalizeFdSpecificOptions = (options) => {
  const optionsCopy = { ...options };
  for (const optionName of FD_SPECIFIC_OPTIONS) {
    optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
  }
  return optionsCopy;
};
var normalizeFdSpecificOption = (options, optionName) => {
  const optionBaseArray = Array.from({ length: getStdioLength(options) + 1 });
  const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
  return addDefaultValue(optionArray, optionName);
};
var getStdioLength = ({ stdio }) => Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length;
var normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
var normalizeOptionObject = (optionValue, optionArray, optionName) => {
  for (const fdName of Object.keys(optionValue).sort(compareFdName)) {
    for (const fdNumber of parseFdName(fdName, optionName, optionArray)) {
      optionArray[fdNumber] = optionValue[fdName];
    }
  }
  return optionArray;
};
var compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
var getFdNameOrder = (fdName) => {
  if (fdName === "stdout" || fdName === "stderr") {
    return 0;
  }
  return fdName === "all" ? 2 : 1;
};
var parseFdName = (fdName, optionName, optionArray) => {
  if (fdName === "ipc") {
    return [optionArray.length - 1];
  }
  const fdNumber = parseFd(fdName);
  if (fdNumber === undefined || fdNumber === 0) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
  }
  if (fdNumber >= optionArray.length) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  return fdNumber === "all" ? [1, 2] : [fdNumber];
};
var parseFd = (fdName) => {
  if (fdName === "all") {
    return fdName;
  }
  if (STANDARD_STREAMS_ALIASES.includes(fdName)) {
    return STANDARD_STREAMS_ALIASES.indexOf(fdName);
  }
  const regexpResult = FD_REGEXP.exec(fdName);
  if (regexpResult !== null) {
    return Number(regexpResult[1]);
  }
};
var FD_REGEXP = /^fd(\d+)$/;
var addDefaultValue = (optionArray, optionName) => optionArray.map((optionValue) => optionValue === undefined ? DEFAULT_OPTIONS[optionName] : optionValue);
var verboseDefault = debuglog("execa").enabled ? "full" : "none";
var DEFAULT_OPTIONS = {
  lines: false,
  buffer: true,
  maxBuffer: 1000 * 1000 * 100,
  verbose: verboseDefault,
  stripFinalNewline: true
};
var FD_SPECIFIC_OPTIONS = ["lines", "buffer", "maxBuffer", "verbose", "stripFinalNewline"];
var getFdSpecificValue = (optionArray, fdNumber) => fdNumber === "ipc" ? optionArray.at(-1) : optionArray[fdNumber];

// node_modules/execa/lib/verbose/values.js
var isVerbose = ({ verbose }, fdNumber) => getFdVerbose(verbose, fdNumber) !== "none";
var isFullVerbose = ({ verbose }, fdNumber) => !["none", "short"].includes(getFdVerbose(verbose, fdNumber));
var getVerboseFunction = ({ verbose }, fdNumber) => {
  const fdVerbose = getFdVerbose(verbose, fdNumber);
  return isVerboseFunction(fdVerbose) ? fdVerbose : undefined;
};
var getFdVerbose = (verbose, fdNumber) => fdNumber === undefined ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber);
var getFdGenericVerbose = (verbose) => verbose.find((fdVerbose) => isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose) => verbose.includes(fdVerbose));
var isVerboseFunction = (fdVerbose) => typeof fdVerbose === "function";
var VERBOSE_VALUES = ["none", "short", "full"];

// node_modules/execa/lib/verbose/log.js
import {writeFileSync} from "node:fs";
import {inspect} from "node:util";

// node_modules/execa/lib/arguments/escape.js
import {platform} from "node:process";
import {stripVTControlCharacters} from "node:util";
var joinCommand = (filePath, rawArguments) => {
  const fileAndArguments = [filePath, ...rawArguments];
  const command = fileAndArguments.join(" ");
  const escapedCommand = fileAndArguments.map((fileAndArgument) => quoteString(escapeControlCharacters(fileAndArgument))).join(" ");
  return { command, escapedCommand };
};
var escapeLines = (lines) => stripVTControlCharacters(lines).split("\n").map((line) => escapeControlCharacters(line)).join("\n");
var escapeControlCharacters = (line) => line.replaceAll(SPECIAL_CHAR_REGEXP, (character) => escapeControlCharacter(character));
var escapeControlCharacter = (character) => {
  const commonEscape = COMMON_ESCAPES[character];
  if (commonEscape !== undefined) {
    return commonEscape;
  }
  const codepoint = character.codePointAt(0);
  const codepointHex = codepoint.toString(16);
  return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, "0")}` : `\\U${codepointHex}`;
};
var getSpecialCharRegExp = () => {
  try {
    return new RegExp("\\p{Separator}|\\p{Other}", "gu");
  } catch {
    return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
  }
};
var SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
var COMMON_ESCAPES = {
  " ": " ",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "\t": "\\t"
};
var ASTRAL_START = 65535;
var quoteString = (escapedArgument) => {
  if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
    return escapedArgument;
  }
  return platform === "win32" ? `"${escapedArgument.replaceAll('"', '""')}"` : `'${escapedArgument.replaceAll("\'", "\'\\\'\'")}'`;
};
var NO_ESCAPE_REGEXP = /^[\w./-]+$/;

// node_modules/is-unicode-supported/index.js
import process3 from "node:process";
function isUnicodeSupported() {
  if (process3.platform !== "win32") {
    return process3.env.TERM !== "linux";
  }
  return Boolean(process3.env.WT_SESSION) || Boolean(process3.env.TERMINUS_SUBLIME) || process3.env.ConEmuTask === "{cmd::Cmder}" || process3.env.TERM_PROGRAM === "Terminus-Sublime" || process3.env.TERM_PROGRAM === "vscode" || process3.env.TERM === "xterm-256color" || process3.env.TERM === "alacritty" || process3.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/figures/index.js
var common = {
  circleQuestionMark: "(?)",
  questionMarkPrefix: "(?)",
  square: "\u2588",
  squareDarkShade: "\u2593",
  squareMediumShade: "\u2592",
  squareLightShade: "\u2591",
  squareTop: "\u2580",
  squareBottom: "\u2584",
  squareLeft: "\u258C",
  squareRight: "\u2590",
  squareCenter: "\u25A0",
  bullet: "\u25CF",
  dot: "\u2024",
  ellipsis: "\u2026",
  pointerSmall: "\u203A",
  triangleUp: "\u25B2",
  triangleUpSmall: "\u25B4",
  triangleDown: "\u25BC",
  triangleDownSmall: "\u25BE",
  triangleLeftSmall: "\u25C2",
  triangleRightSmall: "\u25B8",
  home: "\u2302",
  heart: "\u2665",
  musicNote: "\u266A",
  musicNoteBeamed: "\u266B",
  arrowUp: "\u2191",
  arrowDown: "\u2193",
  arrowLeft: "\u2190",
  arrowRight: "\u2192",
  arrowLeftRight: "\u2194",
  arrowUpDown: "\u2195",
  almostEqual: "\u2248",
  notEqual: "\u2260",
  lessOrEqual: "\u2264",
  greaterOrEqual: "\u2265",
  identical: "\u2261",
  infinity: "\u221E",
  subscriptZero: "\u2080",
  subscriptOne: "\u2081",
  subscriptTwo: "\u2082",
  subscriptThree: "\u2083",
  subscriptFour: "\u2084",
  subscriptFive: "\u2085",
  subscriptSix: "\u2086",
  subscriptSeven: "\u2087",
  subscriptEight: "\u2088",
  subscriptNine: "\u2089",
  oneHalf: "\xBD",
  oneThird: "\u2153",
  oneQuarter: "\xBC",
  oneFifth: "\u2155",
  oneSixth: "\u2159",
  oneEighth: "\u215B",
  twoThirds: "\u2154",
  twoFifths: "\u2156",
  threeQuarters: "\xBE",
  threeFifths: "\u2157",
  threeEighths: "\u215C",
  fourFifths: "\u2158",
  fiveSixths: "\u215A",
  fiveEighths: "\u215D",
  sevenEighths: "\u215E",
  line: "\u2500",
  lineBold: "\u2501",
  lineDouble: "\u2550",
  lineDashed0: "\u2504",
  lineDashed1: "\u2505",
  lineDashed2: "\u2508",
  lineDashed3: "\u2509",
  lineDashed4: "\u254C",
  lineDashed5: "\u254D",
  lineDashed6: "\u2574",
  lineDashed7: "\u2576",
  lineDashed8: "\u2578",
  lineDashed9: "\u257A",
  lineDashed10: "\u257C",
  lineDashed11: "\u257E",
  lineDashed12: "\u2212",
  lineDashed13: "\u2013",
  lineDashed14: "\u2010",
  lineDashed15: "\u2043",
  lineVertical: "\u2502",
  lineVerticalBold: "\u2503",
  lineVerticalDouble: "\u2551",
  lineVerticalDashed0: "\u2506",
  lineVerticalDashed1: "\u2507",
  lineVerticalDashed2: "\u250A",
  lineVerticalDashed3: "\u250B",
  lineVerticalDashed4: "\u254E",
  lineVerticalDashed5: "\u254F",
  lineVerticalDashed6: "\u2575",
  lineVerticalDashed7: "\u2577",
  lineVerticalDashed8: "\u2579",
  lineVerticalDashed9: "\u257B",
  lineVerticalDashed10: "\u257D",
  lineVerticalDashed11: "\u257F",
  lineDownLeft: "\u2510",
  lineDownLeftArc: "\u256E",
  lineDownBoldLeftBold: "\u2513",
  lineDownBoldLeft: "\u2512",
  lineDownLeftBold: "\u2511",
  lineDownDoubleLeftDouble: "\u2557",
  lineDownDoubleLeft: "\u2556",
  lineDownLeftDouble: "\u2555",
  lineDownRight: "\u250C",
  lineDownRightArc: "\u256D",
  lineDownBoldRightBold: "\u250F",
  lineDownBoldRight: "\u250E",
  lineDownRightBold: "\u250D",
  lineDownDoubleRightDouble: "\u2554",
  lineDownDoubleRight: "\u2553",
  lineDownRightDouble: "\u2552",
  lineUpLeft: "\u2518",
  lineUpLeftArc: "\u256F",
  lineUpBoldLeftBold: "\u251B",
  lineUpBoldLeft: "\u251A",
  lineUpLeftBold: "\u2519",
  lineUpDoubleLeftDouble: "\u255D",
  lineUpDoubleLeft: "\u255C",
  lineUpLeftDouble: "\u255B",
  lineUpRight: "\u2514",
  lineUpRightArc: "\u2570",
  lineUpBoldRightBold: "\u2517",
  lineUpBoldRight: "\u2516",
  lineUpRightBold: "\u2515",
  lineUpDoubleRightDouble: "\u255A",
  lineUpDoubleRight: "\u2559",
  lineUpRightDouble: "\u2558",
  lineUpDownLeft: "\u2524",
  lineUpBoldDownBoldLeftBold: "\u252B",
  lineUpBoldDownBoldLeft: "\u2528",
  lineUpDownLeftBold: "\u2525",
  lineUpBoldDownLeftBold: "\u2529",
  lineUpDownBoldLeftBold: "\u252A",
  lineUpDownBoldLeft: "\u2527",
  lineUpBoldDownLeft: "\u2526",
  lineUpDoubleDownDoubleLeftDouble: "\u2563",
  lineUpDoubleDownDoubleLeft: "\u2562",
  lineUpDownLeftDouble: "\u2561",
  lineUpDownRight: "\u251C",
  lineUpBoldDownBoldRightBold: "\u2523",
  lineUpBoldDownBoldRight: "\u2520",
  lineUpDownRightBold: "\u251D",
  lineUpBoldDownRightBold: "\u2521",
  lineUpDownBoldRightBold: "\u2522",
  lineUpDownBoldRight: "\u251F",
  lineUpBoldDownRight: "\u251E",
  lineUpDoubleDownDoubleRightDouble: "\u2560",
  lineUpDoubleDownDoubleRight: "\u255F",
  lineUpDownRightDouble: "\u255E",
  lineDownLeftRight: "\u252C",
  lineDownBoldLeftBoldRightBold: "\u2533",
  lineDownLeftBoldRightBold: "\u252F",
  lineDownBoldLeftRight: "\u2530",
  lineDownBoldLeftBoldRight: "\u2531",
  lineDownBoldLeftRightBold: "\u2532",
  lineDownLeftRightBold: "\u252E",
  lineDownLeftBoldRight: "\u252D",
  lineDownDoubleLeftDoubleRightDouble: "\u2566",
  lineDownDoubleLeftRight: "\u2565",
  lineDownLeftDoubleRightDouble: "\u2564",
  lineUpLeftRight: "\u2534",
  lineUpBoldLeftBoldRightBold: "\u253B",
  lineUpLeftBoldRightBold: "\u2537",
  lineUpBoldLeftRight: "\u2538",
  lineUpBoldLeftBoldRight: "\u2539",
  lineUpBoldLeftRightBold: "\u253A",
  lineUpLeftRightBold: "\u2536",
  lineUpLeftBoldRight: "\u2535",
  lineUpDoubleLeftDoubleRightDouble: "\u2569",
  lineUpDoubleLeftRight: "\u2568",
  lineUpLeftDoubleRightDouble: "\u2567",
  lineUpDownLeftRight: "\u253C",
  lineUpBoldDownBoldLeftBoldRightBold: "\u254B",
  lineUpDownBoldLeftBoldRightBold: "\u2548",
  lineUpBoldDownLeftBoldRightBold: "\u2547",
  lineUpBoldDownBoldLeftRightBold: "\u254A",
  lineUpBoldDownBoldLeftBoldRight: "\u2549",
  lineUpBoldDownLeftRight: "\u2540",
  lineUpDownBoldLeftRight: "\u2541",
  lineUpDownLeftBoldRight: "\u253D",
  lineUpDownLeftRightBold: "\u253E",
  lineUpBoldDownBoldLeftRight: "\u2542",
  lineUpDownLeftBoldRightBold: "\u253F",
  lineUpBoldDownLeftBoldRight: "\u2543",
  lineUpBoldDownLeftRightBold: "\u2544",
  lineUpDownBoldLeftBoldRight: "\u2545",
  lineUpDownBoldLeftRightBold: "\u2546",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "\u256C",
  lineUpDoubleDownDoubleLeftRight: "\u256B",
  lineUpDownLeftDoubleRightDouble: "\u256A",
  lineCross: "\u2573",
  lineBackslash: "\u2572",
  lineSlash: "\u2571"
};
var specialMainSymbols = {
  tick: "\u2714",
  info: "\u2139",
  warning: "\u26A0",
  cross: "\u2718",
  squareSmall: "\u25FB",
  squareSmallFilled: "\u25FC",
  circle: "\u25EF",
  circleFilled: "\u25C9",
  circleDotted: "\u25CC",
  circleDouble: "\u25CE",
  circleCircle: "\u24DE",
  circleCross: "\u24E7",
  circlePipe: "\u24BE",
  radioOn: "\u25C9",
  radioOff: "\u25EF",
  checkboxOn: "\u2612",
  checkboxOff: "\u2610",
  checkboxCircleOn: "\u24E7",
  checkboxCircleOff: "\u24BE",
  pointer: "\u276F",
  triangleUpOutline: "\u25B3",
  triangleLeft: "\u25C0",
  triangleRight: "\u25B6",
  lozenge: "\u25C6",
  lozengeOutline: "\u25C7",
  hamburger: "\u2630",
  smiley: "\u32E1",
  mustache: "\u0DF4",
  star: "\u2605",
  play: "\u25B6",
  nodejs: "\u2B22",
  oneSeventh: "\u2150",
  oneNinth: "\u2151",
  oneTenth: "\u2152"
};
var specialFallbackSymbols = {
  tick: "\u221A",
  info: "i",
  warning: "\u203C",
  cross: "\xD7",
  squareSmall: "\u25A1",
  squareSmallFilled: "\u25A0",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "(\u25CB)",
  circleCross: "(\xD7)",
  circlePipe: "(\u2502)",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[\xD7]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "(\xD7)",
  checkboxCircleOff: "( )",
  pointer: ">",
  triangleUpOutline: "\u2206",
  triangleLeft: "\u25C4",
  triangleRight: "\u25BA",
  lozenge: "\u2666",
  lozengeOutline: "\u25CA",
  hamburger: "\u2261",
  smiley: "\u263A",
  mustache: "\u250C\u2500\u2510",
  star: "\u2736",
  play: "\u25BA",
  nodejs: "\u2666",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
};
var mainSymbols = { ...common, ...specialMainSymbols };
var fallbackSymbols = { ...common, ...specialFallbackSymbols };
var shouldUseMain = isUnicodeSupported();
var figures = shouldUseMain ? mainSymbols : fallbackSymbols;
var figures_default = figures;
var replacements = Object.entries(specialMainSymbols);

// node_modules/yoctocolors/base.js
import tty from "node:tty";
var hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;
var format = (open, close) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close}m`;
  return (input) => {
    const string = input + "";
    let index = string.indexOf(closeCode);
    if (index === -1) {
      return openCode + string + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    while (index !== -1) {
      result += string.slice(lastIndex, index) + openCode;
      lastIndex = index + closeCode.length;
      index = string.indexOf(closeCode, lastIndex);
    }
    result += string.slice(lastIndex) + closeCode;
    return result;
  };
};
var reset = format(0, 0);
var bold = format(1, 22);
var dim = format(2, 22);
var italic = format(3, 23);
var underline = format(4, 24);
var overline = format(53, 55);
var inverse = format(7, 27);
var hidden = format(8, 28);
var strikethrough = format(9, 29);
var black = format(30, 39);
var red = format(31, 39);
var green = format(32, 39);
var yellow = format(33, 39);
var blue = format(34, 39);
var magenta = format(35, 39);
var cyan = format(36, 39);
var white = format(37, 39);
var gray = format(90, 39);
var bgBlack = format(40, 49);
var bgRed = format(41, 49);
var bgGreen = format(42, 49);
var bgYellow = format(43, 49);
var bgBlue = format(44, 49);
var bgMagenta = format(45, 49);
var bgCyan = format(46, 49);
var bgWhite = format(47, 49);
var bgGray = format(100, 49);
var redBright = format(91, 39);
var greenBright = format(92, 39);
var yellowBright = format(93, 39);
var blueBright = format(94, 39);
var magentaBright = format(95, 39);
var cyanBright = format(96, 39);
var whiteBright = format(97, 39);
var bgRedBright = format(101, 49);
var bgGreenBright = format(102, 49);
var bgYellowBright = format(103, 49);
var bgBlueBright = format(104, 49);
var bgMagentaBright = format(105, 49);
var bgCyanBright = format(106, 49);
var bgWhiteBright = format(107, 49);

// node_modules/execa/lib/verbose/default.js
var defaultVerboseFunction = ({
  type,
  message,
  timestamp,
  piped,
  commandId,
  result: { failed = false } = {},
  options: { reject = true }
}) => {
  const timestampString = serializeTimestamp(timestamp);
  const icon = ICONS[type]({ failed, reject, piped });
  const color = COLORS[type]({ reject });
  return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};
var serializeTimestamp = (timestamp) => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
var padField = (field, padding) => String(field).padStart(padding, "0");
var getFinalIcon = ({ failed, reject }) => {
  if (!failed) {
    return figures_default.tick;
  }
  return reject ? figures_default.cross : figures_default.warning;
};
var ICONS = {
  command: ({ piped }) => piped ? "|" : "$",
  output: () => " ",
  ipc: () => "*",
  error: getFinalIcon,
  duration: getFinalIcon
};
var identity = (string) => string;
var COLORS = {
  command: () => bold,
  output: () => identity,
  ipc: () => identity,
  error: ({ reject }) => reject ? redBright : yellowBright,
  duration: () => gray
};

// node_modules/execa/lib/verbose/custom.js
var applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
  const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
  return printedLines.map(({ verboseLine, verboseObject }) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine) => printedLine !== undefined).map((printedLine) => appendNewline(printedLine)).join("");
};
var applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
  if (verboseFunction === undefined) {
    return verboseLine;
  }
  const printedLine = verboseFunction(verboseLine, verboseObject);
  if (typeof printedLine === "string") {
    return printedLine;
  }
};
var appendNewline = (printedLine) => printedLine.endsWith("\n") ? printedLine : `${printedLine}\n`;

// node_modules/execa/lib/verbose/log.js
var verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result }) => {
  const verboseObject = getVerboseObject({ type, result, verboseInfo });
  const printedLines = getPrintedLines(verboseMessage, verboseObject);
  const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
  writeFileSync(STDERR_FD, finalLines);
};
var getVerboseObject = ({
  type,
  result,
  verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } }
}) => ({
  type,
  escapedCommand,
  commandId: `${commandId}`,
  timestamp: new Date,
  piped,
  result,
  options
});
var getPrintedLines = (verboseMessage, verboseObject) => verboseMessage.split("\n").map((message) => getPrintedLine({ ...verboseObject, message }));
var getPrintedLine = (verboseObject) => {
  const verboseLine = defaultVerboseFunction(verboseObject);
  return { verboseLine, verboseObject };
};
var STDERR_FD = 2;
var serializeVerboseMessage = (message) => {
  const messageString = typeof message === "string" ? message : inspect(message);
  const escapedMessage = escapeLines(messageString);
  return escapedMessage.replaceAll("\t", " ".repeat(TAB_SIZE));
};
var TAB_SIZE = 2;

// node_modules/execa/lib/verbose/start.js
var logCommand = (escapedCommand, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  verboseLog({
    type: "command",
    verboseMessage: escapedCommand,
    verboseInfo
  });
};

// node_modules/execa/lib/verbose/info.js
var getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
  validateVerbose(verbose);
  const commandId = getCommandId(verbose);
  return {
    verbose,
    escapedCommand,
    commandId,
    rawOptions
  };
};
var getCommandId = (verbose) => isVerbose({ verbose }) ? COMMAND_ID++ : undefined;
var COMMAND_ID = 0n;
var validateVerbose = (verbose) => {
  for (const fdVerbose of verbose) {
    if (fdVerbose === false) {
      throw new TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');
    }
    if (fdVerbose === true) {
      throw new TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');
    }
    if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
      const allowedValues = VERBOSE_VALUES.map((allowedValue) => `'${allowedValue}'`).join(", ");
      throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
    }
  }
};

// node_modules/execa/lib/return/duration.js
import {hrtime} from "node:process";
var getStartTime = () => hrtime.bigint();
var getDurationMs = (startTime) => Number(hrtime.bigint() - startTime) / 1e6;

// node_modules/execa/lib/arguments/command.js
var handleCommand = (filePath, rawArguments, rawOptions) => {
  const startTime = getStartTime();
  const { command, escapedCommand } = joinCommand(filePath, rawArguments);
  const verbose = normalizeFdSpecificOption(rawOptions, "verbose");
  const verboseInfo = getVerboseInfo(verbose, escapedCommand, { ...rawOptions });
  logCommand(escapedCommand, verboseInfo);
  return {
    command,
    escapedCommand,
    startTime,
    verboseInfo
  };
};

// node_modules/execa/lib/arguments/options.js
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import path4 from "node:path";
import process6 from "node:process";

// node_modules/npm-run-path/index.js
import process4 from "node:process";
import path from "node:path";
import {fileURLToPath as fileURLToPath2} from "node:url";

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env = process.env,
    platform: platform2 = process.platform
  } = options;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(env).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/npm-run-path/index.js
var npmRunPath = ({
  cwd = process4.cwd(),
  path: pathOption = process4.env[pathKey()],
  preferLocal = true,
  execPath = process4.execPath,
  addExecPath = true
} = {}) => {
  const cwdString = cwd instanceof URL ? fileURLToPath2(cwd) : cwd;
  const cwdPath = path.resolve(cwdString);
  const result = [];
  if (preferLocal) {
    applyPreferLocal(result, cwdPath);
  }
  if (addExecPath) {
    applyExecPath(result, execPath, cwdPath);
  }
  return [...result, pathOption].join(path.delimiter);
};
var applyPreferLocal = (result, cwdPath) => {
  let previous;
  while (previous !== cwdPath) {
    result.push(path.join(cwdPath, "node_modules/.bin"));
    previous = cwdPath;
    cwdPath = path.resolve(cwdPath, "..");
  }
};
var applyExecPath = (result, execPath, cwdPath) => {
  const execPathString = execPath instanceof URL ? fileURLToPath2(execPath) : execPath;
  result.push(path.resolve(cwdPath, execPathString, ".."));
};
var npmRunPathEnv = ({ env = process4.env, ...options } = {}) => {
  env = { ...env };
  const pathName = pathKey({ env });
  options.path = env[pathName];
  env[pathName] = npmRunPath(options);
  return env;
};

// node_modules/execa/lib/terminate/kill.js
import {setTimeout as setTimeout2} from "node:timers/promises";

// node_modules/execa/lib/return/final-error.js
var getFinalError = (originalError, message, isSync) => {
  const ErrorClass = isSync ? ExecaSyncError : ExecaError;
  const options = originalError instanceof DiscardedError ? {} : { cause: originalError };
  return new ErrorClass(message, options);
};

class DiscardedError extends Error {
}
var setErrorName = (ErrorClass, value) => {
  Object.defineProperty(ErrorClass.prototype, "name", {
    value,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var isExecaError = (error) => isErrorInstance(error) && (execaErrorSymbol in error);
var execaErrorSymbol = Symbol("isExecaError");
var isErrorInstance = (value) => Object.prototype.toString.call(value) === "[object Error]";

class ExecaError extends Error {
}
setErrorName(ExecaError, ExecaError.name);

class ExecaSyncError extends Error {
}
setErrorName(ExecaSyncError, ExecaSyncError.name);

// node_modules/execa/lib/terminate/signal.js
import {constants as constants3} from "node:os";

// node_modules/human-signals/build/src/main.js
import {constants as constants2} from "node:os";

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
};
var getRealtimeSignal = (value, index) => ({
  name: `SIGRT${index + 1}`,
  number: SIGRTMIN + index,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
import {constants} from "node:os";

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: "Paused using CTRL-Z or \"suspend\"",
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals;
};
var normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = constants;
  const supported = constantSignal !== undefined;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  const signals2 = getSignals();
  return Object.fromEntries(signals2.map(getSignalByName));
};
var getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }];
var signalsByName = getSignalsByName();
var getSignalsByNumber = () => {
  const signals2 = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals2));
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = (number, signals2) => {
  const signal = findSignalByNumber(number, signals2);
  if (signal === undefined) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = (number, signals2) => {
  const signal = signals2.find(({ name }) => constants2.signals[name] === number);
  if (signal !== undefined) {
    return signal;
  }
  return signals2.find((signalA) => signalA.number === number);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/terminate/signal.js
var normalizeKillSignal = (killSignal) => {
  const optionName = "option `killSignal`";
  if (killSignal === 0) {
    throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
  }
  return normalizeSignal2(killSignal, optionName);
};
var normalizeSignalArgument = (signal) => signal === 0 ? signal : normalizeSignal2(signal, "`subprocess.kill()`\'s argument");
var normalizeSignal2 = (signalNameOrInteger, optionName) => {
  if (Number.isInteger(signalNameOrInteger)) {
    return normalizeSignalInteger(signalNameOrInteger, optionName);
  }
  if (typeof signalNameOrInteger === "string") {
    return normalizeSignalName(signalNameOrInteger, optionName);
  }
  throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\n${getAvailableSignals()}`);
};
var normalizeSignalInteger = (signalInteger, optionName) => {
  if (signalsIntegerToName.has(signalInteger)) {
    return signalsIntegerToName.get(signalInteger);
  }
  throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\n${getAvailableSignals()}`);
};
var getSignalsIntegerToName = () => new Map(Object.entries(constants3.signals).reverse().map(([signalName, signalInteger]) => [signalInteger, signalName]));
var signalsIntegerToName = getSignalsIntegerToName();
var normalizeSignalName = (signalName, optionName) => {
  if (signalName in constants3.signals) {
    return signalName;
  }
  if (signalName.toUpperCase() in constants3.signals) {
    throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
  }
  throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\n${getAvailableSignals()}`);
};
var getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
var getAvailableSignalNames = () => Object.keys(constants3.signals).sort().map((signalName) => `'${signalName}'`).join(", ");
var getAvailableSignalIntegers = () => [...new Set(Object.values(constants3.signals).sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))].join(", ");
var getSignalDescription = (signal) => signalsByName[signal].description;

// node_modules/execa/lib/terminate/kill.js
var normalizeForceKillAfterDelay = (forceKillAfterDelay) => {
  if (forceKillAfterDelay === false) {
    return forceKillAfterDelay;
  }
  if (forceKillAfterDelay === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
    throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
  }
  return forceKillAfterDelay;
};
var DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
var subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context, controller }, signalOrError, errorArgument) => {
  const { signal: signal2, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
  emitKillError(error, onInternalError);
  const killResult = kill(signal2);
  setKillTimeout({
    kill,
    signal: signal2,
    forceKillAfterDelay,
    killSignal,
    killResult,
    context,
    controller
  });
  return killResult;
};
var parseKillArguments = (signalOrError, errorArgument, killSignal) => {
  const [signal2 = killSignal, error] = isErrorInstance(signalOrError) ? [undefined, signalOrError] : [signalOrError, errorArgument];
  if (typeof signal2 !== "string" && !Number.isInteger(signal2)) {
    throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal2)}`);
  }
  if (error !== undefined && !isErrorInstance(error)) {
    throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
  }
  return { signal: normalizeSignalArgument(signal2), error };
};
var emitKillError = (error, onInternalError) => {
  if (error !== undefined) {
    onInternalError.reject(error);
  }
};
var setKillTimeout = async ({ kill, signal: signal2, forceKillAfterDelay, killSignal, killResult, context, controller }) => {
  if (signal2 === killSignal && killResult) {
    killOnTimeout({
      kill,
      forceKillAfterDelay,
      context,
      controllerSignal: controller.signal
    });
  }
};
var killOnTimeout = async ({ kill, forceKillAfterDelay, context, controllerSignal }) => {
  if (forceKillAfterDelay === false) {
    return;
  }
  try {
    await setTimeout2(forceKillAfterDelay, undefined, { signal: controllerSignal });
    if (kill("SIGKILL")) {
      context.isForcefullyTerminated ??= true;
    }
  } catch {
  }
};

// node_modules/execa/lib/utils/abort-signal.js
import {once} from "node:events";
var onAbortedSignal = async (mainSignal, stopSignal) => {
  if (!mainSignal.aborted) {
    await once(mainSignal, "abort", { signal: stopSignal });
  }
};

// node_modules/execa/lib/terminate/cancel.js
var validateCancelSignal = ({ cancelSignal }) => {
  if (cancelSignal !== undefined && Object.prototype.toString.call(cancelSignal) !== "[object AbortSignal]") {
    throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
  }
};
var throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context, controller }) => cancelSignal === undefined || gracefulCancel ? [] : [terminateOnCancel(subprocess, cancelSignal, context, controller)];
var terminateOnCancel = async (subprocess, cancelSignal, context, { signal: signal2 }) => {
  await onAbortedSignal(cancelSignal, signal2);
  context.terminationReason ??= "cancel";
  subprocess.kill();
  throw cancelSignal.reason;
};

// node_modules/execa/lib/ipc/graceful.js
import {scheduler as scheduler2} from "node:timers/promises";

// node_modules/execa/lib/ipc/send.js
import {promisify} from "node:util";

// node_modules/execa/lib/ipc/validation.js
var validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected }) => {
  validateIpcOption(methodName, isSubprocess, ipc);
  validateConnection(methodName, isSubprocess, isConnected);
};
var validateIpcOption = (methodName, isSubprocess, ipc) => {
  if (!ipc) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
  }
};
var validateConnection = (methodName, isSubprocess, isConnected) => {
  if (!isConnected) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
  }
};
var throwOnEarlyDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("getOneMessage", isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};
var throwOnStrictDeadlockError = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName("getOneMessage", isSubprocess)},
	${getMethodName("sendMessage", isSubprocess, "message, {strict: true}")},
]);`);
};
var getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName("sendMessage", isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, { cause: error });
var throwOnMissingStrict = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};
var throwOnStrictDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};
var getAbortDisconnectError = () => new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
var throwOnMissingParent = () => {
  throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.");
};
var handleEpipeError = ({ error, methodName, isSubprocess }) => {
  if (error.code === "EPIPE") {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, { cause: error });
  }
};
var handleSerializationError = ({ error, methodName, isSubprocess, message }) => {
  if (isSerializationError(error)) {
    throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, { cause: error });
  }
};
var isSerializationError = ({ code, message }) => SERIALIZATION_ERROR_CODES.has(code) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage) => message.includes(serializationErrorMessage));
var SERIALIZATION_ERROR_CODES = new Set([
  "ERR_MISSING_ARGS",
  "ERR_INVALID_ARG_TYPE"
]);
var SERIALIZATION_ERROR_MESSAGES = [
  "could not be cloned",
  "circular structure",
  "call stack size exceeded"
];
var getMethodName = (methodName, isSubprocess, parameters = "") => methodName === "cancelSignal" ? "`cancelSignal`\'s `controller.abort()`" : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
var getNamespaceName = (isSubprocess) => isSubprocess ? "" : "subprocess.";
var getOtherProcessName = (isSubprocess) => isSubprocess ? "parent process" : "subprocess";
var disconnect = (anyProcess) => {
  if (anyProcess.connected) {
    anyProcess.disconnect();
  }
};

// node_modules/execa/lib/utils/deferred.js
var createDeferred = () => {
  const methods = {};
  const promise = new Promise((resolve, reject) => {
    Object.assign(methods, { resolve, reject });
  });
  return Object.assign(promise, methods);
};

// node_modules/execa/lib/arguments/fd-options.js
var getToStream = (destination, to = "stdin") => {
  const isWritable = true;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
  const fdNumber = getFdNumber(fileDescriptors, to, isWritable);
  const destinationStream = destination.stdio[fdNumber];
  if (destinationStream === null) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));
  }
  return destinationStream;
};
var getFromStream = (source, from = "stdout") => {
  const isWritable = false;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  const fdNumber = getFdNumber(fileDescriptors, from, isWritable);
  const sourceStream = fdNumber === "all" ? source.all : source.stdio[fdNumber];
  if (sourceStream === null || sourceStream === undefined) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));
  }
  return sourceStream;
};
var SUBPROCESS_OPTIONS = new WeakMap;
var getFdNumber = (fileDescriptors, fdName, isWritable) => {
  const fdNumber = parseFdNumber(fdName, isWritable);
  validateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);
  return fdNumber;
};
var parseFdNumber = (fdName, isWritable) => {
  const fdNumber = parseFd(fdName);
  if (fdNumber !== undefined) {
    return fdNumber;
  }
  const { validOptions, defaultValue } = isWritable ? { validOptions: '"stdin"', defaultValue: "stdin" } : { validOptions: '"stdout", "stderr", "all"', defaultValue: "stdout" };
  throw new TypeError(`"${getOptionName(isWritable)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};
var validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {
  const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
  if (fileDescriptor === undefined) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  if (fileDescriptor.direction === "input" && !isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a readable stream, not writable.`);
  }
  if (fileDescriptor.direction !== "input" && isWritable) {
    throw new TypeError(`"${getOptionName(isWritable)}" must not be ${fdName}. It must be a writable stream, not readable.`);
  }
};
var getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {
  if (fdNumber === "all" && !options.all) {
    return 'The "all" option must be true to use "from: \'all\'".';
  }
  const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
  return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};
var getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio }) => {
  const usedDescriptor = getUsedDescriptor(fdNumber);
  if (usedDescriptor === 0 && stdin !== undefined) {
    return { optionName: "stdin", optionValue: stdin };
  }
  if (usedDescriptor === 1 && stdout !== undefined) {
    return { optionName: "stdout", optionValue: stdout };
  }
  if (usedDescriptor === 2 && stderr !== undefined) {
    return { optionName: "stderr", optionValue: stderr };
  }
  return { optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor] };
};
var getUsedDescriptor = (fdNumber) => fdNumber === "all" ? 1 : fdNumber;
var getOptionName = (isWritable) => isWritable ? "to" : "from";
var serializeOptionValue = (value) => {
  if (typeof value === "string") {
    return `'${value}'`;
  }
  return typeof value === "number" ? `${value}` : "Stream";
};

// node_modules/execa/lib/ipc/strict.js
import {once as once3} from "node:events";

// node_modules/execa/lib/utils/max-listeners.js
import {addAbortListener} from "node:events";
var incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal2) => {
  const maxListeners = eventEmitter.getMaxListeners();
  if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
    return;
  }
  eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
  addAbortListener(signal2, () => {
    eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
  });
};

// node_modules/execa/lib/ipc/forward.js
import {EventEmitter} from "node:events";

// node_modules/execa/lib/ipc/incoming.js
import {once as once2} from "node:events";
import {scheduler} from "node:timers/promises";

// node_modules/execa/lib/ipc/reference.js
var addReference = (channel, reference) => {
  if (reference) {
    addReferenceCount(channel);
  }
};
var addReferenceCount = (channel) => {
  channel.refCounted();
};
var removeReference = (channel, reference) => {
  if (reference) {
    removeReferenceCount(channel);
  }
};
var removeReferenceCount = (channel) => {
  channel.unrefCounted();
};
var undoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    removeReferenceCount(channel);
    removeReferenceCount(channel);
  }
};
var redoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    addReferenceCount(channel);
    addReferenceCount(channel);
  }
};

// node_modules/execa/lib/ipc/incoming.js
var onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage) => {
  if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {
    return;
  }
  if (!INCOMING_MESSAGES.has(anyProcess)) {
    INCOMING_MESSAGES.set(anyProcess, []);
  }
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  incomingMessages.push(wrappedMessage);
  if (incomingMessages.length > 1) {
    return;
  }
  while (incomingMessages.length > 0) {
    await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
    await scheduler.yield();
    const message = await handleStrictRequest({
      wrappedMessage: incomingMessages[0],
      anyProcess,
      channel,
      isSubprocess,
      ipcEmitter
    });
    incomingMessages.shift();
    ipcEmitter.emit("message", message);
    ipcEmitter.emit("message:done");
  }
};
var onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage }) => {
  abortOnDisconnect();
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  while (incomingMessages?.length > 0) {
    await once2(ipcEmitter, "message:done");
  }
  anyProcess.removeListener("message", boundOnMessage);
  redoAddedReferences(channel, isSubprocess);
  ipcEmitter.connected = false;
  ipcEmitter.emit("disconnect");
};
var INCOMING_MESSAGES = new WeakMap;

// node_modules/execa/lib/ipc/forward.js
var getIpcEmitter = (anyProcess, channel, isSubprocess) => {
  if (IPC_EMITTERS.has(anyProcess)) {
    return IPC_EMITTERS.get(anyProcess);
  }
  const ipcEmitter = new EventEmitter;
  ipcEmitter.connected = true;
  IPC_EMITTERS.set(anyProcess, ipcEmitter);
  forwardEvents({
    ipcEmitter,
    anyProcess,
    channel,
    isSubprocess
  });
  return ipcEmitter;
};
var IPC_EMITTERS = new WeakMap;
var forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess }) => {
  const boundOnMessage = onMessage.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter
  });
  anyProcess.on("message", boundOnMessage);
  anyProcess.once("disconnect", onDisconnect.bind(undefined, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter,
    boundOnMessage
  }));
  undoAddedReferences(channel, isSubprocess);
};
var isConnected = (anyProcess) => {
  const ipcEmitter = IPC_EMITTERS.get(anyProcess);
  return ipcEmitter === undefined ? anyProcess.channel !== null : ipcEmitter.connected;
};

// node_modules/execa/lib/ipc/strict.js
var handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict: strict2 }) => {
  if (!strict2) {
    return message;
  }
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
  return {
    id: count++,
    type: REQUEST_TYPE,
    message,
    hasListeners
  };
};
var count = 0n;
var validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
    return;
  }
  for (const { id } of outgoingMessages) {
    if (id !== undefined) {
      STRICT_RESPONSES[id].resolve({ isDeadlock: true, hasListeners: false });
    }
  }
};
var handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter }) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
    return wrappedMessage;
  }
  const { id, message } = wrappedMessage;
  const response = { id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter) };
  try {
    await sendMessage({
      anyProcess,
      channel,
      isSubprocess,
      ipc: true
    }, response);
  } catch (error) {
    ipcEmitter.emit("strict:error", error);
  }
  return message;
};
var handleStrictResponse = (wrappedMessage) => {
  if (wrappedMessage?.type !== RESPONSE_TYPE) {
    return false;
  }
  const { id, message: hasListeners } = wrappedMessage;
  STRICT_RESPONSES[id]?.resolve({ isDeadlock: false, hasListeners });
  return true;
};
var waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
  if (wrappedMessage?.type !== REQUEST_TYPE) {
    return;
  }
  const deferred2 = createDeferred();
  STRICT_RESPONSES[wrappedMessage.id] = deferred2;
  const controller = new AbortController;
  try {
    const { isDeadlock, hasListeners } = await Promise.race([
      deferred2,
      throwOnDisconnect(anyProcess, isSubprocess, controller)
    ]);
    if (isDeadlock) {
      throwOnStrictDeadlockError(isSubprocess);
    }
    if (!hasListeners) {
      throwOnMissingStrict(isSubprocess);
    }
  } finally {
    controller.abort();
    delete STRICT_RESPONSES[wrappedMessage.id];
  }
};
var STRICT_RESPONSES = {};
var throwOnDisconnect = async (anyProcess, isSubprocess, { signal: signal2 }) => {
  incrementMaxListeners(anyProcess, 1, signal2);
  await once3(anyProcess, "disconnect", { signal: signal2 });
  throwOnStrictDisconnect(isSubprocess);
};
var REQUEST_TYPE = "execa:ipc:request";
var RESPONSE_TYPE = "execa:ipc:response";

// node_modules/execa/lib/ipc/outgoing.js
var startSendMessage = (anyProcess, wrappedMessage, strict3) => {
  if (!OUTGOING_MESSAGES.has(anyProcess)) {
    OUTGOING_MESSAGES.set(anyProcess, new Set);
  }
  const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
  const onMessageSent = createDeferred();
  const id = strict3 ? wrappedMessage.id : undefined;
  const outgoingMessage = { onMessageSent, id };
  outgoingMessages.add(outgoingMessage);
  return { outgoingMessages, outgoingMessage };
};
var endSendMessage = ({ outgoingMessages, outgoingMessage }) => {
  outgoingMessages.delete(outgoingMessage);
  outgoingMessage.onMessageSent.resolve();
};
var waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
  while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
    const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
    validateStrictDeadlock(outgoingMessages, wrappedMessage);
    await Promise.all(outgoingMessages.map(({ onMessageSent }) => onMessageSent));
  }
};
var OUTGOING_MESSAGES = new WeakMap;
var hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount("message") > getMinListenerCount(anyProcess);
var getMinListenerCount = (anyProcess) => SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, "ipc") ? 1 : 0;

// node_modules/execa/lib/ipc/send.js
var sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict: strict4 = false } = {}) => {
  const methodName = "sendMessage";
  validateIpcMethod({
    methodName,
    isSubprocess,
    ipc,
    isConnected: anyProcess.connected
  });
  return sendMessageAsync({
    anyProcess,
    channel,
    methodName,
    isSubprocess,
    message,
    strict: strict4
  });
};
var sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict: strict4 }) => {
  const wrappedMessage = handleSendStrict({
    anyProcess,
    channel,
    isSubprocess,
    message,
    strict: strict4
  });
  const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict4);
  try {
    await sendOneMessage({
      anyProcess,
      methodName,
      isSubprocess,
      wrappedMessage,
      message
    });
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    endSendMessage(outgoingMessagesState);
  }
};
var sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message }) => {
  const sendMethod = getSendMethod(anyProcess);
  try {
    await Promise.all([
      waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
      sendMethod(wrappedMessage)
    ]);
  } catch (error) {
    handleEpipeError({ error, methodName, isSubprocess });
    handleSerializationError({
      error,
      methodName,
      isSubprocess,
      message
    });
    throw error;
  }
};
var getSendMethod = (anyProcess) => {
  if (PROCESS_SEND_METHODS.has(anyProcess)) {
    return PROCESS_SEND_METHODS.get(anyProcess);
  }
  const sendMethod = promisify(anyProcess.send.bind(anyProcess));
  PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
  return sendMethod;
};
var PROCESS_SEND_METHODS = new WeakMap;

// node_modules/execa/lib/ipc/graceful.js
var sendAbort = (subprocess, message) => {
  const methodName = "cancelSignal";
  validateConnection(methodName, false, subprocess.connected);
  return sendOneMessage({
    anyProcess: subprocess,
    methodName,
    isSubprocess: false,
    wrappedMessage: { type: GRACEFUL_CANCEL_TYPE, message },
    message
  });
};
var getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  await startIpc({
    anyProcess,
    channel,
    isSubprocess,
    ipc
  });
  return cancelController.signal;
};
var startIpc = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  if (cancelListening) {
    return;
  }
  cancelListening = true;
  if (!ipc) {
    throwOnMissingParent();
    return;
  }
  if (channel === null) {
    abortOnDisconnect();
    return;
  }
  getIpcEmitter(anyProcess, channel, isSubprocess);
  await scheduler2.yield();
};
var cancelListening = false;
var handleAbort = (wrappedMessage) => {
  if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
    return false;
  }
  cancelController.abort(wrappedMessage.message);
  return true;
};
var GRACEFUL_CANCEL_TYPE = "execa:ipc:cancel";
var abortOnDisconnect = () => {
  cancelController.abort(getAbortDisconnectError());
};
var cancelController = new AbortController;

// node_modules/execa/lib/terminate/graceful.js
var validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization }) => {
  if (!gracefulCancel) {
    return;
  }
  if (cancelSignal === undefined) {
    throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");
  }
  if (!ipc) {
    throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");
  }
  if (serialization === "json") {
    throw new Error("The `serialization` option cannot be \'json\' when setting the `gracefulCancel` option.");
  }
};
var throwOnGracefulCancel = ({
  subprocess,
  cancelSignal,
  gracefulCancel,
  forceKillAfterDelay,
  context,
  controller
}) => gracefulCancel ? [sendOnAbort({
  subprocess,
  cancelSignal,
  forceKillAfterDelay,
  context,
  controller
})] : [];
var sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal: signal2 } }) => {
  await onAbortedSignal(cancelSignal, signal2);
  const reason = getReason(cancelSignal);
  await sendAbort(subprocess, reason);
  killOnTimeout({
    kill: subprocess.kill,
    forceKillAfterDelay,
    context,
    controllerSignal: signal2
  });
  context.terminationReason ??= "gracefulCancel";
  throw cancelSignal.reason;
};
var getReason = ({ reason }) => {
  if (!(reason instanceof DOMException)) {
    return reason;
  }
  const error = new Error(reason.message);
  Object.defineProperty(error, "stack", {
    value: reason.stack,
    enumerable: false,
    configurable: true,
    writable: true
  });
  return error;
};

// node_modules/execa/lib/terminate/timeout.js
import {setTimeout as setTimeout3} from "node:timers/promises";
var validateTimeout = ({ timeout }) => {
  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined ? [] : [killAfterTimeout(subprocess, timeout, context, controller)];
var killAfterTimeout = async (subprocess, timeout, context, { signal: signal2 }) => {
  await setTimeout3(timeout, undefined, { signal: signal2 });
  context.terminationReason ??= "timeout";
  subprocess.kill();
  throw new DiscardedError;
};

// node_modules/execa/lib/methods/node.js
import {execPath, execArgv} from "node:process";
import path2 from "node:path";
var mapNode = ({ options }) => {
  if (options.node === false) {
    throw new TypeError('The "node" option cannot be false with `execaNode()`.');
  }
  return { options: { ...options, node: true } };
};
var handleNodeOption = (file, commandArguments, {
  node: shouldHandleNode = false,
  nodePath = execPath,
  nodeOptions = execArgv.filter((nodeOption) => !nodeOption.startsWith("--inspect")),
  cwd,
  execPath: formerNodePath,
  ...options
}) => {
  if (formerNodePath !== undefined) {
    throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
  }
  const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
  const resolvedNodePath = path2.resolve(cwd, normalizedNodePath);
  const newOptions = {
    ...options,
    nodePath: resolvedNodePath,
    node: shouldHandleNode,
    cwd
  };
  if (!shouldHandleNode) {
    return [file, commandArguments, newOptions];
  }
  if (path2.basename(file, ".exe") === "node") {
    throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
  }
  return [
    resolvedNodePath,
    [...nodeOptions, file, ...commandArguments],
    { ipc: true, ...newOptions, shell: false }
  ];
};

// node_modules/execa/lib/ipc/ipc-input.js
import {serialize} from "node:v8";
var validateIpcInputOption = ({ ipcInput, ipc, serialization }) => {
  if (ipcInput === undefined) {
    return;
  }
  if (!ipc) {
    throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");
  }
  validateIpcInput[serialization](ipcInput);
};
var validateAdvancedInput = (ipcInput) => {
  try {
    serialize(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with a structured clone.", { cause: error });
  }
};
var validateJsonInput = (ipcInput) => {
  try {
    JSON.stringify(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with JSON.", { cause: error });
  }
};
var validateIpcInput = {
  advanced: validateAdvancedInput,
  json: validateJsonInput
};
var sendIpcInput = async (subprocess, ipcInput) => {
  if (ipcInput === undefined) {
    return;
  }
  await subprocess.sendMessage(ipcInput);
};

// node_modules/execa/lib/arguments/encoding-option.js
var validateEncoding = ({ encoding }) => {
  if (ENCODINGS.has(encoding)) {
    return;
  }
  const correctEncoding = getCorrectEncoding(encoding);
  if (correctEncoding !== undefined) {
    throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
  }
  const correctEncodings = [...ENCODINGS].map((correctEncoding2) => serializeEncoding(correctEncoding2)).join(", ");
  throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};
var TEXT_ENCODINGS = new Set(["utf8", "utf16le"]);
var BINARY_ENCODINGS = new Set(["buffer", "hex", "base64", "base64url", "latin1", "ascii"]);
var ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);
var getCorrectEncoding = (encoding) => {
  if (encoding === null) {
    return "buffer";
  }
  if (typeof encoding !== "string") {
    return;
  }
  const lowerEncoding = encoding.toLowerCase();
  if (lowerEncoding in ENCODING_ALIASES) {
    return ENCODING_ALIASES[lowerEncoding];
  }
  if (ENCODINGS.has(lowerEncoding)) {
    return lowerEncoding;
  }
};
var ENCODING_ALIASES = {
  "utf-8": "utf8",
  "utf-16le": "utf16le",
  "ucs-2": "utf16le",
  ucs2: "utf16le",
  binary: "latin1"
};
var serializeEncoding = (encoding) => typeof encoding === "string" ? `"${encoding}"` : String(encoding);

// node_modules/execa/lib/arguments/cwd.js
import {statSync} from "node:fs";
import path3 from "node:path";
import process5 from "node:process";
var normalizeCwd = (cwd = getDefaultCwd()) => {
  const cwdString = safeNormalizeFileUrl(cwd, 'The "cwd" option');
  return path3.resolve(cwdString);
};
var getDefaultCwd = () => {
  try {
    return process5.cwd();
  } catch (error) {
    error.message = `The current directory does not exist.\n${error.message}`;
    throw error;
  }
};
var fixCwdError = (originalMessage, cwd) => {
  if (cwd === getDefaultCwd()) {
    return originalMessage;
  }
  let cwdStat;
  try {
    cwdStat = statSync(cwd);
  } catch (error) {
    return `The "cwd" option is invalid: ${cwd}.\n${error.message}\n${originalMessage}`;
  }
  if (!cwdStat.isDirectory()) {
    return `The "cwd" option is not a directory: ${cwd}.\n${originalMessage}`;
  }
  return originalMessage;
};

// node_modules/execa/lib/arguments/options.js
var normalizeOptions = (filePath, rawArguments, rawOptions) => {
  rawOptions.cwd = normalizeCwd(rawOptions.cwd);
  const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
  const { command: file, args: commandArguments, options: initialOptions } = import_cross_spawn.default._parse(processedFile, processedArguments, processedOptions);
  const fdOptions = normalizeFdSpecificOptions(initialOptions);
  const options = addDefaultOptions(fdOptions);
  validateTimeout(options);
  validateEncoding(options);
  validateIpcInputOption(options);
  validateCancelSignal(options);
  validateGracefulCancel(options);
  options.shell = normalizeFileUrl(options.shell);
  options.env = getEnv(options);
  options.killSignal = normalizeKillSignal(options.killSignal);
  options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
  options.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
  if (process6.platform === "win32" && path4.basename(file, ".exe") === "cmd") {
    commandArguments.unshift("/q");
  }
  return { file, commandArguments, options };
};
var addDefaultOptions = ({
  extendEnv = true,
  preferLocal = false,
  cwd: cwd2,
  localDir: localDirectory = cwd2,
  encoding = "utf8",
  reject = true,
  cleanup = true,
  all = false,
  windowsHide = true,
  killSignal = "SIGTERM",
  forceKillAfterDelay = true,
  gracefulCancel = false,
  ipcInput,
  ipc = ipcInput !== undefined || gracefulCancel,
  serialization = "advanced",
  ...options
}) => ({
  ...options,
  extendEnv,
  preferLocal,
  cwd: cwd2,
  localDirectory,
  encoding,
  reject,
  cleanup,
  all,
  windowsHide,
  killSignal,
  forceKillAfterDelay,
  gracefulCancel,
  ipcInput,
  ipc,
  serialization
});
var getEnv = ({ env: envOption, extendEnv, preferLocal, node: node2, localDirectory, nodePath }) => {
  const env = extendEnv ? { ...process6.env, ...envOption } : envOption;
  if (preferLocal || node2) {
    return npmRunPathEnv({
      env,
      cwd: localDirectory,
      execPath: nodePath,
      preferLocal,
      addExecPath: node2
    });
  }
  return env;
};

// node_modules/execa/lib/return/message.js
import {inspect as inspect2} from "node:util";

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  if (typeof input === "string") {
    return stripFinalNewlineString(input);
  }
  if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {
    throw new Error("Input must be a string or a Uint8Array");
  }
  return stripFinalNewlineBinary(input);
}
var stripFinalNewlineString = (input) => input.at(-1) === LF ? input.slice(0, input.at(-2) === CR ? -2 : -1) : input;
var stripFinalNewlineBinary = (input) => input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input;
var LF = "\n";
var LF_BINARY = LF.codePointAt(0);
var CR = "\r";
var CR_BINARY = CR.codePointAt(0);

// node_modules/get-stream/source/index.js
import {on} from "node:events";
import {finished} from "node:stream/promises";

// node_modules/is-stream/index.js
function isStream(stream, { checkOpen = true } = {}) {
  return stream !== null && typeof stream === "object" && (stream.writable || stream.readable || !checkOpen || stream.writable === undefined && stream.readable === undefined) && typeof stream.pipe === "function";
}
function isWritableStream(stream, { checkOpen = true } = {}) {
  return isStream(stream, { checkOpen }) && (stream.writable || !checkOpen) && typeof stream.write === "function" && typeof stream.end === "function" && typeof stream.writable === "boolean" && typeof stream.writableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
}
function isReadableStream(stream, { checkOpen = true } = {}) {
  return isStream(stream, { checkOpen }) && (stream.readable || !checkOpen) && typeof stream.read === "function" && typeof stream.readable === "boolean" && typeof stream.readableObjectMode === "boolean" && typeof stream.destroy === "function" && typeof stream.destroyed === "boolean";
}
function isDuplexStream(stream, options) {
  return isWritableStream(stream, options) && isReadableStream(stream, options);
}

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
function i() {
  return this[n].next();
}
function o(r) {
  return this[n].return(r);
}
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(e, r), s = Object.create(u);
  return s[n] = t, s;
}
var a = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}).prototype);

class c {
  #t;
  #n;
  #r = false;
  #e = undefined;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = () => this.#i(e);
    return this.#e ? this.#e.then(t, t) : t();
  }
  async#s() {
    if (this.#r)
      return {
        done: true,
        value: undefined
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = undefined, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = undefined, this.#r = true, this.#t.releaseLock()), e;
  }
  async#i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
}
var n = Symbol();
Object.defineProperty(i, "name", { value: "next" });
Object.defineProperty(o, "name", { value: "return" });
var u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});

// node_modules/get-stream/source/stream.js
var getAsyncIterable = (stream) => {
  if (isReadableStream(stream, { checkOpen: false }) && nodeImports.on !== undefined) {
    return getStreamIterable(stream);
  }
  if (typeof stream?.[Symbol.asyncIterator] === "function") {
    return stream;
  }
  if (toString.call(stream) === "[object ReadableStream]") {
    return h.call(stream);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
};
var { toString } = Object.prototype;
var getStreamIterable = async function* (stream) {
  const controller = new AbortController;
  const state = {};
  handleStreamEnd(stream, controller, state);
  try {
    for await (const [chunk] of nodeImports.on(stream, "data", { signal: controller.signal })) {
      yield chunk;
    }
  } catch (error) {
    if (state.error !== undefined) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    stream.destroy();
  }
};
var handleStreamEnd = async (stream, controller, state) => {
  try {
    await nodeImports.finished(stream, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error) {
    state.error = error;
  } finally {
    controller.abort();
  }
};
var nodeImports = {};

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream2, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream2);
  const state = init();
  state.length = 0;
  try {
    for await (const chunk of asyncIterable) {
      const chunkType = getChunkType(chunk);
      const convertedChunk = convertChunk[chunkType](chunk, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error) {
    const normalizedError = typeof error === "object" && error !== null ? error : new Error(error);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
};
var appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== undefined) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
};
var appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== undefined) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError;
};
var addNewChunk = (convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
};
var getChunkType = (chunk) => {
  const typeOfChunk = typeof chunk;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk)) {
    return "buffer";
  }
  const prototypeName = objectToString2.call(chunk);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString2.call(chunk.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
};
var { toString: objectToString2 } = Object.prototype;

class MaxBufferError extends Error {
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
}

// node_modules/get-stream/source/utils.js
var identity2 = (value) => value;
var noop = () => {
  return;
};
var getContentsProperty = ({ contents }) => contents;
var throwObjectStream = (chunk) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
var getLengthProperty = (convertedChunk) => convertedChunk.length;

// node_modules/get-stream/source/array.js
async function getStreamAsArray(stream2, options) {
  return getStreamContents(stream2, arrayMethods, options);
}
var initArray = () => ({ contents: [] });
var increment = () => 1;
var addArrayChunk = (convertedChunk, { contents: contents2 }) => {
  contents2.push(convertedChunk);
  return contents2;
};
var arrayMethods = {
  init: initArray,
  convertChunk: {
    string: identity2,
    buffer: identity2,
    arrayBuffer: identity2,
    dataView: identity2,
    typedArray: identity2,
    others: identity2
  },
  getSize: increment,
  truncateChunk: noop,
  addChunk: addArrayChunk,
  getFinalChunk: noop,
  finalize: getContentsProperty
};
// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream2, options) {
  return getStreamContents(stream2, arrayBufferMethods, options);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
var useTextEncoder = (chunk) => textEncoder2.encode(chunk);
var textEncoder2 = new TextEncoder;
var useUint8Array = (chunk) => new Uint8Array(chunk);
var useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
var truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var addArrayBufferChunk = (convertedChunk, { contents: contents3, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents3, length) : resizeArrayBufferSlow(contents3, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
};
var resizeArrayBufferSlow = (contents3, length) => {
  if (length <= contents3.byteLength) {
    return contents3;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents3), 0);
  return arrayBuffer;
};
var resizeArrayBuffer = (contents3, length) => {
  if (length <= contents3.maxByteLength) {
    contents3.resize(length);
    return contents3;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents3), 0);
  return arrayBuffer;
};
var getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = ({ contents: contents3, length }) => hasArrayBufferResize() ? contents3 : contents3.slice(0, length);
var hasArrayBufferResize = () => ("resize" in ArrayBuffer.prototype);
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop,
  finalize: finalizeArrayBuffer
};
// node_modules/get-stream/source/string.js
async function getStreamAsString(stream2, options) {
  return getStreamContents(stream2, stringMethods, options);
}
var initString = () => ({ contents: "", textDecoder: new TextDecoder });
var useTextDecoder = (chunk, { textDecoder: textDecoder2 }) => textDecoder2.decode(chunk, { stream: true });
var addStringChunk = (convertedChunk, { contents: contents4 }) => contents4 + convertedChunk;
var truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var getFinalStringChunk = ({ textDecoder: textDecoder2 }) => {
  const finalChunk = textDecoder2.decode();
  return finalChunk === "" ? undefined : finalChunk;
};
var stringMethods = {
  init: initString,
  convertChunk: {
    string: identity2,
    buffer: useTextDecoder,
    arrayBuffer: useTextDecoder,
    dataView: useTextDecoder,
    typedArray: useTextDecoder,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateStringChunk,
  addChunk: addStringChunk,
  getFinalChunk: getFinalStringChunk,
  finalize: getContentsProperty
};
// node_modules/get-stream/source/index.js
Object.assign(nodeImports, { on, finished });

// node_modules/execa/lib/io/max-buffer.js
var handleMaxBuffer = ({ error, stream: stream3, readableObjectMode, lines, encoding, fdNumber }) => {
  if (!(error instanceof MaxBufferError)) {
    throw error;
  }
  if (fdNumber === "all") {
    return error;
  }
  const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
  error.maxBufferInfo = { fdNumber, unit };
  stream3.destroy();
  throw error;
};
var getMaxBufferUnit = (readableObjectMode, lines, encoding) => {
  if (readableObjectMode) {
    return "objects";
  }
  if (lines) {
    return "lines";
  }
  if (encoding === "buffer") {
    return "bytes";
  }
  return "characters";
};
var checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
  if (ipcOutput.length !== maxBuffer) {
    return;
  }
  const error = new MaxBufferError;
  error.maxBufferInfo = { fdNumber: "ipc" };
  throw error;
};
var getMaxBufferMessage = (error, maxBuffer) => {
  const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
  return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};
var getMaxBufferInfo = (error, maxBuffer) => {
  if (error?.maxBufferInfo === undefined) {
    return { streamName: "output", threshold: maxBuffer[1], unit: "bytes" };
  }
  const { maxBufferInfo: { fdNumber, unit } } = error;
  delete error.maxBufferInfo;
  const threshold = getFdSpecificValue(maxBuffer, fdNumber);
  if (fdNumber === "ipc") {
    return { streamName: "IPC output", threshold, unit: "messages" };
  }
  return { streamName: getStreamName(fdNumber), threshold, unit };
};
var isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === "ENOBUFS" && output !== null && output.some((result) => result !== null && result.length > getMaxBufferSync(maxBuffer));
var truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
  if (!isMaxBuffer) {
    return result;
  }
  const maxBufferValue = getMaxBufferSync(maxBuffer);
  return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
var getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;

// node_modules/execa/lib/return/message.js
var createMessages = ({
  stdio,
  all,
  ipcOutput,
  originalError,
  signal: signal4,
  signalDescription,
  exitCode,
  escapedCommand,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal,
  maxBuffer,
  timeout: timeout2,
  cwd: cwd3
}) => {
  const errorCode = originalError?.code;
  const prefix = getErrorPrefix({
    originalError,
    timedOut,
    timeout: timeout2,
    isMaxBuffer,
    maxBuffer,
    errorCode,
    signal: signal4,
    signalDescription,
    exitCode,
    isCanceled,
    isGracefullyCanceled,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal
  });
  const originalMessage = getOriginalMessage(originalError, cwd3);
  const suffix = originalMessage === undefined ? "" : `\n${originalMessage}`;
  const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
  const messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];
  const message = [
    shortMessage,
    ...messageStdio,
    ...stdio.slice(3),
    ipcOutput.map((ipcMessage) => serializeIpcMessage(ipcMessage)).join("\n")
  ].map((messagePart) => escapeLines(stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join("\n\n");
  return { originalMessage, shortMessage, message };
};
var getErrorPrefix = ({
  originalError,
  timedOut,
  timeout: timeout2,
  isMaxBuffer,
  maxBuffer,
  errorCode,
  signal: signal4,
  signalDescription,
  exitCode,
  isCanceled,
  isGracefullyCanceled,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal
}) => {
  const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
  if (timedOut) {
    return `Command timed out after ${timeout2} milliseconds${forcefulSuffix}`;
  }
  if (isGracefullyCanceled) {
    if (signal4 === undefined) {
      return `Command was gracefully canceled with exit code ${exitCode}`;
    }
    return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal4} (${signalDescription})`;
  }
  if (isCanceled) {
    return `Command was canceled${forcefulSuffix}`;
  }
  if (isMaxBuffer) {
    return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
  }
  if (errorCode !== undefined) {
    return `Command failed with ${errorCode}${forcefulSuffix}`;
  }
  if (isForcefullyTerminated) {
    return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
  }
  if (signal4 !== undefined) {
    return `Command was killed with ${signal4} (${signalDescription})`;
  }
  if (exitCode !== undefined) {
    return `Command failed with exit code ${exitCode}`;
  }
  return "Command failed";
};
var getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : "";
var getOriginalMessage = (originalError, cwd3) => {
  if (originalError instanceof DiscardedError) {
    return;
  }
  const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
  const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd3));
  return escapedOriginalMessage === "" ? undefined : escapedOriginalMessage;
};
var serializeIpcMessage = (ipcMessage) => typeof ipcMessage === "string" ? ipcMessage : inspect2(ipcMessage);
var serializeMessagePart = (messagePart) => Array.isArray(messagePart) ? messagePart.map((messageItem) => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join("\n") : serializeMessageItem(messagePart);
var serializeMessageItem = (messageItem) => {
  if (typeof messageItem === "string") {
    return messageItem;
  }
  if (isUint8Array(messageItem)) {
    return uint8ArrayToString(messageItem);
  }
  return "";
};

// node_modules/execa/lib/return/result.js
var makeSuccessResult = ({
  command,
  escapedCommand,
  stdio,
  all,
  ipcOutput,
  options: { cwd: cwd3 },
  startTime
}) => omitUndefinedProperties({
  command,
  escapedCommand,
  cwd: cwd3,
  durationMs: getDurationMs(startTime),
  failed: false,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isTerminated: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  exitCode: 0,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var makeEarlyError = ({
  error,
  command,
  escapedCommand,
  fileDescriptors,
  options,
  startTime,
  isSync
}) => makeError({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  stdio: Array.from({ length: fileDescriptors.length }),
  ipcOutput: [],
  options,
  isSync
});
var makeError = ({
  error: originalError,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode: rawExitCode,
  signal: rawSignal,
  stdio,
  all,
  ipcOutput,
  options: {
    timeoutDuration,
    timeout: timeout2 = timeoutDuration,
    forceKillAfterDelay,
    killSignal,
    cwd: cwd3,
    maxBuffer
  },
  isSync
}) => {
  const { exitCode, signal: signal5, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
  const { originalMessage, shortMessage, message: message2 } = createMessages({
    stdio,
    all,
    ipcOutput,
    originalError,
    signal: signal5,
    signalDescription,
    exitCode,
    escapedCommand,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal,
    maxBuffer,
    timeout: timeout2,
    cwd: cwd3
  });
  const error = getFinalError(originalError, message2, isSync);
  Object.assign(error, getErrorProperties({
    error,
    command,
    escapedCommand,
    startTime,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    exitCode,
    signal: signal5,
    signalDescription,
    stdio,
    all,
    ipcOutput,
    cwd: cwd3,
    originalMessage,
    shortMessage
  }));
  return error;
};
var getErrorProperties = ({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal: signal5,
  signalDescription,
  stdio,
  all,
  ipcOutput,
  cwd: cwd3,
  originalMessage,
  shortMessage
}) => omitUndefinedProperties({
  shortMessage,
  originalMessage,
  command,
  escapedCommand,
  cwd: cwd3,
  durationMs: getDurationMs(startTime),
  failed: true,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isTerminated: signal5 !== undefined,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal: signal5,
  signalDescription,
  code: error.cause?.code,
  stdout: stdio[1],
  stderr: stdio[2],
  all,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var omitUndefinedProperties = (result) => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));
var normalizeExitPayload = (rawExitCode, rawSignal) => {
  const exitCode = rawExitCode === null ? undefined : rawExitCode;
  const signal5 = rawSignal === null ? undefined : rawSignal;
  const signalDescription = signal5 === undefined ? undefined : getSignalDescription(rawSignal);
  return { exitCode, signal: signal5, signalDescription };
};

// node_modules/parse-ms/index.js
function parseNumber(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 86400000),
    hours: Math.trunc(milliseconds / 3600000 % 24),
    minutes: Math.trunc(milliseconds / 60000 % 60),
    seconds: Math.trunc(milliseconds / 1000 % 60),
    milliseconds: Math.trunc(milliseconds % 1000),
    microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),
    nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000)
  };
}
function parseBigint(milliseconds) {
  return {
    days: milliseconds / 86400000n,
    hours: milliseconds / 3600000n % 24n,
    minutes: milliseconds / 60000n % 60n,
    seconds: milliseconds / 1000n % 60n,
    milliseconds: milliseconds % 1000n,
    microseconds: 0n,
    nanoseconds: 0n
  };
}
var toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;
function parseMilliseconds(milliseconds) {
  switch (typeof milliseconds) {
    case "number": {
      if (Number.isFinite(milliseconds)) {
        return parseNumber(milliseconds);
      }
      break;
    }
    case "bigint": {
      return parseBigint(milliseconds);
    }
  }
  throw new TypeError("Expected a finite number or bigint");
}

// node_modules/pretty-ms/index.js
var isZero = (value) => value === 0 || value === 0n;
var pluralize = (word, count2) => count2 === 1 || count2 === 1n ? word : `${word}s`;
var SECOND_ROUNDING_EPSILON = 0.0000001;
var ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
function prettyMilliseconds(milliseconds, options) {
  const isBigInt = typeof milliseconds === "bigint";
  if (!isBigInt && !Number.isFinite(milliseconds)) {
    throw new TypeError("Expected a finite number or bigint");
  }
  options = { ...options };
  const sign = milliseconds < 0 ? "-" : "";
  milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
  if (options.colonNotation) {
    options.compact = false;
    options.formatSubMilliseconds = false;
    options.separateMilliseconds = false;
    options.verbose = false;
  }
  if (options.compact) {
    options.unitCount = 1;
    options.secondsDecimalDigits = 0;
    options.millisecondsDecimalDigits = 0;
  }
  let result = [];
  const floorDecimals = (value, decimalDigits) => {
    const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
    return flooredValue.toFixed(decimalDigits);
  };
  const add = (value, long, short, valueString) => {
    if ((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m")) {
      return;
    }
    valueString ??= String(value);
    if (options.colonNotation) {
      const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
      const minLength = result.length > 0 ? 2 : 1;
      valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
    } else {
      valueString += options.verbose ? " " + pluralize(long, value) : short;
    }
    result.push(valueString);
  };
  const parsed = parseMilliseconds(milliseconds);
  const days = BigInt(parsed.days);
  add(days / 365n, "year", "y");
  add(days % 365n, "day", "d");
  add(Number(parsed.hours), "hour", "h");
  add(Number(parsed.minutes), "minute", "m");
  if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1000) {
    const seconds = Number(parsed.seconds);
    const milliseconds2 = Number(parsed.milliseconds);
    const microseconds = Number(parsed.microseconds);
    const nanoseconds = Number(parsed.nanoseconds);
    add(seconds, "second", "s");
    if (options.formatSubMilliseconds) {
      add(milliseconds2, "millisecond", "ms");
      add(microseconds, "microsecond", "\xB5s");
      add(nanoseconds, "nanosecond", "ns");
    } else {
      const millisecondsAndBelow = milliseconds2 + microseconds / 1000 + nanoseconds / 1e6;
      const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
      const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
      const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
      add(Number.parseFloat(millisecondsString), "millisecond", "ms", millisecondsString);
    }
  } else {
    const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1000 % 60;
    const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
    const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
    const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
    add(Number.parseFloat(secondsString), "second", "s", secondsString);
  }
  if (result.length === 0) {
    return sign + "0" + (options.verbose ? " milliseconds" : "ms");
  }
  const separator = options.colonNotation ? ":" : " ";
  if (typeof options.unitCount === "number") {
    result = result.slice(0, Math.max(options.unitCount, 1));
  }
  return sign + result.join(separator);
}

// node_modules/execa/lib/verbose/error.js
var logError = (result, verboseInfo) => {
  if (result.failed) {
    verboseLog({
      type: "error",
      verboseMessage: result.shortMessage,
      verboseInfo,
      result
    });
  }
};

// node_modules/execa/lib/verbose/complete.js
var logResult = (result, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  logError(result, verboseInfo);
  logDuration(result, verboseInfo);
};
var logDuration = (result, verboseInfo) => {
  const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
  verboseLog({
    type: "duration",
    verboseMessage,
    verboseInfo,
    result
  });
};

// node_modules/execa/lib/return/reject.js
var handleResult = (result, verboseInfo, { reject }) => {
  logResult(result, verboseInfo);
  if (result.failed && reject) {
    throw result;
  }
  return result;
};

// node_modules/execa/lib/stdio/handle-sync.js
import {readFileSync as readFileSync2} from "node:fs";

// node_modules/execa/lib/stdio/type.js
var getStdioItemType = (value, optionName) => {
  if (isAsyncGenerator(value)) {
    return "asyncGenerator";
  }
  if (isSyncGenerator(value)) {
    return "generator";
  }
  if (isUrl(value)) {
    return "fileUrl";
  }
  if (isFilePathObject(value)) {
    return "filePath";
  }
  if (isWebStream(value)) {
    return "webStream";
  }
  if (isStream(value, { checkOpen: false })) {
    return "native";
  }
  if (isUint8Array(value)) {
    return "uint8Array";
  }
  if (isAsyncIterableObject(value)) {
    return "asyncIterable";
  }
  if (isIterableObject(value)) {
    return "iterable";
  }
  if (isTransformStream(value)) {
    return getTransformStreamType({ transform: value }, optionName);
  }
  if (isTransformOptions(value)) {
    return getTransformObjectType(value, optionName);
  }
  return "native";
};
var getTransformObjectType = (value, optionName) => {
  if (isDuplexStream(value.transform, { checkOpen: false })) {
    return getDuplexType(value, optionName);
  }
  if (isTransformStream(value.transform)) {
    return getTransformStreamType(value, optionName);
  }
  return getGeneratorObjectType(value, optionName);
};
var getDuplexType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "Duplex stream");
  return "duplex";
};
var getTransformStreamType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "web TransformStream");
  return "webTransform";
};
var validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName) => {
  checkUndefinedOption(final, `${optionName}.final`, typeName);
  checkUndefinedOption(binary, `${optionName}.binary`, typeName);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
};
var checkUndefinedOption = (value, optionName, typeName) => {
  if (value !== undefined) {
    throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
  }
};
var getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName) => {
  if (transform !== undefined && !isGenerator(transform)) {
    throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
  }
  if (isDuplexStream(final, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
  }
  if (isTransformStream(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
  }
  if (final !== undefined && !isGenerator(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
  }
  checkBooleanOption(binary, `${optionName}.binary`);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
  return isAsyncGenerator(transform) || isAsyncGenerator(final) ? "asyncGenerator" : "generator";
};
var checkBooleanOption = (value, optionName) => {
  if (value !== undefined && typeof value !== "boolean") {
    throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
  }
};
var isGenerator = (value) => isAsyncGenerator(value) || isSyncGenerator(value);
var isAsyncGenerator = (value) => Object.prototype.toString.call(value) === "[object AsyncGeneratorFunction]";
var isSyncGenerator = (value) => Object.prototype.toString.call(value) === "[object GeneratorFunction]";
var isTransformOptions = (value) => isPlainObject(value) && (value.transform !== undefined || value.final !== undefined);
var isUrl = (value) => Object.prototype.toString.call(value) === "[object URL]";
var isRegularUrl = (value) => isUrl(value) && value.protocol !== "file:";
var isFilePathObject = (value) => isPlainObject(value) && Object.keys(value).length === 1 && isFilePathString(value.file);
var isFilePathString = (file) => typeof file === "string";
var isUnknownStdioString = (type, value) => type === "native" && typeof value === "string" && !KNOWN_STDIO_STRINGS.has(value);
var KNOWN_STDIO_STRINGS = new Set(["ipc", "ignore", "inherit", "overlapped", "pipe"]);
var isReadableStream2 = (value) => Object.prototype.toString.call(value) === "[object ReadableStream]";
var isWritableStream2 = (value) => Object.prototype.toString.call(value) === "[object WritableStream]";
var isWebStream = (value) => isReadableStream2(value) || isWritableStream2(value);
var isTransformStream = (value) => isReadableStream2(value?.readable) && isWritableStream2(value?.writable);
var isAsyncIterableObject = (value) => isObject(value) && typeof value[Symbol.asyncIterator] === "function";
var isIterableObject = (value) => isObject(value) && typeof value[Symbol.iterator] === "function";
var isObject = (value) => typeof value === "object" && value !== null;
var TRANSFORM_TYPES = new Set(["generator", "asyncGenerator", "duplex", "webTransform"]);
var FILE_TYPES = new Set(["fileUrl", "filePath", "fileNumber"]);
var SPECIAL_DUPLICATE_TYPES_SYNC = new Set(["fileUrl", "filePath"]);
var SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, "webStream", "nodeStream"]);
var FORBID_DUPLICATE_TYPES = new Set(["webTransform", "duplex"]);
var TYPE_TO_MESSAGE = {
  generator: "a generator",
  asyncGenerator: "an async generator",
  fileUrl: "a file URL",
  filePath: "a file path string",
  fileNumber: "a file descriptor number",
  webStream: "a web stream",
  nodeStream: "a Node.js stream",
  webTransform: "a web TransformStream",
  duplex: "a Duplex stream",
  native: "any value",
  iterable: "an iterable",
  asyncIterable: "an async iterable",
  string: "a string",
  uint8Array: "a Uint8Array"
};

// node_modules/execa/lib/transform/object-mode.js
var getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === "output" ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
var getOutputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = objectMode ?? writableObjectMode;
  return { writableObjectMode, readableObjectMode };
};
var getInputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
  return { writableObjectMode, readableObjectMode };
};
var getFdObjectMode = (stdioItems, direction) => {
  const lastTransform = stdioItems.findLast(({ type: type2 }) => TRANSFORM_TYPES.has(type2));
  if (lastTransform === undefined) {
    return false;
  }
  return direction === "input" ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};

// node_modules/execa/lib/transform/normalize.js
var normalizeTransforms = (stdioItems, optionName, direction, options) => [
  ...stdioItems.filter(({ type: type3 }) => !TRANSFORM_TYPES.has(type3)),
  ...getTransforms(stdioItems, optionName, direction, options)
];
var getTransforms = (stdioItems, optionName, direction, { encoding }) => {
  const transforms = stdioItems.filter(({ type: type3 }) => TRANSFORM_TYPES.has(type3));
  const newTransforms = Array.from({ length: transforms.length });
  for (const [index, stdioItem] of Object.entries(transforms)) {
    newTransforms[index] = normalizeTransform({
      stdioItem,
      index: Number(index),
      newTransforms,
      optionName,
      direction,
      encoding
    });
  }
  return sortTransforms(newTransforms, direction);
};
var normalizeTransform = ({ stdioItem, stdioItem: { type: type3 }, index, newTransforms, optionName, direction, encoding }) => {
  if (type3 === "duplex") {
    return normalizeDuplex({ stdioItem, optionName });
  }
  if (type3 === "webTransform") {
    return normalizeTransformStream({
      stdioItem,
      index,
      newTransforms,
      direction
    });
  }
  return normalizeGenerator({
    stdioItem,
    index,
    newTransforms,
    direction,
    encoding
  });
};
var normalizeDuplex = ({
  stdioItem,
  stdioItem: {
    value: {
      transform,
      transform: { writableObjectMode, readableObjectMode },
      objectMode = readableObjectMode
    }
  },
  optionName
}) => {
  if (objectMode && !readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  if (!objectMode && readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction }) => {
  const { transform, objectMode } = isPlainObject(value) ? value : { transform: value };
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding }) => {
  const {
    transform,
    final,
    binary: binaryOption = false,
    preserveNewlines = false,
    objectMode
  } = isPlainObject(value) ? value : { transform: value };
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: {
      transform,
      final,
      binary,
      preserveNewlines,
      writableObjectMode,
      readableObjectMode
    }
  };
};
var sortTransforms = (newTransforms, direction) => direction === "input" ? newTransforms.reverse() : newTransforms;

// node_modules/execa/lib/stdio/direction.js
import process7 from "node:process";
var getStreamDirection = (stdioItems, fdNumber, optionName) => {
  const directions = stdioItems.map((stdioItem) => getStdioItemDirection(stdioItem, fdNumber));
  if (directions.includes("input") && directions.includes("output")) {
    throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
  }
  return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};
var getStdioItemDirection = ({ type: type4, value }, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type4](value);
var KNOWN_DIRECTIONS = ["input", "output", "output"];
var anyDirection = () => {
  return;
};
var alwaysInput = () => "input";
var guessStreamDirection = {
  generator: anyDirection,
  asyncGenerator: anyDirection,
  fileUrl: anyDirection,
  filePath: anyDirection,
  iterable: alwaysInput,
  asyncIterable: alwaysInput,
  uint8Array: alwaysInput,
  webStream: (value) => isWritableStream2(value) ? "output" : "input",
  nodeStream(value) {
    if (!isReadableStream(value, { checkOpen: false })) {
      return "output";
    }
    return isWritableStream(value, { checkOpen: false }) ? undefined : "input";
  },
  webTransform: anyDirection,
  duplex: anyDirection,
  native(value) {
    const standardStreamDirection = getStandardStreamDirection(value);
    if (standardStreamDirection !== undefined) {
      return standardStreamDirection;
    }
    if (isStream(value, { checkOpen: false })) {
      return guessStreamDirection.nodeStream(value);
    }
  }
};
var getStandardStreamDirection = (value) => {
  if ([0, process7.stdin].includes(value)) {
    return "input";
  }
  if ([1, 2, process7.stdout, process7.stderr].includes(value)) {
    return "output";
  }
};
var DEFAULT_DIRECTION = "output";

// node_modules/execa/lib/ipc/array.js
var normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes("ipc") ? [...stdioArray, "ipc"] : stdioArray;

// node_modules/execa/lib/stdio/stdio-option.js
var normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync) => {
  const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue2(stdioOption, fdNumber));
  return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
};
var getStdioArray = (stdio, options) => {
  if (stdio === undefined) {
    return STANDARD_STREAMS_ALIASES.map((alias) => options[alias]);
  }
  if (hasAlias(options)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return [stdio, stdio, stdio];
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
  return Array.from({ length }, (_, fdNumber) => stdio[fdNumber]);
};
var hasAlias = (options) => STANDARD_STREAMS_ALIASES.some((alias) => options[alias] !== undefined);
var addDefaultValue2 = (stdioOption, fdNumber) => {
  if (Array.isArray(stdioOption)) {
    return stdioOption.map((item) => addDefaultValue2(item, fdNumber));
  }
  if (stdioOption === null || stdioOption === undefined) {
    return fdNumber >= STANDARD_STREAMS_ALIASES.length ? "ignore" : "pipe";
  }
  return stdioOption;
};
var normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) => !buffer[fdNumber] && fdNumber !== 0 && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? "ignore" : stdioOption);
var isOutputPipeOnly = (stdioOption) => stdioOption === "pipe" || Array.isArray(stdioOption) && stdioOption.every((item) => item === "pipe");

// node_modules/execa/lib/stdio/native.js
import {readFileSync} from "node:fs";
import tty2 from "node:tty";
var handleNativeStream = ({ stdioItem, stdioItem: { type: type4 }, isStdioArray, fdNumber, direction, isSync }) => {
  if (!isStdioArray || type4 !== "native") {
    return stdioItem;
  }
  return isSync ? handleNativeStreamSync({ stdioItem, fdNumber, direction }) : handleNativeStreamAsync({ stdioItem, fdNumber });
};
var handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction }) => {
  const targetFd = getTargetFd({
    value,
    optionName,
    fdNumber,
    direction
  });
  if (targetFd !== undefined) {
    return targetFd;
  }
  if (isStream(value, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
  }
  return stdioItem;
};
var getTargetFd = ({ value, optionName, fdNumber, direction }) => {
  const targetFdNumber = getTargetFdNumber(value, fdNumber);
  if (targetFdNumber === undefined) {
    return;
  }
  if (direction === "output") {
    return { type: "fileNumber", value: targetFdNumber, optionName };
  }
  if (tty2.isatty(targetFdNumber)) {
    throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
  }
  return { type: "uint8Array", value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName };
};
var getTargetFdNumber = (value, fdNumber) => {
  if (value === "inherit") {
    return fdNumber;
  }
  if (typeof value === "number") {
    return value;
  }
  const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
  if (standardStreamIndex !== -1) {
    return standardStreamIndex;
  }
};
var handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber }) => {
  if (value === "inherit") {
    return { type: "nodeStream", value: getStandardStream(fdNumber, value, optionName), optionName };
  }
  if (typeof value === "number") {
    return { type: "nodeStream", value: getStandardStream(value, value, optionName), optionName };
  }
  if (isStream(value, { checkOpen: false })) {
    return { type: "nodeStream", value, optionName };
  }
  return stdioItem;
};
var getStandardStream = (fdNumber, value, optionName) => {
  const standardStream = STANDARD_STREAMS[fdNumber];
  if (standardStream === undefined) {
    throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
  }
  return standardStream;
};

// node_modules/execa/lib/stdio/input-option.js
var handleInputOptions = ({ input, inputFile }, fdNumber) => fdNumber === 0 ? [
  ...handleInputOption(input),
  ...handleInputFileOption(inputFile)
] : [];
var handleInputOption = (input) => input === undefined ? [] : [{
  type: getInputType(input),
  value: input,
  optionName: "input"
}];
var getInputType = (input) => {
  if (isReadableStream(input, { checkOpen: false })) {
    return "nodeStream";
  }
  if (typeof input === "string") {
    return "string";
  }
  if (isUint8Array(input)) {
    return "uint8Array";
  }
  throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.");
};
var handleInputFileOption = (inputFile) => inputFile === undefined ? [] : [{
  ...getInputFileType(inputFile),
  optionName: "inputFile"
}];
var getInputFileType = (inputFile) => {
  if (isUrl(inputFile)) {
    return { type: "fileUrl", value: inputFile };
  }
  if (isFilePathString(inputFile)) {
    return { type: "filePath", value: { file: inputFile } };
  }
  throw new Error("The `inputFile` option must be a file path string or a file URL.");
};

// node_modules/execa/lib/stdio/duplicate.js
var filterDuplicates = (stdioItems) => stdioItems.filter((stdioItemOne, indexOne) => stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === "generator" || stdioItemOne.type === "asyncGenerator"));
var getDuplicateStream = ({ stdioItem: { type: type6, value, optionName }, direction, fileDescriptors, isSync }) => {
  const otherStdioItems = getOtherStdioItems(fileDescriptors, type6);
  if (otherStdioItems.length === 0) {
    return;
  }
  if (isSync) {
    validateDuplicateStreamSync({
      otherStdioItems,
      type: type6,
      value,
      optionName,
      direction
    });
    return;
  }
  if (SPECIAL_DUPLICATE_TYPES.has(type6)) {
    return getDuplicateStreamInstance({
      otherStdioItems,
      type: type6,
      value,
      optionName,
      direction
    });
  }
  if (FORBID_DUPLICATE_TYPES.has(type6)) {
    validateDuplicateTransform({
      otherStdioItems,
      type: type6,
      value,
      optionName
    });
  }
};
var getOtherStdioItems = (fileDescriptors, type6) => fileDescriptors.flatMap(({ direction, stdioItems }) => stdioItems.filter((stdioItem) => stdioItem.type === type6).map((stdioItem) => ({ ...stdioItem, direction })));
var validateDuplicateStreamSync = ({ otherStdioItems, type: type6, value, optionName, direction }) => {
  if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type6)) {
    getDuplicateStreamInstance({
      otherStdioItems,
      type: type6,
      value,
      optionName,
      direction
    });
  }
};
var getDuplicateStreamInstance = ({ otherStdioItems, type: type6, value, optionName, direction }) => {
  const duplicateStdioItems = otherStdioItems.filter((stdioItem) => hasSameValue(stdioItem, value));
  if (duplicateStdioItems.length === 0) {
    return;
  }
  const differentStdioItem = duplicateStdioItems.find((stdioItem) => stdioItem.direction !== direction);
  throwOnDuplicateStream(differentStdioItem, optionName, type6);
  return direction === "output" ? duplicateStdioItems[0].stream : undefined;
};
var hasSameValue = ({ type: type6, value }, secondValue) => {
  if (type6 === "filePath") {
    return value.file === secondValue.file;
  }
  if (type6 === "fileUrl") {
    return value.href === secondValue.href;
  }
  return value === secondValue;
};
var validateDuplicateTransform = ({ otherStdioItems, type: type6, value, optionName }) => {
  const duplicateStdioItem = otherStdioItems.find(({ value: { transform } }) => transform === value.transform);
  throwOnDuplicateStream(duplicateStdioItem, optionName, type6);
};
var throwOnDuplicateStream = (stdioItem, optionName, type6) => {
  if (stdioItem !== undefined) {
    throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type6]} that is the same.`);
  }
};

// node_modules/execa/lib/stdio/handle.js
var handleStdio = (addProperties, options, verboseInfo, isSync) => {
  const stdio = normalizeStdioOption(options, verboseInfo, isSync);
  const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
    stdioOption,
    fdNumber,
    options,
    isSync
  }));
  const fileDescriptors = getFinalFileDescriptors({
    initialFileDescriptors,
    addProperties,
    options,
    isSync
  });
  options.stdio = fileDescriptors.map(({ stdioItems }) => forwardStdio(stdioItems));
  return fileDescriptors;
};
var getFileDescriptor = ({ stdioOption, fdNumber, options, isSync }) => {
  const optionName = getStreamName(fdNumber);
  const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
    stdioOption,
    fdNumber,
    options,
    optionName
  });
  const direction2 = getStreamDirection(initialStdioItems, fdNumber, optionName);
  const stdioItems = initialStdioItems.map((stdioItem) => handleNativeStream({
    stdioItem,
    isStdioArray,
    fdNumber,
    direction: direction2,
    isSync
  }));
  const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction2, options);
  const objectMode = getFdObjectMode(normalizedStdioItems, direction2);
  validateFileObjectMode(normalizedStdioItems, objectMode);
  return { direction: direction2, objectMode, stdioItems: normalizedStdioItems };
};
var initializeStdioItems = ({ stdioOption, fdNumber, options, optionName }) => {
  const values6 = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
  const initialStdioItems = [
    ...values6.map((value) => initializeStdioItem(value, optionName)),
    ...handleInputOptions(options, fdNumber)
  ];
  const stdioItems = filterDuplicates(initialStdioItems);
  const isStdioArray = stdioItems.length > 1;
  validateStdioArray(stdioItems, isStdioArray, optionName);
  validateStreams(stdioItems);
  return { stdioItems, isStdioArray };
};
var initializeStdioItem = (value, optionName) => ({
  type: getStdioItemType(value, optionName),
  value,
  optionName
});
var validateStdioArray = (stdioItems, isStdioArray, optionName) => {
  if (stdioItems.length === 0) {
    throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
  }
  if (!isStdioArray) {
    return;
  }
  for (const { value, optionName: optionName2 } of stdioItems) {
    if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
      throw new Error(`The \`${optionName2}\` option must not include \`${value}\`.`);
    }
  }
};
var INVALID_STDIO_ARRAY_OPTIONS = new Set(["ignore", "ipc"]);
var validateStreams = (stdioItems) => {
  for (const stdioItem of stdioItems) {
    validateFileStdio(stdioItem);
  }
};
var validateFileStdio = ({ type: type7, value, optionName }) => {
  if (isRegularUrl(value)) {
    throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
  }
  if (isUnknownStdioString(type7, value)) {
    throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
  }
};
var validateFileObjectMode = (stdioItems, objectMode) => {
  if (!objectMode) {
    return;
  }
  const fileStdioItem = stdioItems.find(({ type: type7 }) => FILE_TYPES.has(type7));
  if (fileStdioItem !== undefined) {
    throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
  }
};
var getFinalFileDescriptors = ({ initialFileDescriptors, addProperties, options, isSync }) => {
  const fileDescriptors = [];
  try {
    for (const fileDescriptor of initialFileDescriptors) {
      fileDescriptors.push(getFinalFileDescriptor({
        fileDescriptor,
        fileDescriptors,
        addProperties,
        options,
        isSync
      }));
    }
    return fileDescriptors;
  } catch (error2) {
    cleanupCustomStreams(fileDescriptors);
    throw error2;
  }
};
var getFinalFileDescriptor = ({
  fileDescriptor: { direction: direction2, objectMode, stdioItems },
  fileDescriptors,
  addProperties,
  options,
  isSync
}) => {
  const finalStdioItems = stdioItems.map((stdioItem) => addStreamProperties({
    stdioItem,
    addProperties,
    direction: direction2,
    options,
    fileDescriptors,
    isSync
  }));
  return { direction: direction2, objectMode, stdioItems: finalStdioItems };
};
var addStreamProperties = ({ stdioItem, addProperties, direction: direction2, options, fileDescriptors, isSync }) => {
  const duplicateStream = getDuplicateStream({
    stdioItem,
    direction: direction2,
    fileDescriptors,
    isSync
  });
  if (duplicateStream !== undefined) {
    return { ...stdioItem, stream: duplicateStream };
  }
  return {
    ...stdioItem,
    ...addProperties[direction2][stdioItem.type](stdioItem, options)
  };
};
var cleanupCustomStreams = (fileDescriptors) => {
  for (const { stdioItems } of fileDescriptors) {
    for (const { stream: stream3 } of stdioItems) {
      if (stream3 !== undefined && !isStandardStream(stream3)) {
        stream3.destroy();
      }
    }
  }
};
var forwardStdio = (stdioItems) => {
  if (stdioItems.length > 1) {
    return stdioItems.some(({ value: value2 }) => value2 === "overlapped") ? "overlapped" : "pipe";
  }
  const [{ type: type7, value }] = stdioItems;
  return type7 === "native" ? value : "pipe";
};

// node_modules/execa/lib/stdio/handle-sync.js
var handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);
var forbiddenIfSync = ({ type: type8, optionName }) => {
  throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type8]);
};
var forbiddenNativeIfSync = ({ optionName, value }) => {
  if (value === "ipc" || value === "overlapped") {
    throwInvalidSyncValue(optionName, `"${value}"`);
  }
  return {};
};
var throwInvalidSyncValue = (optionName, value) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};
var addProperties = {
  generator() {
  },
  asyncGenerator: forbiddenIfSync,
  webStream: forbiddenIfSync,
  nodeStream: forbiddenIfSync,
  webTransform: forbiddenIfSync,
  duplex: forbiddenIfSync,
  asyncIterable: forbiddenIfSync,
  native: forbiddenNativeIfSync
};
var addPropertiesSync = {
  input: {
    ...addProperties,
    fileUrl: ({ value }) => ({ contents: [bufferToUint8Array(readFileSync2(value))] }),
    filePath: ({ value: { file } }) => ({ contents: [bufferToUint8Array(readFileSync2(file))] }),
    fileNumber: forbiddenIfSync,
    iterable: ({ value }) => ({ contents: [...value] }),
    string: ({ value }) => ({ contents: [value] }),
    uint8Array: ({ value }) => ({ contents: [value] })
  },
  output: {
    ...addProperties,
    fileUrl: ({ value }) => ({ path: value }),
    filePath: ({ value: { file } }) => ({ path: file }),
    fileNumber: ({ value }) => ({ path: value }),
    iterable: forbiddenIfSync,
    string: forbiddenIfSync,
    uint8Array: forbiddenIfSync
  }
};

// node_modules/execa/lib/io/strip-newline.js
var stripNewline = (value, { stripFinalNewline: stripFinalNewline2 }, fdNumber) => getStripFinalNewline(stripFinalNewline2, fdNumber) && value !== undefined && !Array.isArray(value) ? stripFinalNewline(value) : value;
var getStripFinalNewline = (stripFinalNewline2, fdNumber) => fdNumber === "all" ? stripFinalNewline2[1] || stripFinalNewline2[2] : stripFinalNewline2[fdNumber];

// node_modules/execa/lib/transform/generator.js
import {Transform, getDefaultHighWaterMark} from "node:stream";

// node_modules/execa/lib/transform/split.js
var getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped ? undefined : initializeSplitLines(preserveNewlines, state);
var splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode ? chunk.flatMap((item) => splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
var splitLinesItemSync = (chunk, preserveNewlines) => {
  const { transform, final } = initializeSplitLines(preserveNewlines, {});
  return [...transform(chunk), ...final()];
};
var initializeSplitLines = (preserveNewlines, state) => {
  state.previousChunks = "";
  return {
    transform: splitGenerator.bind(undefined, state, preserveNewlines),
    final: linesFinal.bind(undefined, state)
  };
};
var splitGenerator = function* (state, preserveNewlines, chunk) {
  if (typeof chunk !== "string") {
    yield chunk;
    return;
  }
  let { previousChunks } = state;
  let start2 = -1;
  for (let end = 0;end < chunk.length; end += 1) {
    if (chunk[end] === "\n") {
      const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
      let line = chunk.slice(start2 + 1, end + 1 - newlineLength);
      if (previousChunks.length > 0) {
        line = concatString(previousChunks, line);
        previousChunks = "";
      }
      yield line;
      start2 = end;
    }
  }
  if (start2 !== chunk.length - 1) {
    previousChunks = concatString(previousChunks, chunk.slice(start2 + 1));
  }
  state.previousChunks = previousChunks;
};
var getNewlineLength = (chunk, end, preserveNewlines, state) => {
  if (preserveNewlines) {
    return 0;
  }
  state.isWindowsNewline = end !== 0 && chunk[end - 1] === "\r";
  return state.isWindowsNewline ? 2 : 1;
};
var linesFinal = function* ({ previousChunks }) {
  if (previousChunks.length > 0) {
    yield previousChunks;
  }
};
var getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state }) => binary || preserveNewlines || readableObjectMode ? undefined : { transform: appendNewlineGenerator.bind(undefined, state) };
var appendNewlineGenerator = function* ({ isWindowsNewline = false }, chunk) {
  const { unixNewline, windowsNewline, LF: LF2, concatBytes } = typeof chunk === "string" ? linesStringInfo : linesUint8ArrayInfo;
  if (chunk.at(-1) === LF2) {
    yield chunk;
    return;
  }
  const newline = isWindowsNewline ? windowsNewline : unixNewline;
  yield concatBytes(chunk, newline);
};
var concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
var linesStringInfo = {
  windowsNewline: "\r\n",
  unixNewline: "\n",
  LF: "\n",
  concatBytes: concatString
};
var concatUint8Array = (firstChunk, secondChunk) => {
  const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
  chunk.set(firstChunk, 0);
  chunk.set(secondChunk, firstChunk.length);
  return chunk;
};
var linesUint8ArrayInfo = {
  windowsNewline: new Uint8Array([13, 10]),
  unixNewline: new Uint8Array([10]),
  LF: 10,
  concatBytes: concatUint8Array
};

// node_modules/execa/lib/transform/validate.js
import {Buffer as Buffer2} from "node:buffer";
var getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode ? undefined : validateStringTransformInput.bind(undefined, optionName);
var validateStringTransformInput = function* (optionName, chunk) {
  if (typeof chunk !== "string" && !isUint8Array(chunk) && !Buffer2.isBuffer(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
  }
  yield chunk;
};
var getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode ? validateObjectTransformReturn.bind(undefined, optionName) : validateStringTransformReturn.bind(undefined, optionName);
var validateObjectTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  yield chunk;
};
var validateStringTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  if (typeof chunk !== "string" && !isUint8Array(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
  }
  yield chunk;
};
var validateEmptyReturn = (optionName, chunk) => {
  if (chunk === null || chunk === undefined) {
    throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
  }
};

// node_modules/execa/lib/transform/encoding-transform.js
import {Buffer as Buffer3} from "node:buffer";
import {StringDecoder as StringDecoder2} from "node:string_decoder";
var getEncodingTransformGenerator = (binary, encoding, skipped) => {
  if (skipped) {
    return;
  }
  if (binary) {
    return { transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder) };
  }
  const stringDecoder = new StringDecoder2(encoding);
  return {
    transform: encodingStringGenerator.bind(undefined, stringDecoder),
    final: encodingStringFinal.bind(undefined, stringDecoder)
  };
};
var encodingUint8ArrayGenerator = function* (textEncoder3, chunk) {
  if (Buffer3.isBuffer(chunk)) {
    yield bufferToUint8Array(chunk);
  } else if (typeof chunk === "string") {
    yield textEncoder3.encode(chunk);
  } else {
    yield chunk;
  }
};
var encodingStringGenerator = function* (stringDecoder, chunk) {
  yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
};
var encodingStringFinal = function* (stringDecoder) {
  const lastChunk = stringDecoder.end();
  if (lastChunk !== "") {
    yield lastChunk;
  }
};

// node_modules/execa/lib/transform/run-async.js
import {callbackify} from "node:util";
var pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {
  state.currentIterable = getChunks(...getChunksArguments);
  try {
    for await (const chunk of state.currentIterable) {
      transformStream.push(chunk);
    }
  } finally {
    delete state.currentIterable;
  }
});
var transformChunk = async function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator } = generators[index];
  for await (const transformedChunk of transform(chunk)) {
    yield* transformChunk(transformedChunk, generators, index + 1);
  }
};
var finalChunks = async function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunks(final, Number(index), generators);
  }
};
var generatorFinalChunks = async function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for await (const finalChunk of final()) {
    yield* transformChunk(finalChunk, generators, index + 1);
  }
};
var destroyTransform = callbackify(async ({ currentIterable }, error2) => {
  if (currentIterable !== undefined) {
    await (error2 ? currentIterable.throw(error2) : currentIterable.return());
    return;
  }
  if (error2) {
    throw error2;
  }
});
var identityGenerator = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/run-sync.js
var pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
  try {
    for (const chunk of getChunksSync(...getChunksArguments)) {
      transformStream.push(chunk);
    }
    done();
  } catch (error2) {
    done(error2);
  }
};
var runTransformSync = (generators, chunks) => [
  ...chunks.flatMap((chunk) => [...transformChunkSync(chunk, generators, 0)]),
  ...finalChunksSync(generators)
];
var transformChunkSync = function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator2 } = generators[index];
  for (const transformedChunk of transform(chunk)) {
    yield* transformChunkSync(transformedChunk, generators, index + 1);
  }
};
var finalChunksSync = function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunksSync(final, Number(index), generators);
  }
};
var generatorFinalChunksSync = function* (final, index, generators) {
  if (final === undefined) {
    return;
  }
  for (const finalChunk of final()) {
    yield* transformChunkSync(finalChunk, generators, index + 1);
  }
};
var identityGenerator2 = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/generator.js
var generatorToStream = ({
  value,
  value: { transform, final, writableObjectMode, readableObjectMode },
  optionName
}, { encoding }) => {
  const state = {};
  const generators = addInternalGenerators(value, encoding, optionName);
  const transformAsync = isAsyncGenerator(transform);
  const finalAsync = isAsyncGenerator(final);
  const transformMethod = transformAsync ? pushChunks.bind(undefined, transformChunk, state) : pushChunksSync.bind(undefined, transformChunkSync);
  const finalMethod = transformAsync || finalAsync ? pushChunks.bind(undefined, finalChunks, state) : pushChunksSync.bind(undefined, finalChunksSync);
  const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(undefined, state) : undefined;
  const stream3 = new Transform({
    writableObjectMode,
    writableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),
    readableObjectMode,
    readableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),
    transform(chunk, encoding2, done) {
      transformMethod([chunk, generators, 0], this, done);
    },
    flush(done) {
      finalMethod([generators], this, done);
    },
    destroy: destroyMethod
  });
  return { stream: stream3 };
};
var runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
  const generators = stdioItems.filter(({ type: type9 }) => type9 === "generator");
  const reversedGenerators = isInput ? generators.reverse() : generators;
  for (const { value, optionName } of reversedGenerators) {
    const generators2 = addInternalGenerators(value, encoding, optionName);
    chunks = runTransformSync(generators2, chunks);
  }
  return chunks;
};
var addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName) => {
  const state = {};
  return [
    { transform: getValidateTransformInput(writableObjectMode, optionName) },
    getEncodingTransformGenerator(binary, encoding, writableObjectMode),
    getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
    { transform, final },
    { transform: getValidateTransformReturn(readableObjectMode, optionName) },
    getAppendNewlineGenerator({
      binary,
      preserveNewlines,
      readableObjectMode,
      state
    })
  ].filter(Boolean);
};

// node_modules/execa/lib/io/input-sync.js
var addInputOptionsSync = (fileDescriptors, options) => {
  for (const fdNumber of getInputFdNumbers(fileDescriptors)) {
    addInputOptionSync(fileDescriptors, fdNumber, options);
  }
};
var getInputFdNumbers = (fileDescriptors) => new Set(Object.entries(fileDescriptors).filter(([, { direction: direction2 }]) => direction2 === "input").map(([fdNumber]) => Number(fdNumber)));
var addInputOptionSync = (fileDescriptors, fdNumber, options) => {
  const { stdioItems } = fileDescriptors[fdNumber];
  const allStdioItems = stdioItems.filter(({ contents: contents4 }) => contents4 !== undefined);
  if (allStdioItems.length === 0) {
    return;
  }
  if (fdNumber !== 0) {
    const [{ type: type10, optionName }] = allStdioItems;
    throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type10]} with synchronous methods.`);
  }
  const allContents = allStdioItems.map(({ contents: contents4 }) => contents4);
  const transformedContents = allContents.map((contents4) => applySingleInputGeneratorsSync(contents4, stdioItems));
  options.input = joinToUint8Array(transformedContents);
};
var applySingleInputGeneratorsSync = (contents4, stdioItems) => {
  const newContents = runGeneratorsSync(contents4, stdioItems, "utf8", true);
  validateSerializable(newContents);
  return joinToUint8Array(newContents);
};
var validateSerializable = (newContents) => {
  const invalidItem = newContents.find((item) => typeof item !== "string" && !isUint8Array(item));
  if (invalidItem !== undefined) {
    throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
  }
};

// node_modules/execa/lib/io/output-sync.js
import {writeFileSync as writeFileSync2, appendFileSync} from "node:fs";

// node_modules/execa/lib/verbose/output.js
var shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber }) => fdNumber !== "all" && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type: type11, value }) => type11 === "native" && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type: type11 }) => TRANSFORM_TYPES.has(type11)));
var fdUsesVerbose = (fdNumber) => fdNumber === 1 || fdNumber === 2;
var PIPED_STDIO_VALUES = new Set(["pipe", "overlapped"]);
var logLines = async (linesIterable, stream3, fdNumber, verboseInfo) => {
  for await (const line of linesIterable) {
    if (!isPipingStream(stream3)) {
      logLine(line, fdNumber, verboseInfo);
    }
  }
};
var logLinesSync = (linesArray, fdNumber, verboseInfo) => {
  for (const line of linesArray) {
    logLine(line, fdNumber, verboseInfo);
  }
};
var isPipingStream = (stream3) => stream3._readableState.pipes.length > 0;
var logLine = (line, fdNumber, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(line);
  verboseLog({
    type: "output",
    verboseMessage,
    fdNumber,
    verboseInfo
  });
};

// node_modules/execa/lib/io/output-sync.js
var transformOutputSync = ({ fileDescriptors, syncResult: { output: output2 }, options, isMaxBuffer, verboseInfo }) => {
  if (output2 === null) {
    return { output: Array.from({ length: 3 }) };
  }
  const state = {};
  const outputFiles = new Set([]);
  const transformedOutput = output2.map((result, fdNumber) => transformOutputResultSync({
    result,
    fileDescriptors,
    fdNumber,
    state,
    outputFiles,
    isMaxBuffer,
    verboseInfo
  }, options));
  return { output: transformedOutput, ...state };
};
var transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline: stripFinalNewline2, maxBuffer }) => {
  if (result === null) {
    return;
  }
  const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
  const uint8ArrayResult = bufferToUint8Array(truncatedResult);
  const { stdioItems, objectMode } = fileDescriptors[fdNumber];
  const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
  const { serializedResult, finalResult = serializedResult } = serializeChunks({
    chunks,
    objectMode,
    encoding,
    lines,
    stripFinalNewline: stripFinalNewline2,
    fdNumber
  });
  logOutputSync({
    serializedResult,
    fdNumber,
    state,
    verboseInfo,
    encoding,
    stdioItems,
    objectMode
  });
  const returnedResult = buffer[fdNumber] ? finalResult : undefined;
  try {
    if (state.error === undefined) {
      writeToFiles(serializedResult, stdioItems, outputFiles);
    }
    return returnedResult;
  } catch (error2) {
    state.error = error2;
    return returnedResult;
  }
};
var runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
  try {
    return runGeneratorsSync(chunks, stdioItems, encoding, false);
  } catch (error2) {
    state.error = error2;
    return chunks;
  }
};
var serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline: stripFinalNewline2, fdNumber }) => {
  if (objectMode) {
    return { serializedResult: chunks };
  }
  if (encoding === "buffer") {
    return { serializedResult: joinToUint8Array(chunks) };
  }
  const serializedResult = joinToString(chunks, encoding);
  if (lines[fdNumber]) {
    return { serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline2[fdNumber], objectMode) };
  }
  return { serializedResult };
};
var logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode }) => {
  if (!shouldLogOutput({
    stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesArray = splitLinesSync(serializedResult, false, objectMode);
  try {
    logLinesSync(linesArray, fdNumber, verboseInfo);
  } catch (error2) {
    state.error ??= error2;
  }
};
var writeToFiles = (serializedResult, stdioItems, outputFiles) => {
  for (const { path: path5 } of stdioItems.filter(({ type: type12 }) => FILE_TYPES.has(type12))) {
    const pathString = typeof path5 === "string" ? path5 : path5.toString();
    if (outputFiles.has(pathString)) {
      appendFileSync(path5, serializedResult);
    } else {
      outputFiles.add(pathString);
      writeFileSync2(path5, serializedResult);
    }
  }
};

// node_modules/execa/lib/resolve/all-sync.js
var getAllSync = ([, stdout, stderr], options) => {
  if (!options.all) {
    return;
  }
  if (stdout === undefined) {
    return stderr;
  }
  if (stderr === undefined) {
    return stdout;
  }
  if (Array.isArray(stdout)) {
    return Array.isArray(stderr) ? [...stdout, ...stderr] : [...stdout, stripNewline(stderr, options, "all")];
  }
  if (Array.isArray(stderr)) {
    return [stripNewline(stdout, options, "all"), ...stderr];
  }
  if (isUint8Array(stdout) && isUint8Array(stderr)) {
    return concatUint8Arrays([stdout, stderr]);
  }
  return `${stdout}${stderr}`;
};

// node_modules/execa/lib/resolve/exit-async.js
import {once as once4} from "node:events";
var waitForExit = async (subprocess, context) => {
  const [exitCode, signal5] = await waitForExitOrError(subprocess);
  context.isForcefullyTerminated ??= false;
  return [exitCode, signal5];
};
var waitForExitOrError = async (subprocess) => {
  const [spawnPayload, exitPayload] = await Promise.allSettled([
    once4(subprocess, "spawn"),
    once4(subprocess, "exit")
  ]);
  if (spawnPayload.status === "rejected") {
    return [];
  }
  return exitPayload.status === "rejected" ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
var waitForSubprocessExit = async (subprocess) => {
  try {
    return await once4(subprocess, "exit");
  } catch {
    return waitForSubprocessExit(subprocess);
  }
};
var waitForSuccessfulExit = async (exitPromise) => {
  const [exitCode, signal5] = await exitPromise;
  if (!isSubprocessErrorExit(exitCode, signal5) && isFailedExit(exitCode, signal5)) {
    throw new DiscardedError;
  }
  return [exitCode, signal5];
};
var isSubprocessErrorExit = (exitCode, signal5) => exitCode === undefined && signal5 === undefined;
var isFailedExit = (exitCode, signal5) => exitCode !== 0 || signal5 !== null;

// node_modules/execa/lib/resolve/exit-sync.js
var getExitResultSync = ({ error: error2, status: exitCode, signal: signal5, output: output2 }, { maxBuffer }) => {
  const resultError = getResultError(error2, exitCode, signal5);
  const timedOut = resultError?.code === "ETIMEDOUT";
  const isMaxBuffer = isMaxBufferSync(resultError, output2, maxBuffer);
  return {
    resultError,
    exitCode,
    signal: signal5,
    timedOut,
    isMaxBuffer
  };
};
var getResultError = (error2, exitCode, signal5) => {
  if (error2 !== undefined) {
    return error2;
  }
  return isFailedExit(exitCode, signal5) ? new DiscardedError : undefined;
};

// node_modules/execa/lib/methods/main-sync.js
var execaCoreSync = (rawFile, rawArguments, rawOptions) => {
  const { file, commandArguments, command: command2, escapedCommand, startTime, verboseInfo, options: options2, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
  const result2 = spawnSubprocessSync({
    file,
    commandArguments,
    options: options2,
    command: command2,
    escapedCommand,
    verboseInfo,
    fileDescriptors,
    startTime
  });
  return handleResult(result2, verboseInfo, options2);
};
var handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command: command2, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const syncOptions = normalizeSyncOptions(rawOptions);
  const { file, commandArguments, options: options2 } = normalizeOptions(rawFile, rawArguments, syncOptions);
  validateSyncOptions(options2);
  const fileDescriptors = handleStdioSync(options2, verboseInfo);
  return {
    file,
    commandArguments,
    command: command2,
    escapedCommand,
    startTime,
    verboseInfo,
    options: options2,
    fileDescriptors
  };
};
var normalizeSyncOptions = (options2) => options2.node && !options2.ipc ? { ...options2, ipc: false } : options2;
var validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal }) => {
  if (ipcInput) {
    throwInvalidSyncOption("ipcInput");
  }
  if (ipc) {
    throwInvalidSyncOption("ipc: true");
  }
  if (detached) {
    throwInvalidSyncOption("detached: true");
  }
  if (cancelSignal) {
    throwInvalidSyncOption("cancelSignal");
  }
};
var throwInvalidSyncOption = (value) => {
  throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};
var spawnSubprocessSync = ({ file, commandArguments, options: options2, command: command2, escapedCommand, verboseInfo, fileDescriptors, startTime }) => {
  const syncResult = runSubprocessSync({
    file,
    commandArguments,
    options: options2,
    command: command2,
    escapedCommand,
    fileDescriptors,
    startTime
  });
  if (syncResult.failed) {
    return syncResult;
  }
  const { resultError, exitCode, signal: signal5, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options2);
  const { output: output2, error: error2 = resultError } = transformOutputSync({
    fileDescriptors,
    syncResult,
    options: options2,
    isMaxBuffer,
    verboseInfo
  });
  const stdio = output2.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options2, fdNumber));
  const all = stripNewline(getAllSync(output2, options2), options2, "all");
  return getSyncResult({
    error: error2,
    exitCode,
    signal: signal5,
    timedOut,
    isMaxBuffer,
    stdio,
    all,
    options: options2,
    command: command2,
    escapedCommand,
    startTime
  });
};
var runSubprocessSync = ({ file, commandArguments, options: options2, command: command2, escapedCommand, fileDescriptors, startTime }) => {
  try {
    addInputOptionsSync(fileDescriptors, options2);
    const normalizedOptions = normalizeSpawnSyncOptions(options2);
    return spawnSync(file, commandArguments, normalizedOptions);
  } catch (error2) {
    return makeEarlyError({
      error: error2,
      command: command2,
      escapedCommand,
      fileDescriptors,
      options: options2,
      startTime,
      isSync: true
    });
  }
};
var normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options2 }) => ({ ...options2, encoding: "buffer", maxBuffer: getMaxBufferSync(maxBuffer) });
var getSyncResult = ({ error: error2, exitCode, signal: signal5, timedOut, isMaxBuffer, stdio, all, options: options2, command: command2, escapedCommand, startTime }) => error2 === undefined ? makeSuccessResult({
  command: command2,
  escapedCommand,
  stdio,
  all,
  ipcOutput: [],
  options: options2,
  startTime
}) : makeError({
  error: error2,
  command: command2,
  escapedCommand,
  timedOut,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer,
  isForcefullyTerminated: false,
  exitCode,
  signal: signal5,
  stdio,
  all,
  ipcOutput: [],
  options: options2,
  startTime,
  isSync: true
});

// node_modules/execa/lib/methods/main-async.js
import {setMaxListeners} from "node:events";
import {spawn} from "node:child_process";

// node_modules/execa/lib/ipc/methods.js
import process8 from "node:process";

// node_modules/execa/lib/ipc/get-one.js
import {once as once5, on as on2} from "node:events";
var getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference: reference4 = true, filter } = {}) => {
  validateIpcMethod({
    methodName: "getOneMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  return getOneMessageAsync({
    anyProcess,
    channel,
    isSubprocess,
    filter,
    reference: reference4
  });
};
var getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter, reference: reference4 }) => {
  addReference(channel, reference4);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  try {
    return await Promise.race([
      getMessage(ipcEmitter, filter, controller),
      throwOnDisconnect2(ipcEmitter, isSubprocess, controller),
      throwOnStrictError(ipcEmitter, isSubprocess, controller)
    ]);
  } catch (error2) {
    disconnect(anyProcess);
    throw error2;
  } finally {
    controller.abort();
    removeReference(channel, reference4);
  }
};
var getMessage = async (ipcEmitter, filter, { signal: signal5 }) => {
  if (filter === undefined) {
    const [message2] = await once5(ipcEmitter, "message", { signal: signal5 });
    return message2;
  }
  for await (const [message2] of on2(ipcEmitter, "message", { signal: signal5 })) {
    if (filter(message2)) {
      return message2;
    }
  }
};
var throwOnDisconnect2 = async (ipcEmitter, isSubprocess, { signal: signal5 }) => {
  await once5(ipcEmitter, "disconnect", { signal: signal5 });
  throwOnEarlyDisconnect(isSubprocess);
};
var throwOnStrictError = async (ipcEmitter, isSubprocess, { signal: signal5 }) => {
  const [error2] = await once5(ipcEmitter, "strict:error", { signal: signal5 });
  throw getStrictResponseError(error2, isSubprocess);
};

// node_modules/execa/lib/ipc/get-each.js
import {once as once6, on as on3} from "node:events";
var getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference: reference5 = true } = {}) => loopOnMessages({
  anyProcess,
  channel,
  isSubprocess,
  ipc,
  shouldAwait: !isSubprocess,
  reference: reference5
});
var loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference: reference5 }) => {
  validateIpcMethod({
    methodName: "getEachMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  addReference(channel, reference5);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController;
  const state = {};
  stopOnDisconnect(anyProcess, ipcEmitter, controller);
  abortOnStrictError({
    ipcEmitter,
    isSubprocess,
    controller,
    state
  });
  return iterateOnMessages({
    anyProcess,
    channel,
    ipcEmitter,
    isSubprocess,
    shouldAwait,
    controller,
    state,
    reference: reference5
  });
};
var stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
  try {
    await once6(ipcEmitter, "disconnect", { signal: controller.signal });
    controller.abort();
  } catch {
  }
};
var abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state }) => {
  try {
    const [error2] = await once6(ipcEmitter, "strict:error", { signal: controller.signal });
    state.error = getStrictResponseError(error2, isSubprocess);
    controller.abort();
  } catch {
  }
};
var iterateOnMessages = async function* ({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference: reference5 }) {
  try {
    for await (const [message2] of on3(ipcEmitter, "message", { signal: controller.signal })) {
      throwIfStrictError(state);
      yield message2;
    }
  } catch {
    throwIfStrictError(state);
  } finally {
    controller.abort();
    removeReference(channel, reference5);
    if (!isSubprocess) {
      disconnect(anyProcess);
    }
    if (shouldAwait) {
      await anyProcess;
    }
  }
};
var throwIfStrictError = ({ error: error2 }) => {
  if (error2) {
    throw error2;
  }
};

// node_modules/execa/lib/ipc/methods.js
var addIpcMethods = (subprocess, { ipc }) => {
  Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
var getIpcExport = () => {
  const anyProcess = process8;
  const isSubprocess = true;
  const ipc = process8.channel !== undefined;
  return {
    ...getIpcMethods(anyProcess, isSubprocess, ipc),
    getCancelSignal: getCancelSignal.bind(undefined, {
      anyProcess,
      channel: anyProcess.channel,
      isSubprocess,
      ipc
    })
  };
};
var getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
  sendMessage: sendMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getOneMessage: getOneMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getEachMessage: getEachMessage.bind(undefined, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  })
});

// node_modules/execa/lib/return/early-error.js
import {ChildProcess as ChildProcess2} from "node:child_process";
import {
PassThrough,
Readable,
Writable,
Duplex
} from "node:stream";
var handleEarlyError = ({ error: error2, command: command2, escapedCommand, fileDescriptors, options: options2, startTime, verboseInfo }) => {
  cleanupCustomStreams(fileDescriptors);
  const subprocess = new ChildProcess2;
  createDummyStreams(subprocess, fileDescriptors);
  Object.assign(subprocess, { readable, writable, duplex });
  const earlyError = makeEarlyError({
    error: error2,
    command: command2,
    escapedCommand,
    fileDescriptors,
    options: options2,
    startTime,
    isSync: false
  });
  const promise = handleDummyPromise(earlyError, verboseInfo, options2);
  return { subprocess, promise };
};
var createDummyStreams = (subprocess, fileDescriptors) => {
  const stdin = createDummyStream();
  const stdout = createDummyStream();
  const stderr = createDummyStream();
  const extraStdio = Array.from({ length: fileDescriptors.length - 3 }, createDummyStream);
  const all = createDummyStream();
  const stdio = [stdin, stdout, stderr, ...extraStdio];
  Object.assign(subprocess, {
    stdin,
    stdout,
    stderr,
    all,
    stdio
  });
};
var createDummyStream = () => {
  const stream3 = new PassThrough;
  stream3.end();
  return stream3;
};
var readable = () => new Readable({ read() {
} });
var writable = () => new Writable({ write() {
} });
var duplex = () => new Duplex({ read() {
}, write() {
} });
var handleDummyPromise = async (error2, verboseInfo, options2) => handleResult(error2, verboseInfo, options2);

// node_modules/execa/lib/stdio/handle-async.js
import {createReadStream, createWriteStream} from "node:fs";
import {Buffer as Buffer4} from "node:buffer";
import {Readable as Readable2, Writable as Writable2, Duplex as Duplex2} from "node:stream";
var handleStdioAsync = (options2, verboseInfo) => handleStdio(addPropertiesAsync, options2, verboseInfo, false);
var forbiddenIfAsync = ({ type: type13, optionName }) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type13]}.`);
};
var addProperties2 = {
  fileNumber: forbiddenIfAsync,
  generator: generatorToStream,
  asyncGenerator: generatorToStream,
  nodeStream: ({ value }) => ({ stream: value }),
  webTransform({ value: { transform, writableObjectMode, readableObjectMode } }) {
    const objectMode = writableObjectMode || readableObjectMode;
    const stream3 = Duplex2.fromWeb(transform, { objectMode });
    return { stream: stream3 };
  },
  duplex: ({ value: { transform } }) => ({ stream: transform }),
  native() {
  }
};
var addPropertiesAsync = {
  input: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: createReadStream(value) }),
    filePath: ({ value: { file } }) => ({ stream: createReadStream(file) }),
    webStream: ({ value }) => ({ stream: Readable2.fromWeb(value) }),
    iterable: ({ value }) => ({ stream: Readable2.from(value) }),
    asyncIterable: ({ value }) => ({ stream: Readable2.from(value) }),
    string: ({ value }) => ({ stream: Readable2.from(value) }),
    uint8Array: ({ value }) => ({ stream: Readable2.from(Buffer4.from(value)) })
  },
  output: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: createWriteStream(value) }),
    filePath: ({ value: { file } }) => ({ stream: createWriteStream(file) }),
    webStream: ({ value }) => ({ stream: Writable2.fromWeb(value) }),
    iterable: forbiddenIfAsync,
    asyncIterable: forbiddenIfAsync,
    string: forbiddenIfAsync,
    uint8Array: forbiddenIfAsync
  }
};

// node_modules/@sindresorhus/merge-streams/index.js
import {on as on4, once as once7} from "node:events";
import {PassThrough as PassThroughStream, getDefaultHighWaterMark as getDefaultHighWaterMark2} from "node:stream";
import {finished as finished2} from "node:stream/promises";
function mergeStreams(streams) {
  if (!Array.isArray(streams)) {
    throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
  }
  for (const stream3 of streams) {
    validateStream(stream3);
  }
  const objectMode = streams.some(({ readableObjectMode }) => readableObjectMode);
  const highWaterMark = getHighWaterMark(streams, objectMode);
  const passThroughStream = new MergedStream({
    objectMode,
    writableHighWaterMark: highWaterMark,
    readableHighWaterMark: highWaterMark
  });
  for (const stream3 of streams) {
    passThroughStream.add(stream3);
  }
  return passThroughStream;
}
var getHighWaterMark = (streams, objectMode) => {
  if (streams.length === 0) {
    return getDefaultHighWaterMark2(objectMode);
  }
  const highWaterMarks = streams.filter(({ readableObjectMode }) => readableObjectMode === objectMode).map(({ readableHighWaterMark }) => readableHighWaterMark);
  return Math.max(...highWaterMarks);
};

class MergedStream extends PassThroughStream {
  #streams = new Set([]);
  #ended = new Set([]);
  #aborted = new Set([]);
  #onFinished;
  #unpipeEvent = Symbol("unpipe");
  #streamPromises = new WeakMap;
  add(stream3) {
    validateStream(stream3);
    if (this.#streams.has(stream3)) {
      return;
    }
    this.#streams.add(stream3);
    this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
    const streamPromise = endWhenStreamsDone({
      passThroughStream: this,
      stream: stream3,
      streams: this.#streams,
      ended: this.#ended,
      aborted: this.#aborted,
      onFinished: this.#onFinished,
      unpipeEvent: this.#unpipeEvent
    });
    this.#streamPromises.set(stream3, streamPromise);
    stream3.pipe(this, { end: false });
  }
  async remove(stream3) {
    validateStream(stream3);
    if (!this.#streams.has(stream3)) {
      return false;
    }
    const streamPromise = this.#streamPromises.get(stream3);
    if (streamPromise === undefined) {
      return false;
    }
    this.#streamPromises.delete(stream3);
    stream3.unpipe(this);
    await streamPromise;
    return true;
  }
}
var onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
  const controller = new AbortController;
  try {
    await Promise.race([
      onMergedStreamEnd(passThroughStream, controller),
      onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
  }
};
var onMergedStreamEnd = async (passThroughStream, { signal: signal5 }) => {
  try {
    await finished2(passThroughStream, { signal: signal5, cleanup: true });
  } catch (error2) {
    errorOrAbortStream(passThroughStream, error2);
    throw error2;
  }
};
var onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal: signal5 }) => {
  for await (const [unpipedStream] of on4(passThroughStream, "unpipe", { signal: signal5 })) {
    if (streams.has(unpipedStream)) {
      unpipedStream.emit(unpipeEvent);
    }
  }
};
var validateStream = (stream3) => {
  if (typeof stream3?.pipe !== "function") {
    throw new TypeError(`Expected a readable stream, got: \`${typeof stream3}\`.`);
  }
};
var endWhenStreamsDone = async ({ passThroughStream, stream: stream3, streams, ended, aborted, onFinished, unpipeEvent }) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
  const controller = new AbortController;
  try {
    await Promise.race([
      afterMergedStreamFinished(onFinished, stream3, controller),
      onInputStreamEnd({
        passThroughStream,
        stream: stream3,
        streams,
        ended,
        aborted,
        controller
      }),
      onInputStreamUnpipe({
        stream: stream3,
        streams,
        ended,
        aborted,
        unpipeEvent,
        controller
      })
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
  }
  if (streams.size > 0 && streams.size === ended.size + aborted.size) {
    if (ended.size === 0 && aborted.size > 0) {
      abortStream(passThroughStream);
    } else {
      endStream(passThroughStream);
    }
  }
};
var afterMergedStreamFinished = async (onFinished, stream3, { signal: signal5 }) => {
  try {
    await onFinished;
    if (!signal5.aborted) {
      abortStream(stream3);
    }
  } catch (error2) {
    if (!signal5.aborted) {
      errorOrAbortStream(stream3, error2);
    }
  }
};
var onInputStreamEnd = async ({ passThroughStream, stream: stream3, streams, ended, aborted, controller: { signal: signal5 } }) => {
  try {
    await finished2(stream3, {
      signal: signal5,
      cleanup: true,
      readable: true,
      writable: false
    });
    if (streams.has(stream3)) {
      ended.add(stream3);
    }
  } catch (error2) {
    if (signal5.aborted || !streams.has(stream3)) {
      return;
    }
    if (isAbortError(error2)) {
      aborted.add(stream3);
    } else {
      errorStream(passThroughStream, error2);
    }
  }
};
var onInputStreamUnpipe = async ({ stream: stream3, streams, ended, aborted, unpipeEvent, controller: { signal: signal5 } }) => {
  await once7(stream3, unpipeEvent, { signal: signal5 });
  if (!stream3.readable) {
    return once7(signal5, "abort", { signal: signal5 });
  }
  streams.delete(stream3);
  ended.delete(stream3);
  aborted.delete(stream3);
};
var endStream = (stream3) => {
  if (stream3.writable) {
    stream3.end();
  }
};
var errorOrAbortStream = (stream3, error2) => {
  if (isAbortError(error2)) {
    abortStream(stream3);
  } else {
    errorStream(stream3, error2);
  }
};
var isAbortError = (error2) => error2?.code === "ERR_STREAM_PREMATURE_CLOSE";
var abortStream = (stream3) => {
  if (stream3.readable || stream3.writable) {
    stream3.destroy();
  }
};
var errorStream = (stream3, error2) => {
  if (!stream3.destroyed) {
    stream3.once("error", noop2);
    stream3.destroy(error2);
  }
};
var noop2 = () => {
};
var updateMaxListeners = (passThroughStream, increment2) => {
  const maxListeners = passThroughStream.getMaxListeners();
  if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {
    passThroughStream.setMaxListeners(maxListeners + increment2);
  }
};
var PASSTHROUGH_LISTENERS_COUNT = 2;
var PASSTHROUGH_LISTENERS_PER_STREAM = 1;

// node_modules/execa/lib/io/pipeline.js
import {finished as finished3} from "node:stream/promises";
var pipeStreams = (source, destination) => {
  source.pipe(destination);
  onSourceFinish(source, destination);
  onDestinationFinish(source, destination);
};
var onSourceFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(source, { cleanup: true, readable: true, writable: false });
  } catch {
  }
  endDestinationStream(destination);
};
var endDestinationStream = (destination) => {
  if (destination.writable) {
    destination.end();
  }
};
var onDestinationFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await finished3(destination, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  abortSourceStream(source);
};
var abortSourceStream = (source) => {
  if (source.readable) {
    source.destroy();
  }
};

// node_modules/execa/lib/io/output-async.js
var pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
  const pipeGroups = new Map;
  for (const [fdNumber, { stdioItems, direction: direction2 }] of Object.entries(fileDescriptors)) {
    for (const { stream: stream3 } of stdioItems.filter(({ type: type14 }) => TRANSFORM_TYPES.has(type14))) {
      pipeTransform(subprocess, stream3, direction2, fdNumber);
    }
    for (const { stream: stream3 } of stdioItems.filter(({ type: type14 }) => !TRANSFORM_TYPES.has(type14))) {
      pipeStdioItem({
        subprocess,
        stream: stream3,
        direction: direction2,
        fdNumber,
        pipeGroups,
        controller
      });
    }
  }
  for (const [outputStream, inputStreams] of pipeGroups.entries()) {
    const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
    pipeStreams(inputStream, outputStream);
  }
};
var pipeTransform = (subprocess, stream3, direction2, fdNumber) => {
  if (direction2 === "output") {
    pipeStreams(subprocess.stdio[fdNumber], stream3);
  } else {
    pipeStreams(stream3, subprocess.stdio[fdNumber]);
  }
  const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
  if (streamProperty !== undefined) {
    subprocess[streamProperty] = stream3;
  }
  subprocess.stdio[fdNumber] = stream3;
};
var SUBPROCESS_STREAM_PROPERTIES = ["stdin", "stdout", "stderr"];
var pipeStdioItem = ({ subprocess, stream: stream3, direction: direction2, fdNumber, pipeGroups, controller }) => {
  if (stream3 === undefined) {
    return;
  }
  setStandardStreamMaxListeners(stream3, controller);
  const [inputStream, outputStream] = direction2 === "output" ? [stream3, subprocess.stdio[fdNumber]] : [subprocess.stdio[fdNumber], stream3];
  const outputStreams = pipeGroups.get(inputStream) ?? [];
  pipeGroups.set(inputStream, [...outputStreams, outputStream]);
};
var setStandardStreamMaxListeners = (stream3, { signal: signal5 }) => {
  if (isStandardStream(stream3)) {
    incrementMaxListeners(stream3, MAX_LISTENERS_INCREMENT, signal5);
  }
};
var MAX_LISTENERS_INCREMENT = 2;

// node_modules/execa/lib/terminate/cleanup.js
import {addAbortListener as addAbortListener2} from "node:events";

// node_modules/signal-exit/dist/mjs/signals.js
var signals2 = [];
signals2.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") {
  signals2.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
}
if (process.platform === "linux") {
  signals2.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
}

// node_modules/signal-exit/dist/mjs/index.js
var processOk = (process9) => !!process9 && typeof process9 === "object" && typeof process9.removeListener === "function" && typeof process9.emit === "function" && typeof process9.reallyExit === "function" && typeof process9.listeners === "function" && typeof process9.kill === "function" && typeof process9.pid === "number" && typeof process9.on === "function";
var kExitEmitter = Symbol.for("signal-exit emitter");
var global2 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);

class Emitter {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i2 = list.indexOf(fn);
    if (i2 === -1) {
      return;
    }
    if (i2 === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i2, 1);
    }
  }
  emit(ev, code, signal5) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal5) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code, signal5) || ret;
    }
    return ret;
  }
}

class SignalExitBase {
}
var signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
};

class SignalExitFallback extends SignalExitBase {
  onExit() {
    return () => {
    };
  }
  load() {
  }
  unload() {
  }
}

class SignalExit extends SignalExitBase {
  #hupSig = process9.platform === "win32" ? "SIGINT" : "SIGHUP";
  #emitter = new Emitter;
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = false;
  constructor(process9) {
    super();
    this.#process = process9;
    this.#sigListeners = {};
    for (const sig of signals2) {
      this.#sigListeners[sig] = () => {
        const listeners = this.#process.listeners(sig);
        let { count: count2 } = this.#emitter;
        const p = process9;
        if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
          count2 += p.__signal_exit_emitter__.count;
        }
        if (listeners.length === count2) {
          this.unload();
          const ret = this.#emitter.emit("exit", null, sig);
          const s = sig === "SIGHUP" ? this.#hupSig : sig;
          if (!ret)
            process9.kill(process9.pid, s);
        }
      };
    }
    this.#originalProcessReallyExit = process9.reallyExit;
    this.#originalProcessEmit = process9.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process)) {
      return () => {
      };
    }
    if (this.#loaded === false) {
      this.load();
    }
    const ev = opts?.alwaysLast ? "afterExit" : "exit";
    this.#emitter.on(ev, cb);
    return () => {
      this.#emitter.removeListener(ev, cb);
      if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#loaded) {
      return;
    }
    this.#loaded = true;
    this.#emitter.count += 1;
    for (const sig of signals2) {
      try {
        const fn = this.#sigListeners[sig];
        if (fn)
          this.#process.on(sig, fn);
      } catch (_) {
      }
    }
    this.#process.emit = (ev, ...a2) => {
      return this.#processEmit(ev, ...a2);
    };
    this.#process.reallyExit = (code) => {
      return this.#processReallyExit(code);
    };
  }
  unload() {
    if (!this.#loaded) {
      return;
    }
    this.#loaded = false;
    signals2.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener) {
        throw new Error("Listener not defined for signal: " + sig);
      }
      try {
        this.#process.removeListener(sig, listener);
      } catch (_) {
      }
    });
    this.#process.emit = this.#originalProcessEmit;
    this.#process.reallyExit = this.#originalProcessReallyExit;
    this.#emitter.count -= 1;
  }
  #processReallyExit(code) {
    if (!processOk(this.#process)) {
      return 0;
    }
    this.#process.exitCode = code || 0;
    this.#emitter.emit("exit", this.#process.exitCode, null);
    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === "exit" && processOk(this.#process)) {
      if (typeof args[0] === "number") {
        this.#process.exitCode = args[0];
      }
      const ret = og.call(this.#process, ev, ...args);
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return ret;
    } else {
      return og.call(this.#process, ev, ...args);
    }
  }
}
var process9 = globalThis.process;
var {
  onExit,
  load,
  unload
} = signalExitWrap(processOk(process9) ? new SignalExit(process9) : new SignalExitFallback);

// node_modules/execa/lib/terminate/cleanup.js
var cleanupOnExit = (subprocess, { cleanup, detached }, { signal: signal5 }) => {
  if (!cleanup || detached) {
    return;
  }
  const removeExitHandler = onExit(() => {
    subprocess.kill();
  });
  addAbortListener2(signal5, () => {
    removeExitHandler();
  });
};

// node_modules/execa/lib/pipe/pipe-arguments.js
var normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments) => {
  const startTime = getStartTime();
  const {
    destination,
    destinationStream,
    destinationError,
    from,
    unpipeSignal
  } = getDestinationStream(boundOptions, createNested, pipeArguments);
  const { sourceStream, sourceError } = getSourceStream(source, from);
  const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  return {
    sourcePromise,
    sourceStream,
    sourceOptions,
    sourceError,
    destination,
    destinationStream,
    destinationError,
    unpipeSignal,
    fileDescriptors,
    startTime
  };
};
var getDestinationStream = (boundOptions, createNested, pipeArguments) => {
  try {
    const {
      destination,
      pipeOptions: { from, to, unpipeSignal } = {}
    } = getDestination(boundOptions, createNested, ...pipeArguments);
    const destinationStream = getToStream(destination, to);
    return {
      destination,
      destinationStream,
      from,
      unpipeSignal
    };
  } catch (error2) {
    return { destinationError: error2 };
  }
};
var getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
  if (Array.isArray(firstArgument)) {
    const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
    return { destination, pipeOptions: boundOptions };
  }
  if (typeof firstArgument === "string" || firstArgument instanceof URL) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
    }
    const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
    const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
    return { destination, pipeOptions: rawOptions };
  }
  if (SUBPROCESS_OPTIONS.has(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");
    }
    return { destination: firstArgument, pipeOptions: pipeArguments[0] };
  }
  throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};
var mapDestinationArguments = ({ options: options2 }) => ({ options: { ...options2, stdin: "pipe", piped: true } });
var getSourceStream = (source, from) => {
  try {
    const sourceStream = getFromStream(source, from);
    return { sourceStream };
  } catch (error2) {
    return { sourceError: error2 };
  }
};

// node_modules/execa/lib/pipe/throw.js
var handlePipeArgumentsError = ({
  sourceStream,
  sourceError,
  destinationStream,
  destinationError,
  fileDescriptors,
  sourceOptions,
  startTime
}) => {
  const error2 = getPipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError
  });
  if (error2 !== undefined) {
    throw createNonCommandError({
      error: error2,
      fileDescriptors,
      sourceOptions,
      startTime
    });
  }
};
var getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError }) => {
  if (sourceError !== undefined && destinationError !== undefined) {
    return destinationError;
  }
  if (destinationError !== undefined) {
    abortSourceStream(sourceStream);
    return destinationError;
  }
  if (sourceError !== undefined) {
    endDestinationStream(destinationStream);
    return sourceError;
  }
};
var createNonCommandError = ({ error: error2, fileDescriptors, sourceOptions, startTime }) => makeEarlyError({
  error: error2,
  command: PIPE_COMMAND_MESSAGE,
  escapedCommand: PIPE_COMMAND_MESSAGE,
  fileDescriptors,
  options: sourceOptions,
  startTime,
  isSync: false
});
var PIPE_COMMAND_MESSAGE = "source.pipe(destination)";

// node_modules/execa/lib/pipe/sequence.js
var waitForBothSubprocesses = async (subprocessPromises) => {
  const [
    { status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason },
    { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }
  ] = await subprocessPromises;
  if (!destinationResult.pipedFrom.includes(sourceResult)) {
    destinationResult.pipedFrom.push(sourceResult);
  }
  if (destinationStatus === "rejected") {
    throw destinationResult;
  }
  if (sourceStatus === "rejected") {
    throw sourceResult;
  }
  return destinationResult;
};

// node_modules/execa/lib/pipe/streaming.js
import {finished as finished4} from "node:stream/promises";
var pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
  const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
  incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
  incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
  cleanupMergedStreamsMap(destinationStream);
  return mergedStream;
};
var pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = mergeStreams([sourceStream]);
  pipeStreams(mergedStream, destinationStream);
  MERGED_STREAMS.set(destinationStream, mergedStream);
  return mergedStream;
};
var pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = MERGED_STREAMS.get(destinationStream);
  mergedStream.add(sourceStream);
  return mergedStream;
};
var cleanupMergedStreamsMap = async (destinationStream) => {
  try {
    await finished4(destinationStream, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  MERGED_STREAMS.delete(destinationStream);
};
var MERGED_STREAMS = new WeakMap;
var SOURCE_LISTENERS_PER_PIPE = 2;
var DESTINATION_LISTENERS_PER_PIPE = 1;

// node_modules/execa/lib/pipe/abort.js
import {aborted} from "node:util";
var unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined ? [] : [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];
var unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime }) => {
  await aborted(unpipeSignal, sourceStream);
  await mergedStream.remove(sourceStream);
  const error2 = new Error("Pipe canceled by `unpipeSignal` option.");
  throw createNonCommandError({
    error: error2,
    fileDescriptors,
    sourceOptions,
    startTime
  });
};

// node_modules/execa/lib/pipe/setup.js
var pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
  if (isPlainObject(pipeArguments[0])) {
    return pipeToSubprocess.bind(undefined, {
      ...sourceInfo,
      boundOptions: { ...sourceInfo.boundOptions, ...pipeArguments[0] }
    });
  }
  const { destination, ...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
  const promise = handlePipePromise({ ...normalizedInfo, destination });
  promise.pipe = pipeToSubprocess.bind(undefined, {
    ...sourceInfo,
    source: destination,
    sourcePromise: promise,
    boundOptions: {}
  });
  return promise;
};
var handlePipePromise = async ({
  sourcePromise,
  sourceStream,
  sourceOptions,
  sourceError,
  destination,
  destinationStream,
  destinationError,
  unpipeSignal,
  fileDescriptors,
  startTime
}) => {
  const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
  handlePipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError,
    fileDescriptors,
    sourceOptions,
    startTime
  });
  const maxListenersController = new AbortController;
  try {
    const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
    return await Promise.race([
      waitForBothSubprocesses(subprocessPromises),
      ...unpipeOnAbort(unpipeSignal, {
        sourceStream,
        mergedStream,
        sourceOptions,
        fileDescriptors,
        startTime
      })
    ]);
  } finally {
    maxListenersController.abort();
  }
};
var getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);

// node_modules/execa/lib/io/contents.js
import {setImmediate as setImmediate2} from "node:timers/promises";

// node_modules/execa/lib/io/iterate.js
import {on as on5} from "node:events";
import {getDefaultHighWaterMark as getDefaultHighWaterMark3} from "node:stream";
var iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines }) => {
  const controller = new AbortController;
  stopReadingOnExit(subprocess, controller);
  return iterateOnStream({
    stream: subprocessStdout,
    controller,
    binary,
    shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
    encoding,
    shouldSplit: !subprocessStdout.readableObjectMode,
    preserveNewlines
  });
};
var stopReadingOnExit = async (subprocess, controller) => {
  try {
    await subprocess;
  } catch {
  } finally {
    controller.abort();
  }
};
var iterateForResult = ({ stream: stream3, onStreamEnd, lines, encoding, stripFinalNewline: stripFinalNewline2, allMixed }) => {
  const controller = new AbortController;
  stopReadingOnStreamEnd(onStreamEnd, controller, stream3);
  const objectMode = stream3.readableObjectMode && !allMixed;
  return iterateOnStream({
    stream: stream3,
    controller,
    binary: encoding === "buffer",
    shouldEncode: !objectMode,
    encoding,
    shouldSplit: !objectMode && lines,
    preserveNewlines: !stripFinalNewline2
  });
};
var stopReadingOnStreamEnd = async (onStreamEnd, controller, stream3) => {
  try {
    await onStreamEnd;
  } catch {
    stream3.destroy();
  } finally {
    controller.abort();
  }
};
var iterateOnStream = ({ stream: stream3, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => {
  const onStdoutChunk = on5(stream3, "data", {
    signal: controller.signal,
    highWaterMark: HIGH_WATER_MARK,
    highWatermark: HIGH_WATER_MARK
  });
  return iterateOnData({
    onStdoutChunk,
    controller,
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
};
var DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark3(true);
var HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
var iterateOnData = async function* ({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
  const generators = getGenerators({
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
  try {
    for await (const [chunk] of onStdoutChunk) {
      yield* transformChunkSync(chunk, generators, 0);
    }
  } catch (error2) {
    if (!controller.signal.aborted) {
      throw error2;
    }
  } finally {
    yield* finalChunksSync(generators);
  }
};
var getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => [
  getEncodingTransformGenerator(binary, encoding, !shouldEncode),
  getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})
].filter(Boolean);

// node_modules/execa/lib/io/contents.js
var getStreamOutput = async ({ stream: stream3, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  const logPromise = logOutputAsync({
    stream: stream3,
    onStreamEnd,
    fdNumber,
    encoding,
    allMixed,
    verboseInfo,
    streamInfo
  });
  if (!buffer) {
    await Promise.all([resumeStream(stream3), logPromise]);
    return;
  }
  const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline2, fdNumber);
  const iterable = iterateForResult({
    stream: stream3,
    onStreamEnd,
    lines,
    encoding,
    stripFinalNewline: stripFinalNewlineValue,
    allMixed
  });
  const [output3] = await Promise.all([
    getStreamContents2({
      stream: stream3,
      iterable,
      fdNumber,
      encoding,
      maxBuffer,
      lines
    }),
    logPromise
  ]);
  return output3;
};
var logOutputAsync = async ({ stream: stream3, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } }) => {
  if (!shouldLogOutput({
    stdioItems: fileDescriptors[fdNumber]?.stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesIterable = iterateForResult({
    stream: stream3,
    onStreamEnd,
    lines: true,
    encoding,
    stripFinalNewline: true,
    allMixed
  });
  await logLines(linesIterable, stream3, fdNumber, verboseInfo);
};
var resumeStream = async (stream3) => {
  await setImmediate2();
  if (stream3.readableFlowing === null) {
    stream3.resume();
  }
};
var getStreamContents2 = async ({ stream: stream3, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines }) => {
  try {
    if (readableObjectMode || lines) {
      return await getStreamAsArray(iterable, { maxBuffer });
    }
    if (encoding === "buffer") {
      return new Uint8Array(await getStreamAsArrayBuffer(iterable, { maxBuffer }));
    }
    return await getStreamAsString(iterable, { maxBuffer });
  } catch (error2) {
    return handleBufferedData(handleMaxBuffer({
      error: error2,
      stream: stream3,
      readableObjectMode,
      lines,
      encoding,
      fdNumber
    }));
  }
};
var getBufferedData = async (streamPromise) => {
  try {
    return await streamPromise;
  } catch (error2) {
    return handleBufferedData(error2);
  }
};
var handleBufferedData = ({ bufferedData }) => isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;

// node_modules/execa/lib/resolve/wait-stream.js
import {finished as finished5} from "node:stream/promises";
var waitForStream = async (stream3, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {}) => {
  const state = handleStdinDestroy(stream3, streamInfo);
  const abortController = new AbortController;
  try {
    await Promise.race([
      ...stopOnExit ? [streamInfo.exitPromise] : [],
      finished5(stream3, { cleanup: true, signal: abortController.signal })
    ]);
  } catch (error2) {
    if (!state.stdinCleanedUp) {
      handleStreamError(error2, fdNumber, streamInfo, isSameDirection);
    }
  } finally {
    abortController.abort();
  }
};
var handleStdinDestroy = (stream3, { originalStreams: [originalStdin], subprocess }) => {
  const state = { stdinCleanedUp: false };
  if (stream3 === originalStdin) {
    spyOnStdinDestroy(stream3, subprocess, state);
  }
  return state;
};
var spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
  const { _destroy } = subprocessStdin;
  subprocessStdin._destroy = (...destroyArguments) => {
    setStdinCleanedUp(subprocess, state);
    _destroy.call(subprocessStdin, ...destroyArguments);
  };
};
var setStdinCleanedUp = ({ exitCode, signalCode }, state) => {
  if (exitCode !== null || signalCode !== null) {
    state.stdinCleanedUp = true;
  }
};
var handleStreamError = (error2, fdNumber, streamInfo, isSameDirection) => {
  if (!shouldIgnoreStreamError(error2, fdNumber, streamInfo, isSameDirection)) {
    throw error2;
  }
};
var shouldIgnoreStreamError = (error2, fdNumber, streamInfo, isSameDirection = true) => {
  if (streamInfo.propagating) {
    return isStreamEpipe(error2) || isStreamAbort(error2);
  }
  streamInfo.propagating = true;
  return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error2) : isStreamAbort(error2);
};
var isInputFileDescriptor = ({ fileDescriptors }, fdNumber) => fdNumber !== "all" && fileDescriptors[fdNumber].direction === "input";
var isStreamAbort = (error2) => error2?.code === "ERR_STREAM_PREMATURE_CLOSE";
var isStreamEpipe = (error2) => error2?.code === "EPIPE";

// node_modules/execa/lib/resolve/stdio.js
var waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => subprocess.stdio.map((stream3, fdNumber) => waitForSubprocessStream({
  stream: stream3,
  fdNumber,
  encoding,
  buffer: buffer[fdNumber],
  maxBuffer: maxBuffer[fdNumber],
  lines: lines[fdNumber],
  allMixed: false,
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
}));
var waitForSubprocessStream = async ({ stream: stream3, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  if (!stream3) {
    return;
  }
  const onStreamEnd = waitForStream(stream3, fdNumber, streamInfo);
  if (isInputFileDescriptor(streamInfo, fdNumber)) {
    await onStreamEnd;
    return;
  }
  const [output3] = await Promise.all([
    getStreamOutput({
      stream: stream3,
      onStreamEnd,
      fdNumber,
      encoding,
      buffer,
      maxBuffer,
      lines,
      allMixed,
      stripFinalNewline: stripFinalNewline2,
      verboseInfo,
      streamInfo
    }),
    onStreamEnd
  ]);
  return output3;
};

// node_modules/execa/lib/resolve/all-async.js
var makeAllStream = ({ stdout, stderr }, { all }) => all && (stdout || stderr) ? mergeStreams([stdout, stderr].filter(Boolean)) : undefined;
var waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => waitForSubprocessStream({
  ...getAllStream(subprocess, buffer),
  fdNumber: "all",
  encoding,
  maxBuffer: maxBuffer[1] + maxBuffer[2],
  lines: lines[1] || lines[2],
  allMixed: getAllMixed(subprocess),
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
});
var getAllStream = ({ stdout, stderr, all }, [, bufferStdout, bufferStderr]) => {
  const buffer = bufferStdout || bufferStderr;
  if (!buffer) {
    return { stream: all, buffer };
  }
  if (!bufferStdout) {
    return { stream: stderr, buffer };
  }
  if (!bufferStderr) {
    return { stream: stdout, buffer };
  }
  return { stream: all, buffer };
};
var getAllMixed = ({ all, stdout, stderr }) => all && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;

// node_modules/execa/lib/resolve/wait-subprocess.js
import {once as once8} from "node:events";

// node_modules/execa/lib/verbose/ipc.js
var shouldLogIpc = (verboseInfo) => isFullVerbose(verboseInfo, "ipc");
var logIpcOutput = (message2, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(message2);
  verboseLog({
    type: "ipc",
    verboseMessage,
    fdNumber: "ipc",
    verboseInfo
  });
};

// node_modules/execa/lib/ipc/buffer-messages.js
var waitForIpcOutput = async ({
  subprocess,
  buffer: bufferArray,
  maxBuffer: maxBufferArray,
  ipc: ipc2,
  ipcOutput,
  verboseInfo
}) => {
  if (!ipc2) {
    return ipcOutput;
  }
  const isVerbose2 = shouldLogIpc(verboseInfo);
  const buffer = getFdSpecificValue(bufferArray, "ipc");
  const maxBuffer = getFdSpecificValue(maxBufferArray, "ipc");
  for await (const message2 of loopOnMessages({
    anyProcess: subprocess,
    channel: subprocess.channel,
    isSubprocess: false,
    ipc: ipc2,
    shouldAwait: false,
    reference: true
  })) {
    if (buffer) {
      checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
      ipcOutput.push(message2);
    }
    if (isVerbose2) {
      logIpcOutput(message2, verboseInfo);
    }
  }
  return ipcOutput;
};
var getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
  await Promise.allSettled([ipcOutputPromise]);
  return ipcOutput;
};

// node_modules/execa/lib/resolve/wait-subprocess.js
var waitForSubprocessResult = async ({
  subprocess,
  options: {
    encoding,
    buffer,
    maxBuffer,
    lines,
    timeoutDuration: timeout3,
    cancelSignal,
    gracefulCancel,
    forceKillAfterDelay,
    stripFinalNewline: stripFinalNewline2,
    ipc: ipc2,
    ipcInput
  },
  context,
  verboseInfo,
  fileDescriptors,
  originalStreams,
  onInternalError,
  controller
}) => {
  const exitPromise = waitForExit(subprocess, context);
  const streamInfo = {
    originalStreams,
    fileDescriptors,
    subprocess,
    exitPromise,
    propagating: false
  };
  const stdioPromises = waitForStdioStreams({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const allPromise = waitForAllStream({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const ipcOutput = [];
  const ipcOutputPromise = waitForIpcOutput({
    subprocess,
    buffer,
    maxBuffer,
    ipc: ipc2,
    ipcOutput,
    verboseInfo
  });
  const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
  const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
  try {
    return await Promise.race([
      Promise.all([
        {},
        waitForSuccessfulExit(exitPromise),
        Promise.all(stdioPromises),
        allPromise,
        ipcOutputPromise,
        sendIpcInput(subprocess, ipcInput),
        ...originalPromises,
        ...customStreamsEndPromises
      ]),
      onInternalError,
      throwOnSubprocessError(subprocess, controller),
      ...throwOnTimeout(subprocess, timeout3, context, controller),
      ...throwOnCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        context,
        controller
      }),
      ...throwOnGracefulCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        forceKillAfterDelay,
        context,
        controller
      })
    ]);
  } catch (error2) {
    context.terminationReason ??= "other";
    return Promise.all([
      { error: error2 },
      exitPromise,
      Promise.all(stdioPromises.map((stdioPromise) => getBufferedData(stdioPromise))),
      getBufferedData(allPromise),
      getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
      Promise.allSettled(originalPromises),
      Promise.allSettled(customStreamsEndPromises)
    ]);
  }
};
var waitForOriginalStreams = (originalStreams, subprocess, streamInfo) => originalStreams.map((stream3, fdNumber) => stream3 === subprocess.stdio[fdNumber] ? undefined : waitForStream(stream3, fdNumber, streamInfo));
var waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({ stdioItems }, fdNumber) => stdioItems.filter(({ value, stream: stream3 = value }) => isStream(stream3, { checkOpen: false }) && !isStandardStream(stream3)).map(({ type: type15, value, stream: stream3 = value }) => waitForStream(stream3, fdNumber, streamInfo, {
  isSameDirection: TRANSFORM_TYPES.has(type15),
  stopOnExit: type15 === "native"
})));
var throwOnSubprocessError = async (subprocess, { signal: signal5 }) => {
  const [error2] = await once8(subprocess, "error", { signal: signal5 });
  throw error2;
};

// node_modules/execa/lib/convert/concurrent.js
var initializeConcurrentStreams = () => ({
  readableDestroy: new WeakMap,
  writableFinal: new WeakMap,
  writableDestroy: new WeakMap
});
var addConcurrentStream = (concurrentStreams, stream3, waitName) => {
  const weakMap = concurrentStreams[waitName];
  if (!weakMap.has(stream3)) {
    weakMap.set(stream3, []);
  }
  const promises11 = weakMap.get(stream3);
  const promise = createDeferred();
  promises11.push(promise);
  const resolve = promise.resolve.bind(promise);
  return { resolve, promises: promises11 };
};
var waitForConcurrentStreams = async ({ resolve, promises: promises11 }, subprocess) => {
  resolve();
  const [isSubprocessExit] = await Promise.race([
    Promise.allSettled([true, subprocess]),
    Promise.all([false, ...promises11])
  ]);
  return !isSubprocessExit;
};

// node_modules/execa/lib/convert/readable.js
import {Readable as Readable3} from "node:stream";
import {callbackify as callbackify2} from "node:util";

// node_modules/execa/lib/convert/shared.js
import {finished as finished6} from "node:stream/promises";
var safeWaitForSubprocessStdin = async (subprocessStdin) => {
  if (subprocessStdin === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdin(subprocessStdin);
  } catch {
  }
};
var safeWaitForSubprocessStdout = async (subprocessStdout) => {
  if (subprocessStdout === undefined) {
    return;
  }
  try {
    await waitForSubprocessStdout(subprocessStdout);
  } catch {
  }
};
var waitForSubprocessStdin = async (subprocessStdin) => {
  await finished6(subprocessStdin, { cleanup: true, readable: false, writable: true });
};
var waitForSubprocessStdout = async (subprocessStdout) => {
  await finished6(subprocessStdout, { cleanup: true, readable: true, writable: false });
};
var waitForSubprocess = async (subprocess, error2) => {
  await subprocess;
  if (error2) {
    throw error2;
  }
};
var destroyOtherStream = (stream3, isOpen, error2) => {
  if (error2 && !isStreamAbort(error2)) {
    stream3.destroy(error2);
  } else if (isOpen) {
    stream3.destroy();
  }
};

// node_modules/execa/lib/convert/readable.js
var createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const readable2 = new Readable3({
    read,
    destroy: callbackify2(onReadableDestroy.bind(undefined, { subprocessStdout, subprocess, waitReadableDestroy })),
    highWaterMark: readableHighWaterMark,
    objectMode: readableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: readable2,
    subprocess
  });
  return readable2;
};
var getSubprocessStdout = (subprocess, from, concurrentStreams) => {
  const subprocessStdout = getFromStream(subprocess, from);
  const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, "readableDestroy");
  return { subprocessStdout, waitReadableDestroy };
};
var getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary) => binary ? { readableEncoding, readableObjectMode, readableHighWaterMark } : { readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK };
var getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines }) => {
  const onStdoutDataDone = createDeferred();
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: !binary,
    encoding,
    preserveNewlines
  });
  return {
    read() {
      onRead(this, onStdoutData, onStdoutDataDone);
    },
    onStdoutDataDone
  };
};
var onRead = async (readable2, onStdoutData, onStdoutDataDone) => {
  try {
    const { value, done } = await onStdoutData.next();
    if (done) {
      onStdoutDataDone.resolve();
    } else {
      readable2.push(value);
    }
  } catch {
  }
};
var onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable: readable2, subprocess, subprocessStdin }) => {
  try {
    await waitForSubprocessStdout(subprocessStdout);
    await subprocess;
    await safeWaitForSubprocessStdin(subprocessStdin);
    await onStdoutDataDone;
    if (readable2.readable) {
      readable2.push(null);
    }
  } catch (error2) {
    await safeWaitForSubprocessStdin(subprocessStdin);
    destroyOtherReadable(readable2, error2);
  }
};
var onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error2) => {
  if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
    destroyOtherReadable(subprocessStdout, error2);
    await waitForSubprocess(subprocess, error2);
  }
};
var destroyOtherReadable = (stream3, error2) => {
  destroyOtherStream(stream3, stream3.readable, error2);
};

// node_modules/execa/lib/convert/writable.js
import {Writable as Writable3} from "node:stream";
import {callbackify as callbackify3} from "node:util";
var createWritable = ({ subprocess, concurrentStreams }, { to } = {}) => {
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const writable2 = new Writable3({
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify3(onWritableDestroy.bind(undefined, {
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    })),
    highWaterMark: subprocessStdin.writableHighWaterMark,
    objectMode: subprocessStdin.writableObjectMode
  });
  onStdinFinished(subprocessStdin, writable2);
  return writable2;
};
var getSubprocessStdin = (subprocess, to, concurrentStreams) => {
  const subprocessStdin = getToStream(subprocess, to);
  const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, "writableFinal");
  const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, "writableDestroy");
  return { subprocessStdin, waitWritableFinal, waitWritableDestroy };
};
var getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
  write: onWrite.bind(undefined, subprocessStdin),
  final: callbackify3(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal))
});
var onWrite = (subprocessStdin, chunk, encoding, done) => {
  if (subprocessStdin.write(chunk, encoding)) {
    done();
  } else {
    subprocessStdin.once("drain", done);
  }
};
var onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
  if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
    if (subprocessStdin.writable) {
      subprocessStdin.end();
    }
    await subprocess;
  }
};
var onStdinFinished = async (subprocessStdin, writable2, subprocessStdout) => {
  try {
    await waitForSubprocessStdin(subprocessStdin);
    if (writable2.writable) {
      writable2.end();
    }
  } catch (error2) {
    await safeWaitForSubprocessStdout(subprocessStdout);
    destroyOtherWritable(writable2, error2);
  }
};
var onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error2) => {
  await waitForConcurrentStreams(waitWritableFinal, subprocess);
  if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
    destroyOtherWritable(subprocessStdin, error2);
    await waitForSubprocess(subprocess, error2);
  }
};
var destroyOtherWritable = (stream3, error2) => {
  destroyOtherStream(stream3, stream3.writable, error2);
};

// node_modules/execa/lib/convert/duplex.js
import {Duplex as Duplex3} from "node:stream";
import {callbackify as callbackify4} from "node:util";
var createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const duplex2 = new Duplex3({
    read,
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: callbackify4(onDuplexDestroy.bind(undefined, {
      subprocessStdout,
      subprocessStdin,
      subprocess,
      waitReadableDestroy,
      waitWritableFinal,
      waitWritableDestroy
    })),
    readableHighWaterMark,
    writableHighWaterMark: subprocessStdin.writableHighWaterMark,
    readableObjectMode,
    writableObjectMode: subprocessStdin.writableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: duplex2,
    subprocess,
    subprocessStdin
  });
  onStdinFinished(subprocessStdin, duplex2, subprocessStdout);
  return duplex2;
};
var onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error2) => {
  await Promise.all([
    onReadableDestroy({ subprocessStdout, subprocess, waitReadableDestroy }, error2),
    onWritableDestroy({
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    }, error2)
  ]);
};

// node_modules/execa/lib/convert/iterable.js
var createIterable = (subprocess, encoding, {
  from,
  binary: binaryOption = false,
  preserveNewlines = false
} = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const subprocessStdout = getFromStream(subprocess, from);
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: true,
    encoding,
    preserveNewlines
  });
  return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
var iterateOnStdoutData = async function* (onStdoutData, subprocessStdout, subprocess) {
  try {
    yield* onStdoutData;
  } finally {
    if (subprocessStdout.readable) {
      subprocessStdout.destroy();
    }
    await subprocess;
  }
};

// node_modules/execa/lib/convert/add.js
var addConvertedStreams = (subprocess, { encoding }) => {
  const concurrentStreams = initializeConcurrentStreams();
  subprocess.readable = createReadable.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.writable = createWritable.bind(undefined, { subprocess, concurrentStreams });
  subprocess.duplex = createDuplex.bind(undefined, { subprocess, concurrentStreams, encoding });
  subprocess.iterable = createIterable.bind(undefined, subprocess, encoding);
  subprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});
};

// node_modules/execa/lib/methods/promise.js
var mergePromise = (subprocess, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = descriptor.value.bind(promise);
    Reflect.defineProperty(subprocess, property, { ...descriptor, value });
  }
};
var nativePromisePrototype = (async () => {
})().constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);

// node_modules/execa/lib/methods/main-async.js
var execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
  const { file, commandArguments, command: command3, escapedCommand, startTime, verboseInfo, options: options3, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
  const { subprocess, promise: promise2 } = spawnSubprocessAsync({
    file,
    commandArguments,
    options: options3,
    startTime,
    verboseInfo,
    command: command3,
    escapedCommand,
    fileDescriptors
  });
  subprocess.pipe = pipeToSubprocess.bind(undefined, {
    source: subprocess,
    sourcePromise: promise2,
    boundOptions: {},
    createNested
  });
  mergePromise(subprocess, promise2);
  SUBPROCESS_OPTIONS.set(subprocess, { options: options3, fileDescriptors });
  return subprocess;
};
var handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command: command3, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
  const options3 = handleAsyncOptions(normalizedOptions);
  const fileDescriptors = handleStdioAsync(options3, verboseInfo);
  return {
    file,
    commandArguments,
    command: command3,
    escapedCommand,
    startTime,
    verboseInfo,
    options: options3,
    fileDescriptors
  };
};
var handleAsyncOptions = ({ timeout: timeout3, signal: signal5, ...options3 }) => {
  if (signal5 !== undefined) {
    throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
  }
  return { ...options3, timeoutDuration: timeout3 };
};
var spawnSubprocessAsync = ({ file, commandArguments, options: options3, startTime, verboseInfo, command: command3, escapedCommand, fileDescriptors }) => {
  let subprocess;
  try {
    subprocess = spawn(file, commandArguments, options3);
  } catch (error2) {
    return handleEarlyError({
      error: error2,
      command: command3,
      escapedCommand,
      fileDescriptors,
      options: options3,
      startTime,
      verboseInfo
    });
  }
  const controller = new AbortController;
  setMaxListeners(Number.POSITIVE_INFINITY, controller.signal);
  const originalStreams = [...subprocess.stdio];
  pipeOutputAsync(subprocess, fileDescriptors, controller);
  cleanupOnExit(subprocess, options3, controller);
  const context = {};
  const onInternalError = createDeferred();
  subprocess.kill = subprocessKill.bind(undefined, {
    kill: subprocess.kill.bind(subprocess),
    options: options3,
    onInternalError,
    context,
    controller
  });
  subprocess.all = makeAllStream(subprocess, options3);
  addConvertedStreams(subprocess, options3);
  addIpcMethods(subprocess, options3);
  const promise2 = handlePromise({
    subprocess,
    options: options3,
    startTime,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    command: command3,
    escapedCommand,
    context,
    onInternalError,
    controller
  });
  return { subprocess, promise: promise2 };
};
var handlePromise = async ({ subprocess, options: options3, startTime, verboseInfo, fileDescriptors, originalStreams, command: command3, escapedCommand, context, onInternalError, controller }) => {
  const [
    errorInfo,
    [exitCode, signal5],
    stdioResults,
    allResult,
    ipcOutput
  ] = await waitForSubprocessResult({
    subprocess,
    options: options3,
    context,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    onInternalError,
    controller
  });
  controller.abort();
  onInternalError.resolve();
  const stdio3 = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options3, fdNumber));
  const all = stripNewline(allResult, options3, "all");
  const result5 = getAsyncResult({
    errorInfo,
    exitCode,
    signal: signal5,
    stdio: stdio3,
    all,
    ipcOutput,
    context,
    options: options3,
    command: command3,
    escapedCommand,
    startTime
  });
  return handleResult(result5, verboseInfo, options3);
};
var getAsyncResult = ({ errorInfo, exitCode, signal: signal5, stdio: stdio3, all, ipcOutput, context, options: options3, command: command3, escapedCommand, startTime }) => ("error" in errorInfo) ? makeError({
  error: errorInfo.error,
  command: command3,
  escapedCommand,
  timedOut: context.terminationReason === "timeout",
  isCanceled: context.terminationReason === "cancel" || context.terminationReason === "gracefulCancel",
  isGracefullyCanceled: context.terminationReason === "gracefulCancel",
  isMaxBuffer: errorInfo.error instanceof MaxBufferError,
  isForcefullyTerminated: context.isForcefullyTerminated,
  exitCode,
  signal: signal5,
  stdio: stdio3,
  all,
  ipcOutput,
  options: options3,
  startTime,
  isSync: false
}) : makeSuccessResult({
  command: command3,
  escapedCommand,
  stdio: stdio3,
  all,
  ipcOutput,
  options: options3,
  startTime
});

// node_modules/execa/lib/methods/bind.js
var mergeOptions = (boundOptions, options3) => {
  const newOptions = Object.fromEntries(Object.entries(options3).map(([optionName, optionValue]) => [
    optionName,
    mergeOption(optionName, boundOptions[optionName], optionValue)
  ]));
  return { ...boundOptions, ...newOptions };
};
var mergeOption = (optionName, boundOptionValue, optionValue) => {
  if (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {
    return { ...boundOptionValue, ...optionValue };
  }
  return optionValue;
};
var DEEP_OPTIONS = new Set(["env", ...FD_SPECIFIC_OPTIONS]);

// node_modules/execa/lib/methods/create.js
var createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
  const createNested = (mapArguments2, boundOptions2, setBoundExeca2) => createExeca(mapArguments2, boundOptions2, deepOptions, setBoundExeca2);
  const boundExeca = (...execaArguments) => callBoundExeca({
    mapArguments,
    deepOptions,
    boundOptions,
    setBoundExeca,
    createNested
  }, ...execaArguments);
  if (setBoundExeca !== undefined) {
    setBoundExeca(boundExeca, createNested, boundOptions);
  }
  return boundExeca;
};
var callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments) => {
  if (isPlainObject(firstArgument)) {
    return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
  }
  const { file, commandArguments, options: options3, isSync } = parseArguments({
    mapArguments,
    firstArgument,
    nextArguments,
    deepOptions,
    boundOptions
  });
  return isSync ? execaCoreSync(file, commandArguments, options3) : execaCoreAsync(file, commandArguments, options3, createNested);
};
var parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions }) => {
  const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [firstArgument, ...nextArguments];
  const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
  const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
  const {
    file = initialFile,
    commandArguments = initialArguments,
    options: options3 = mergedOptions,
    isSync = false
  } = mapArguments({ file: initialFile, commandArguments: initialArguments, options: mergedOptions });
  return {
    file,
    commandArguments,
    options: options3,
    isSync
  };
};

// node_modules/execa/lib/methods/command.js
var mapCommandAsync = ({ file, commandArguments }) => parseCommand(file, commandArguments);
var mapCommandSync = ({ file, commandArguments }) => ({ ...parseCommand(file, commandArguments), isSync: true });
var parseCommand = (command3, unusedArguments) => {
  if (unusedArguments.length > 0) {
    throw new TypeError(`The command and its arguments must be passed as a single string: ${command3} ${unusedArguments}.`);
  }
  const [file, ...commandArguments] = parseCommandString(command3);
  return { file, commandArguments };
};
var parseCommandString = (command3) => {
  if (typeof command3 !== "string") {
    throw new TypeError(`The command must be a string: ${String(command3)}.`);
  }
  const trimmedCommand = command3.trim();
  if (trimmedCommand === "") {
    return [];
  }
  const tokens = [];
  for (const token of trimmedCommand.split(SPACES_REGEXP)) {
    const previousToken = tokens.at(-1);
    if (previousToken && previousToken.endsWith("\\")) {
      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
    } else {
      tokens.push(token);
    }
  }
  return tokens;
};
var SPACES_REGEXP = / +/g;

// node_modules/execa/lib/methods/script.js
var setScriptSync = (boundExeca, createNested, boundOptions) => {
  boundExeca.sync = createNested(mapScriptSync, boundOptions);
  boundExeca.s = boundExeca.sync;
};
var mapScriptAsync = ({ options: options3 }) => getScriptOptions(options3);
var mapScriptSync = ({ options: options3 }) => ({ ...getScriptOptions(options3), isSync: true });
var getScriptOptions = (options3) => ({ options: { ...getScriptStdinOption(options3), ...options3 } });
var getScriptStdinOption = ({ input, inputFile, stdio: stdio3 }) => input === undefined && inputFile === undefined && stdio3 === undefined ? { stdin: "inherit" } : {};
var deepScriptOptions = { preferLocal: true };

// node_modules/execa/index.js
var execa = createExeca(() => ({}));
var execaSync = createExeca(() => ({ isSync: true }));
var execaCommand = createExeca(mapCommandAsync);
var execaCommandSync = createExeca(mapCommandSync);
var execaNode = createExeca(mapNode);
var $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
var {
  sendMessage: sendMessage2,
  getOneMessage: getOneMessage2,
  getEachMessage: getEachMessage2,
  getCancelSignal: getCancelSignal2
} = getIpcExport();

// src/index.ts
var core2 = __toESM(require_core(), 1);
var tool_cache = __toESM(require_tool_cache(), 1);
var cache = __toESM(require_cache2(), 1);
var import_semver = __toESM(require_semver3(), 1);
import {existsSync, readFileSync as readFileSync3, chmodSync} from "fs";
import {join} from "path";
async function run() {
  try {
    checkPlatformCompatibility();
    const inputVersion = core2.getInput("version");
    const cacheEnabled = core2.getInput("cache") === "true";
    const inputCacheKey = core2.getInput("cache-key");
    const inputCachePath = core2.getInput("cache-path");
    let version;
    if (inputVersion) {
      version = inputVersion;
    } else {
      version = await detectFlutterGenVersion();
      if (!version) {
        throw new Error("FlutterGen version not found. Please specify it explicitly or add it to your project configuration.");
      }
    }
    if (!import_semver.valid(version)) {
      throw new Error(`Invalid version format: ${version}`);
    }
    let cacheKey;
    if (inputCacheKey) {
      cacheKey = inputCacheKey;
    } else {
      cacheKey = `fluttergen-${process.platform}-${process.arch}-${version}`;
    }
    let cachePath;
    if (inputCachePath) {
      cachePath = inputCachePath;
    } else {
      cachePath = join(process.env.RUNNER_TOOL_CACHE, ".fluttergen");
    }
    const installedPath = await installFlutterGen(version, cacheEnabled, cacheKey, cachePath);
    core2.info(`FlutterGen installed: ${installedPath}`);
    await makeExecutable(installedPath);
    await execa("fluttergen", ["--version"], { stdio: "inherit" });
    core2.setOutput("version", version);
  } catch (error2) {
    if (error2 instanceof Error) {
      core2.setFailed(error2.message);
    } else {
      core2.setFailed("An unexpected error occurred.");
    }
  }
}
function checkPlatformCompatibility() {
  if (process.platform !== "linux" && process.platform !== "darwin") {
    throw new Error(`Unsupported platform: ${process.platform}`);
  }
}
async function detectFlutterGenVersion() {
  const toolVersionsPath = join(process.env.GITHUB_WORKSPACE, ".tool-versions");
  if (existsSync(toolVersionsPath)) {
    const content = readFileSync3(toolVersionsPath, "utf-8");
    const match = content.match(/fluttergen\s*(\d+\.\d+\.\d+)/m);
    if (match) {
      return match[1];
    }
  }
  const miseTomlPath = join(process.env.GITHUB_WORKSPACE, ".mise.toml");
  if (existsSync(miseTomlPath)) {
    const content = readFileSync3(miseTomlPath, "utf-8");
    const match = content.match(/fluttergen\s*=\s*("|')(\d+\.\d+\.\d+)("|')/m);
    if (match) {
      return match[2];
    }
  }
  return;
}
async function installFlutterGen(version, cacheEnabled, cacheKey, cachePath) {
  if (cacheEnabled) {
    const hitCacheKey = await cache.restoreCache([cachePath], cacheKey);
    if (hitCacheKey) {
      core2.info(`Restored FlutterGen from cache: ${cachePath}`);
      return cachePath;
    }
  }
  core2.info(`Downloading FlutterGen version ${version}`);
  const platform2 = process.platform === "darwin" ? "macos" : process.platform;
  const downloadUrl = `https://github.com/FlutterGen/flutter_gen/releases/download/v${version}/fluttergen-${platform2}.tar.gz`;
  const downloadPath = await tool_cache.downloadTool(downloadUrl);
  const extractDir = await tool_cache.extractTar(downloadPath, cachePath);
  if (cacheEnabled) {
    await cache.saveCache([extractDir], cacheKey);
    core2.info(`Saved FlutterGen to cache: ${extractDir}`);
  }
  return extractDir;
}
async function makeExecutable(installedPath) {
  const fluttergenPath = join(installedPath, "fluttergen");
  chmodSync(fluttergenPath, 755);
  core2.addPath(installedPath);
}
run();

//# debugId=2ECF789E3C76642064756E2164756E21
